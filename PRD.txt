Product Requirements Document: AI Assistant Swarm System
Overview and Objectives
The AI Assistant Swarm is a fully locally-hosted multi-agent assistant system designed for beginner Python users. It provides a cooperative network of specialized AI agents to help with programming, medical inquiries, and general tasks without any cloud dependencies. The goal is to create an intuitive and secure assistant that leverages multiple local AI models to handle different domains, all orchestrated seamlessly for the end-user. This PRD outlines the core features, technical requirements, performance targets, security considerations, and development roadmap for the system, with guidance aimed at a junior developer for clarity.
Core Functionalities
Multi-Agent Swarm Architecture
Specialized Agents: The system consists of multiple AI agents, each an expert in a specific domain or task. For the initial version, the key agents and their roles include:
Medical Specialist – Powered by the Gemma3 27B model, specialized in medical and health-related queries. This agent provides detailed yet beginner-friendly explanations for medical questions and analyzes medical documents.
Senior Python Developer – Powered by the DeepSeek-RAG model, acting as a coding mentor. This agent helps users with Python programming questions, code debugging, and examples, using retrieval-augmented generation to provide accurate and context-rich answers.
Master Orchestrator – Powered by the Qwen model, serving as the central coordinator. The orchestrator agent handles general user interactions and delegates tasks to the appropriate specialist agent based on the query. For example, a medical question is routed to the Medical Specialist, while a coding question goes to the Python Developer.
Fallback Agent(s): Other queries or unsupported tasks are handled by a general-purpose fallback agent (could be the orchestrator itself or a default large model). In this first iteration, agent selection is mostly rule-based (if medical then Gemma3, if coding then DeepSeek, otherwise fallback). The system is designed with future dynamic agent selection in mind, where the orchestrator will intelligently choose the best model for each task on the fly using context and model capabilities.
Agent Collaboration: The agents can collaborate through the orchestrator. For complex requests, the orchestrator might break down the task and involve multiple agents. For instance, a query requiring coding and a bit of medical context could see the orchestrator ask the Medical Specialist for info, then have the Python Developer agent use that info in code, merging their results before responding to the user. This cooperative approach ensures each query is handled by the most qualified model(s).
Beginner-Friendly Interaction: The system’s responses are tailored for a beginner. The Python Developer agent, for example, not only provides code solutions but also explains them in simple terms and offers guidance on how to run or modify the code. The Medical Specialist avoids heavy jargon and clearly explains medical terms. The orchestrator ensures the overall tone remains helpful and not overwhelming.
User Interface and Interaction
Command-Line Interface (CLI): A simple CLI will allow users to interact with the swarm. Users can type questions or commands and optionally specify an agent (e.g., prefix a question with "Medical:" to direct to the Medical Specialist, or "Code:" for the Python Developer). If no agent is specified, the Master Orchestrator will interpret the query and route it accordingly.
Web Interface (Gradio): For a more user-friendly experience, a basic web UI will be built using Gradio. Gradio provides a quick way to create a chat interface in the browser gradio.app . The web UI will have:
A dropdown or buttons to select a specific agent or an "Auto" mode (handled by the orchestrator).
A chat area where the user enters queries and receives responses (with streaming text if possible, for immediacy).
Basic session management, allowing the user to reset the conversation or switch agents.
Chat and Context Management: The system maintains context within a session. If a user is having a conversation with the Python Developer agent, the agent will remember the previous questions and code discussed (within the limits of the memory system) to provide better answers. The orchestrator also maintains high-level context; if the user switches agents or topics, it provides relevant session context to the new agent when appropriate.
Technical Requirements
Local Models and Mappings
Pre-Installed Ollama Models: The system uses Ollama to run all language models locally. Each agent is mapped to a specific model that must be installed on the user's machine:
Gemma3 27B for the Medical Specialist. (Ensure the model file is downloaded and in Ollama’s library. Gemma3 is a powerful local model known for strong performance comparable to larger cloud models.)
DeepSeek-RAG for the Senior Python Developer. (DeepSeek-RAG is a reasoning model with retrieval capabilities, ideal for providing factual, code-specific answers by searching an embedded knowledge base.)
Qwen for the Master Orchestrator. (Qwen is a general-purpose large model effective at understanding queries and dividing tasks. It will manage inter-agent communication.)
Default fallback model (could be a smaller general LLaMA-based model) for any other tasks or as a backup if specialized models are not confident.
Local Execution (Zero Cloud Dependency): All model inference happens locally on the user’s hardware. No cloud APIs or internet calls are required, which means the system works fully offline. Once the necessary models are downloaded, the user can use the assistant anywhere with complete privacy. This requires that the system is optimized to run on local resources (possibly leveraging GPU if available, or using quantized models for CPU).
Integration Frameworks: The development will leverage existing frameworks to simplify working with LLMs:
LangChain: Used to orchestrate the chain-of-thought and agent behaviors. LangChain is a framework that helps build applications powered by language models, offering tools for sequencing prompts, managing memory, and integrating with external data. It will help implement the logic for the orchestrator agent and the tool-use by agents (like searching memory or running code).
LlamaIndex: Used for connecting LLM agents with external data sources (documents, PDFs, etc.). LlamaIndex (formerly GPT Index) provides simple interfaces to index and query documents with LLMs. In our system, it will assist in indexing large text (like PDFs or knowledge base articles) so agents can retrieve info from them efficiently.
Memory System and Data Retention
Vector Database (ChromaDB): Long-term memory for the AI swarm is handled by ChromaDB, an open-source vector database for storing embeddings of text. Whenever a new document is ingested or a significant conversation occurs, the system creates embeddings (numerical vector representations) of the content and stores them in ChromaDB. This enables semantic search – agents can query the vector store to retrieve contextually relevant information from past interactions or documents when needed.
Retention Policies: Different types of data have different retention and compression strategies to balance memory vs. recall:
Research Papers: Stored indefinitely in a compressed form. When the user inputs or the system ingests a research paper, the content is summarized and key data (important findings, statistics, conclusions) are extracted. The full text may be compressed (or only stored as embeddings and summary) to save space, but the critical information is retained forever for future queries. This ensures that even months later, the assistant can recall core insights from academic papers.
Chat Logs / PDFs: Casual conversation logs or general PDF documents are kept for 1 year. They are stored with full-text embeddings to allow semantic search. This means the assistant can recall details from a conversation or document within the last year as if it were still in context. After 1 year, these entries may be archived or deleted to reduce storage load, assuming they are less likely to be needed. (In future enhancements, we might implement a grace period or user prompt before deletion.)
Medical Documents: Medical records or documents are kept forever in hot storage. "Hot storage" implies they're readily accessible without delay. Because medical data can be critical, the system never deletes it and stores it in a way that it can be quickly retrieved and cross-validated. Additionally, multi-layer validation is applied for medical info: when the Medical Specialist agent fetches medical records from memory, the data may be cross-checked by additional rules or even a second pass by the LLM to ensure accuracy before use (to avoid using outdated or incorrect medical info).
Context-Aware Retrieval: When answering questions, agents will fetch relevant information from the memory automatically. For example, if the user asks a follow-up question referring to "the previous result" or some topic discussed earlier, the agent uses the vector store to find the relevant context from prior conversation history or documents. The retrieval is based on semantic similarity, so even if the user doesn't use exact keywords, the correct context can be found. The system also updates indexes on the fly – whenever new info is added (like a new PDF is uploaded or a new conversation session starts), the ChromaDB index is updated so that it’s immediately searchable.
Memory Management: To ensure efficient use of memory and storage:
Large texts are summarized when possible (for storage) while preserving vectors for detail lookup. This is inspired by techniques where conversation histories are summarized into vectors to allow long-term memory without huge text logs.
We set size thresholds so the vector database doesn’t grow unbounded. For instance, for chat logs beyond one year, entries might be moved to an archive (possibly still queryable but not loaded by default).
The system will provide tools or scripts to compact or backup the ChromaDB periodically (especially for long-running installations).
Performance Benchmarks and Targets
To ensure a smooth user experience, the system must meet the following performance benchmarks (on typical modern local hardware, e.g., a mid-range GPU or high-end CPU):
Single-Agent Query Latency: When the user asks a question that only involves one agent’s response (no complex orchestration needed), the system should respond within 5 seconds on average. Target: <5s per single-agent query. Failure threshold: >8s is considered too slow and must be optimized (e.g., by using a smaller model variant or optimizing the prompt pipeline).
Concurrent Agents Response Time: For queries that require multiple agents (e.g., orchestrator + specialist) or parallel tasks, the response should be reasonably quick. Target: <12s for a response involving up to 3 agents working concurrently. This includes the time for the orchestrator to gather responses from, say, the Medical and Python agents and compile an answer. Failure threshold: >15s for a multi-agent interaction. To meet this, we may need to ensure models run in parallel threads/processes if possible, or serialize tasks efficiently.
Document Ingestion Speed: When a user provides a new document (for example, uploading a 10-page PDF for the assistant to remember or analyze), the system should process it quickly. Target: A 10-page PDF is processed (text extracted, embeddings generated, stored in vector DB) in <30 seconds. This includes any summarization. Failure threshold: >1 minute for a 10-page document. If the document is larger, the processing time can scale linearly (e.g., 20 pages ~ 60s target). Techniques like incremental embedding or using efficient text splitters will be employed to speed this up.
Memory Recall Accuracy: The system’s ability to recall information from memory after a period is crucial. For a query about something that happened 24 hours ago (in a prior session), the assistant should recall with high fidelity. Target: 95% accuracy in recalling facts/context from 24 hours earlier. This might be measured by testing the assistant on known prompts from a day before and seeing if it correctly uses the context. Failure threshold: <90% accuracy. If the assistant frequently forgets or confuses context from just a day ago, the memory retrieval approach needs improvement (through better embedding, chunking, or prompt strategy to inject retrieved memory into the agent's context window).
Resource Utilization: (Informational) The system should be mindful of CPU/GPU and RAM usage since it’s running locally. While not hard numbers, the goal is to run the 3 main models concurrently on a typical dev machine (e.g., 16GB RAM, one GPU with 12GB VRAM or CPU inference) without exhausting resources. This might involve using quantized models (like 4-bit or 8-bit quantization) to reduce memory footprint, and loading/unloading models as needed. If resources are very limited, the system should degrade gracefully (e.g., warn the user or switch to a smaller model).
Security and Privacy Considerations
Local-Only Data Storage: All data – including conversation logs, documents, and embeddings – are stored locally on the user’s machine. No data is sent to any cloud or external server. This guarantees user privacy and confidentiality of sensitive information. By running entirely offline and using local models, the system ensures complete data control by the user. This is especially important for medical or personal data which must remain private.
Data Encryption at Rest: (For future or optional implementation) Consider encrypting the local database (ChromaDB) or any saved conversation logs on disk, so that if someone gains access to the file system they cannot easily read the content. This might be an advanced feature, but even a simple password-based encryption for the stored vectors could be beneficial for sensitive deployments.
Error Handling and Validation: The system will include robust error handling to prevent crashes or undefined behaviors. For example:
If a model fails to load or generate (out-of-memory or other errors), the orchestrator catches this and returns a friendly error message to the user (and possibly suggests a solution, like closing other apps or using a smaller model).
Input validation: The CLI and web UI should sanitize inputs (to avoid injection of unwanted commands in a prompt that might confuse the agent framework). Also ensure file paths or URLs provided by the user are handled securely (if we extend to allow the assistant to read files, etc., make sure it cannot be tricked into reading system files outside allowed scope).
Each agent’s output can be validated by the orchestrator if possible. For instance, if the Python Developer agent returns code, the orchestrator might run a quick syntax check or test on that code (in a sandbox) to verify it runs without errors, before sending it to the user. This extra step can catch obvious hallucinations or mistakes in code.
Preventing AI Hallucinations (especially in code): AI models sometimes produce confident but incorrect answers (hallucinations). This is a known issue, particularly for code generation where a model might output code that looks correct but won't run. To mitigate this:
The Python Developer agent will be instructed via its system prompt to only provide tested, verified code snippets. Encourage it to run a mental trace of the code or use a small internal interpreter if available (some frameworks allow execution of code through tools).
We can integrate a tool in LangChain for the Python agent: a sandboxed Python REPL where it can execute code and verify outputs. The agent can use this to ensure the code compiles/runs and solve simple test cases before finalizing the answer (this uses LangChain’s tool usage abilities).
For factual queries (medical or others), the agents should cite from the stored documents or their training data. We might implement a format where the assistant provides references from memory for the user to trust the information (especially for medical answers, referencing the source document or known medical guidelines).
The orchestrator can perform a second-pass sanity check. If an agent’s answer seems off (e.g., contains apologetic language or seems to diverge from known context), the orchestrator might ask the agent to double-check or even ask another agent to verify the answer (a form of cross-examination among agents).
Memory Management Best Practices: Running multiple large models can be memory-intensive. Some practices to ensure stability:
Load models on demand: The system might not load all models into RAM at once. For example, if the first question is medical, it loads Gemma3; if the next is coding, it may unload Gemma3 if memory is limited and load DeepSeek. Advanced optimization can keep frequently used models in memory and unload idle ones.
Use quantized model versions to reduce memory usage (with minimal impact on quality).
Monitor memory and provide user feedback: If the user’s machine is running low on RAM or VRAM, the system can warn about potential slowdowns. Possibly include a performance diagnostics command (in CLI) to show which models are loaded and memory usage, so a user can decide to unload some.
Ensure that the vector database does not consume excessive disk space. As mentioned in retention, limit unbounded growth by cleaning up old data and compressing where possible. Also, handle vector search efficiently to avoid high CPU usage on every query (ChromaDB is optimized for speed, but we should also limit the number of vectors searched via metadata or indexing optimizations).
Implementation Roadmap
To build the AI Assistant Swarm, development will progress through phased milestones. Each phase ensures the system is functional and testable before moving to the next, providing a clear path for a junior developer to follow:
Phase 1: Core Agent Integration – Set up the foundation of the multi-agent system.
Model Setup: Install and configure the required Ollama models (Gemma3 27B, DeepSeek-RAG, Qwen, etc.). Confirm each model runs in isolation via Ollama.
Basic Agent Classes: Using LangChain (or a simple custom framework), create agent classes for each role (Medical Specialist, Python Developer, etc.) with hardcoded model backends. At this stage, the agents can be simple: they take input, maybe add a role-specific system prompt (e.g., “You are a medical expert...”), then call the model to get a response.
Master Orchestrator Logic: Implement the orchestrator agent that can receive any user query, determine which specialized agent (or agents) should handle it, forward the query, and return the answer. This can be rule-based initially (e.g., detect keywords or use a prefix command as mentioned). For now, no learning or complex routing – just straightforward mapping.
Test Cases: Verify that each agent works: ask a medical question and see that it goes through the Medical model, ask a coding question for the Python model. Ensure the orchestrator returns the answer appropriately. Identify any major issues with model responses (e.g., if answers are too long or off-topic, adjust the prompts).
Phase 2: Memory System with ChromaDB – Integrate long-term memory capabilities so agents can store and retrieve information.
Set Up ChromaDB: Install and initialize a ChromaDB instance (likely as a local server or in-memory if data is small). Define collections in the vector DB for different data types (e.g., research_papers, chats, medical_docs).
Embed and Store: Use an embedding model (could be a smaller sentence transformer or even the LLMs themselves via LlamaIndex) to vectorize text. Implement functions for agents or a dedicated memory service to: a) Add to Memory: Take a document or conversation transcript, break it into chunks (if large), generate embeddings, and store in ChromaDB with metadata (date, type, source agent, etc.). b) Retrieve from Memory: Given a query or context (e.g., the current conversation), query ChromaDB for similar vectors to fetch relevant text snippets or summaries.
Retention Policy Logic: Implement the rules for retention. For example, mark entries with an expiration date for chat logs (so the system can filter out or remove entries older than 1 year in the chats collection). Ensure that when adding a research paper or medical document, a flag is set that it should never be deleted. Possibly implement compression: after adding a research paper, also store a summary of it in a separate research_summaries collection for quick reference.
Agent Integration: Modify agents (and orchestrator) to use the memory system. For instance, before the Medical Specialist answers a question, it should check ChromaDB for any stored info that might help (like if the question is about "diabetes treatment" and the user had previously uploaded a research PDF on diabetes, the agent should retrieve that and use it to provide a more informed answer). Similarly, the Python agent could store snippets of previous coding discussions so it can recall user’s coding style or past errors.
Testing: Simulate a scenario: upload a PDF, ask questions about it immediately and then again after saving to memory, ensure the agent can recall information. Test that an older conversation (simulate by writing to the DB with an old timestamp) gets ignored if beyond retention policy. Validate that irrelevant memory is not pulled in (the semantic search returns relevant context).
Phase 3: User Interface (CLI & Web UI) – Develop the interfaces for users to interact with the assistant swarm.
Command-Line Interface: Implement a CLI application (could be a simple Python script using readline or just input/output in a loop). Features:
Accept user input, check if it contains an agent prefix or special command.
If it’s a normal query, send it to orchestrator and print the response.
If it’s a special command (e.g., /switch agent or /load file), handle accordingly (maybe allow user to manually specify agent, or load a document into memory).
Support multi-turn chat in the CLI – possibly by keeping the conversation context in a list and sending it as part of the prompt for continuity (though the vector memory also helps with long-term context).
Gradio Web UI: Create a simple Gradio app to allow chat through a browser. Gradio can create text input and output components easily. The UI should have:
A text box for queries and a send button.
A way to select agent or mode. This could be a radio button list: "Auto (Orchestrator)", "Medical Specialist", "Python Developer", etc. In Auto mode, the orchestrator decides; in a specific mode, the query goes directly to that agent (or instructs orchestrator to route only to that one).
Display the conversation history in a chat format (user messages on one side, agent replies on the other).
Behind the scenes, on each submission, call the Python backend which uses the orchestrator/agent to get a response. Use streaming response if possible for better experience (Gradio supports streaming text responses to mimic real-time typing).
File Uploads: If feasible with Gradio, include an upload button for documents. This will let the user add a PDF or text file to the system memory. The backend should receive the file, process it (Phase 2 functionality), and confirm to the user that it’s stored. Then the user can ask questions about it.
User Guidance: Because the target users are beginners, ensure the UI provides hints. For example, the web UI can have placeholder text like "Ask a question, e.g. 'How do I write a Python loop?'" for the Python agent. Or a note that says "For medical questions, select the Medical Specialist agent."
Testing & UX: Try out the interfaces with sample queries. Make sure the CLI doesn’t crash on invalid input. For the web UI, test in a browser; ensure the conversation flows properly. Check that switching agents in the dropdown truly changes which model responds. Also verify that the memory retrieval from Phase 2 still works via these interfaces (the back-end logic should be the same).
Phase 4: Performance Optimization and Memory Handling – Refine the system to meet the performance benchmarks and be robust in extended use.
Profiling: Measure the response times for various types of queries (single agent vs multi-agent, short vs long context) on the target hardware. Identify bottlenecks. For example, if loading a model each time is slow, consider keeping it loaded. If vector search is slow, see if filtering by metadata (like limiting to certain collections) improves speed.
Parallelism: Update the orchestrator to handle agents in parallel if possible. For instance, if a query could be answered by either of two agents (like both medical and general knowledge), perhaps run both and see who gives the better answer or combine answers. Or if one agent needs to do two things (retrieve info and then answer), maybe do retrieval asynchronously. Use Python’s async features or multi-threading where appropriate to overlap operations and reduce total wait time.
Memory Footprint: Evaluate the memory usage when all agents are active. If it’s too high, implement a smart loading mechanism: e.g., load models on first use, and possibly unload the largest model if it hasn’t been used for a while (to free RAM). There could be a background thread to handle this. Clearly comment this mechanism so a junior dev can understand or adjust thresholds (like how to decide when to unload).
Caching Responses: For repeated questions or known queries, consider caching answers. If a user asks the exact same question twice, the second time should be near-instant (retrieve answer from a cache rather than recompute). This can be as simple as a dictionary of recent Q->A mappings or something more persistent. Be careful to invalidate cache when memory or context updates that could change the answer.
Refining Memory Retrieval: Improve the context injection from memory. For example, if multiple relevant pieces of information are found in ChromaDB, decide how to include them in the prompt (maybe summarize them first to avoid prompt overflow). Tune the number of vectors retrieved or the similarity threshold to balance relevance vs noise. Possibly integrate a feedback loop: if the agent’s answer missed something that was in memory, adjust retrieval parameters.
Hallucination Reduction: Evaluate some outputs to see if hallucinations still occur. If yes, implement further tweaks: e.g., more strict system prompts, or using a verification agent. Perhaps introduce a "Critic agent" concept: after an answer is produced, another smaller agent quickly reviews it for correctness or consistency (particularly for code, it could be a linting or test run; for medical, check against known data). This is an advanced idea, so implement if time permits.
User Testing: If possible, have a few users (especially beginners) try the system at this stage. Gather feedback on response quality, speed, and ease of use. Optimize the system based on this feedback (e.g., if users find the need to manually switch agents confusing, perhaps improve the auto-detection in orchestrator or the UI wording).
Phase 5: Dynamic Agent Selection and Advanced Features – Enhance the system with intelligent routing and new capabilities once the core is solid.
Dynamic Orchestration: Upgrade the Master Orchestrator with a more sophisticated decision mechanism. This could involve using a classification model or prompt-based reasoning where Qwen (or another meta-model) reads the user query and decides which agent or chain of agents is best suited. Instead of simple rules, it can analyze the query (maybe using few-shot examples in the prompt: "if query is about medical, choose medical agent; if about coding, choose coding agent; if ambiguous, ask clarifying question or choose best fit"). This makes the system more extensible as new agents are added – the orchestrator can adapt without hard-coded rules.
Additional Specialized Agents: Introduce new agents for other domains as needed, and integrate them. For instance, a Data Science Analyst agent for data-related queries, a Personal Assistant agent for scheduling or generic tasks, or a Knowledge Graph agent for doing high-precision lookup on certain data. During this phase, ensure the orchestrator’s dynamic selection logic can handle these new agents.
Learning from Interactions: Consider implementing a feedback mechanism where the system learns from user corrections or preferences. For example, if the user always rephrases the Python agent’s answers or prefers shorter explanations, the system could adapt the style over time. This could be as simple as a config or as complex as fine-tuning a model (likely out of scope for a junior dev in early stages, but design for it if possible).
Voice and Multimodal I/O (Optional): To enhance usability, one could add voice input/output or image understanding. For instance, integrate a text-to-speech for responses (so the assistant can talk) or speech-to-text for input. Or allow the Medical Specialist to analyze medical images (if a model like a vision-capable model is available). These are stretch goals that would require additional libraries (for voice) or models (for vision). Gradio can support audio inputs/outputs easily, so it's feasible as an add-on.
Robust Testing & Documentation: Before finalizing, ensure that all new features are thoroughly tested. Update documentation (including this PRD and a user guide) to reflect any new agent or capability. For dynamic selection, document how the orchestrator decides, so developers understand the process.
Performance Re-evaluation: Adding more agents and dynamic logic could affect performance. Re-run the performance benchmarks with the new changes and optimize as needed (perhaps the new agents are smaller or used less frequently, but the orchestrator’s own complexity might grow).
Throughout all phases, maintain structured, clean code with comments, so that a junior developer (or any new contributor) can follow the logic. Use version control to track changes at each phase (e.g., separate branches for each milestone). After Phase 5, the AI Assistant Swarm system should be a feature-complete, locally running multi-agent assistant, suitable for beginner programmers and general users who value privacy and specialized expertise on demand.
Conclusion
This PRD provides a comprehensive plan for developing the AI Assistant Swarm system. By following the phases and meeting the requirements outlined, a developer will create an innovative assistant that is powerful yet private, leveraging local AI models in concert. The document is structured to guide a junior developer through both high-level concepts and low-level technical specifics, ensuring clarity at each step. Upon completion, users (especially those new to Python) will have a reliable AI partner that can help with coding, answer medical questions with authority, and manage knowledge – all on their own machine.
