sABC.roaming>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: state directory tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        roaming=roaming,
        ensure_exists=ensure_exists,
    ).user_state_dir


def user_log_dir(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> str:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: log directory tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).user_log_dir


def user_documents_dir() -> str:
    """:returns: documents directory tied to the user"""
    return PlatformDirs().user_documents_dir


def user_downloads_dir() -> str:
    """:returns: downloads directory tied to the user"""
    return PlatformDirs().user_downloads_dir


def user_pictures_dir() -> str:
    """:returns: pictures directory tied to the user"""
    return PlatformDirs().user_pictures_dir


def user_videos_dir() -> str:
    """:returns: videos directory tied to the user"""
    return PlatformDirs().user_videos_dir


def user_music_dir() -> str:
    """:returns: music directory tied to the user"""
    return PlatformDirs().user_music_dir


def user_desktop_dir() -> str:
    """:returns: desktop directory tied to the user"""
    return PlatformDirs().user_desktop_dir


def user_runtime_dir(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> str:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: runtime directory tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).user_runtime_dir


def site_runtime_dir(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> str:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: runtime directory shared by users
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).site_runtime_dir


def user_data_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    roaming: bool = False,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: data path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        roaming=roaming,
        ensure_exists=ensure_exists,
    ).user_data_path


def site_data_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    multipath: bool = False,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param multipath: See `multipath <platformdirs.api.PlatformDirsABC.multipath>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: data path shared by users
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        multipath=multipath,
        ensure_exists=ensure_exists,
    ).site_data_path


def user_config_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    roaming: bool = False,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: config path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        roaming=roaming,
        ensure_exists=ensure_exists,
    ).user_config_path


def site_config_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    multipath: bool = False,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: config path shared by the users
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        multipath=multipath,
        ensure_exists=ensure_exists,
    ).site_config_path


def site_cache_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: cache directory tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).site_cache_path


def user_cache_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: cache path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).user_cache_path


def user_state_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    roaming: bool = False,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: state path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        roaming=roaming,
        ensure_exists=ensure_exists,
    ).user_state_path


def user_log_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: log path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).user_log_path


def user_documents_path() -> Path:
    """:returns: documents a path tied to the user"""
    return PlatformDirs().user_documents_path


def user_downloads_path() -> Path:
    """:returns: downloads path tied to the user"""
    return PlatformDirs().user_downloads_path


def user_pictures_path() -> Path:
    """:returns: pictures path tied to the user"""
    return PlatformDirs().user_pictures_path


def user_videos_path() -> Path:
    """:returns: videos path tied to the user"""
    return PlatformDirs().user_videos_path


def user_music_path() -> Path:
    """:returns: music path tied to the user"""
    return PlatformDirs().user_music_path


def user_desktop_path() -> Path:
    """:returns: desktop path tied to the user"""
    return PlatformDirs().user_desktop_path


def user_runtime_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: runtime path tied to the user
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).user_runtime_path


def site_runtime_path(
    appname: str | None = None,
    appauthor: str | None | Literal[False] = None,
    version: str | None = None,
    opinion: bool = True,  # noqa: FBT001, FBT002
    ensure_exists: bool = False,  # noqa: FBT001, FBT002
) -> Path:
    """
    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.
    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.
    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.
    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.
    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    :returns: runtime path shared by users
    """
    return PlatformDirs(
        appname=appname,
        appauthor=appauthor,
        version=version,
        opinion=opinion,
        ensure_exists=ensure_exists,
    ).site_runtime_path


__all__ = [
    "AppDirs",
    "PlatformDirs",
    "PlatformDirsABC",
    "__version__",
    "__version_info__",
    "site_cache_dir",
    "site_cache_path",
    "site_config_dir",
    "site_config_path",
    "site_data_dir",
    "site_data_path",
    "site_runtime_dir",
    "site_runtime_path",
    "user_cache_dir",
    "user_cache_path",
    "user_config_dir",
    "user_config_path",
    "user_data_dir",
    "user_data_path",
    "user_desktop_dir",
    "user_desktop_path",
    "user_documents_dir",
    "user_documents_path",
    "user_downloads_dir",
    "user_downloads_path",
    "user_log_dir",
    "user_log_path",
    "user_music_dir",
    "user_music_path",
    "user_pictures_dir",
    "user_pictures_path",
    "user_runtime_dir",
    "user_runtime_path",
    "user_state_dir",
    "user_state_path",
    "user_videos_dir",
    "user_videos_path",
]

"""Base API."""

from __future__ import annotations

import os
from abc import ABC, abstractmethod
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterator, Literal


class PlatformDirsABC(ABC):  # noqa: PLR0904
    """Abstract base class for platform directories."""

    def __init__(  # noqa: PLR0913, PLR0917
        self,
        appname: str | None = None,
        appauthor: str | None | Literal[False] = None,
        version: str | None = None,
        roaming: bool = False,  # noqa: FBT001, FBT002
        multipath: bool = False,  # noqa: FBT001, FBT002
        opinion: bool = True,  # noqa: FBT001, FBT002
        ensure_exists: bool = False,  # noqa: FBT001, FBT002
    ) -> None:
        """
        Create a new platform directory.

        :param appname: See `appname`.
        :param appauthor: See `appauthor`.
        :param version: See `version`.
        :param roaming: See `roaming`.
        :param multipath: See `multipath`.
        :param opinion: See `opinion`.
        :param ensure_exists: See `ensure_exists`.

        """
        self.appname = appname  #: The name of application.
        self.appauthor = appauthor
        """
        The name of the app author or distributing body for this application.

        Typically, it is the owning company name. Defaults to `appname`. You may pass ``False`` to disable it.

        """
        self.version = version
        """
        An optional version path element to append to the path.

        You might want to use this if you want multiple versions of your app to be able to run independently. If used,
        this would typically be ``<major>.<minor>``.

        """
        self.roaming = roaming
        """
        Whether to use the roaming appdata directory on Windows.

        That means that for users on a Windows network setup for roaming profiles, this user data will be synced on
        login (see
        `here <https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>`_).

        """
        self.multipath = multipath
        """
        An optional parameter which indicates that the entire list of data dirs should be returned.

        By default, the first item would only be returned.

        """
        self.opinion = opinion  #: A flag to indicating to use opinionated values.
        self.ensure_exists = ensure_exists
        """
        Optionally create the directory (and any missing parents) upon access if it does not exist.

        By default, no directories are created.

        """

    def _append_app_name_and_version(self, *base: str) -> str:
        params = list(base[1:])
        if self.appname:
            params.append(self.appname)
            if self.version:
                params.append(self.version)
        path = os.path.join(base[0], *params)  # noqa: PTH118
        self._optionally_create_directory(path)
        return path

    def _optionally_create_directory(self, path: str) -> None:
        if self.ensure_exists:
            Path(path).mkdir(parents=True, exist_ok=True)

    def _first_item_as_path_if_multipath(self, directory: str) -> Path:
        if self.multipath:
            # If multipath is True, the first path is returned.
            directory = directory.split(os.pathsep)[0]
        return Path(directory)

    @property
    @abstractmethod
    def user_data_dir(self) -> str:
        """:return: data directory tied to the user"""

    @property
    @abstractmethod
    def site_data_dir(self) -> str:
        """:return: data directory shared by users"""

    @property
    @abstractmethod
    def user_config_dir(self) -> str:
        """:return: config directory tied to the user"""

    @property
    @abstractmethod
    def site_config_dir(self) -> str:
        """:return: config directory shared by the users"""

    @property
    @abstractmethod
    def user_cache_dir(self) -> str:
        """:return: cache directory tied to the user"""

    @property
    @abstractmethod
    def site_cache_dir(self) -> str:
        """:return: cache directory shared by users"""

    @property
    @abstractmethod
    def user_state_dir(self) -> str:
        """:return: state directory tied to the user"""

    @property
    @abstractmethod
    def user_log_dir(self) -> str:
        """:return: log directory tied to the user"""

    @property
    @abstractmethod
    def user_documents_dir(self) -> str:
        """:return: documents directory tied to the user"""

    @property
    @abstractmethod
    def user_downloads_dir(self) -> str:
        """:return: downloads directory tied to the user"""

    @property
    @abstractmethod
    def user_pictures_dir(self) -> str:
        """:return: pictures directory tied to the user"""

    @property
    @abstractmethod
    def user_videos_dir(self) -> str:
        """:return: videos directory tied to the user"""

    @property
    @abstractmethod
    def user_music_dir(self) -> str:
        """:return: music directory tied to the user"""

    @property
    @abstractmethod
    def user_desktop_dir(self) -> str:
        """:return: desktop directory tied to the user"""

    @property
    @abstractmethod
    def user_runtime_dir(self) -> str:
        """:return: runtime directory tied to the user"""

    @property
    @abstractmethod
    def site_runtime_dir(self) -> str:
        """:return: runtime directory shared by users"""

    @property
    def user_data_path(self) -> Path:
        """:return: data path tied to the user"""
        return Path(self.user_data_dir)

    @property
    def site_data_path(self) -> Path:
        """:return: data path shared by users"""
        return Path(self.site_data_dir)

    @property
    def user_config_path(self) -> Path:
        """:return: config path tied to the user"""
        return Path(self.user_config_dir)

    @property
    def site_config_path(self) -> Path:
        """:return: config path shared by the users"""
        return Path(self.site_config_dir)

    @property
    def user_cache_path(self) -> Path:
        """:return: cache path tied to the user"""
        return Path(self.user_cache_dir)

    @property
    def site_cache_path(self) -> Path:
        """:return: cache path shared by users"""
        return Path(self.site_cache_dir)

    @property
    def user_state_path(self) -> Path:
        """:return: state path tied to the user"""
        return Path(self.user_state_dir)

    @property
    def user_log_path(self) -> Path:
        """:return: log path tied to the user"""
        return Path(self.user_log_dir)

    @property
    def user_documents_path(self) -> Path:
        """:return: documents a path tied to the user"""
        return Path(self.user_documents_dir)

    @property
    def user_downloads_path(self) -> Path:
        """:return: downloads path tied to the user"""
        return Path(self.user_downloads_dir)

    @property
    def user_pictures_path(self) -> Path:
        """:return: pictures path tied to the user"""
        return Path(self.user_pictures_dir)

    @property
    def user_videos_path(self) -> Path:
        """:return: videos path tied to the user"""
        return Path(self.user_videos_dir)

    @property
    def user_music_path(self) -> Path:
        """:return: music path tied to the user"""
        return Path(self.user_music_dir)

    @property
    def user_desktop_path(self) -> Path:
        """:return: desktop path tied to the user"""
        return Path(self.user_desktop_dir)

    @property
    def user_runtime_path(self) -> Path:
        """:return: runtime path tied to the user"""
        return Path(self.user_runtime_dir)

    @property
    def site_runtime_path(self) -> Path:
        """:return: runtime path shared by users"""
        return Path(self.site_runtime_dir)

    def iter_config_dirs(self) -> Iterator[str]:
        """:yield: all user and site configuration directories."""
        yield self.user_config_dir
        yield self.site_config_dir

    def iter_data_dirs(self) -> Iterator[str]:
        """:yield: all user and site data directories."""
        yield self.user_data_dir
        yield self.site_data_dir

    def iter_cache_dirs(self) -> Iterator[str]:
        """:yield: all user and site cache directories."""
        yield self.user_cache_dir
        yield self.site_cache_dir

    def iter_runtime_dirs(self) -> Iterator[str]:
        """:yield: all user and site runtime directories."""
        yield self.user_runtime_dir
        yield self.site_runtime_dir

    def iter_config_paths(self) -> Iterator[Path]:
        """:yield: all user and site configuration paths."""
        for path in self.iter_config_dirs():
            yield Path(path)

    def iter_data_paths(self) -> Iterator[Path]:
        """:yield: all user and site data paths."""
        for path in self.iter_data_dirs():
            yield Path(path)

    def iter_cache_paths(self) -> Iterator[Path]:
        """:yield: all user and site cache paths."""
        for path in self.iter_cache_dirs():
            yield Path(path)

    def iter_runtime_paths(self) -> Iterator[Path]:
        """:yield: all user and site runtime paths."""
        for path in self.iter_runtime_dirs():
            yield Path(path)

"""Android."""

from __future__ import annotations

import os
import re
import sys
from functools import lru_cache
from typing import TYPE_CHECKING, cast

from .api import PlatformDirsABC


class Android(PlatformDirsABC):
    """
    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_.

    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `version
    <platformdirs.api.PlatformDirsABC.version>`, `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.

    """

    @property
    def user_data_dir(self) -> str:
        """:return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``"""
        return self._append_app_name_and_version(cast(str, _android_folder()), "files")

    @property
    def site_data_dir(self) -> str:
        """:return: data directory shared by users, same as `user_data_dir`"""
        return self.user_data_dir

    @property
    def user_config_dir(self) -> str:
        """
        :return: config directory tied to the user, e.g. \
        ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``
        """
        return self._append_app_name_and_version(cast(str, _android_folder()), "shared_prefs")

    @property
    def site_config_dir(self) -> str:
        """:return: config directory shared by the users, same as `user_config_dir`"""
        return self.user_config_dir

    @property
    def user_cache_dir(self) -> str:
        """:return: cache directory tied to the user, e.g.,``/data/user/<userid>/<packagename>/cache/<AppName>``"""
        return self._append_app_name_and_version(cast(str, _android_folder()), "cache")

    @property
    def site_cache_dir(self) -> str:
        """:return: cache directory shared by users, same as `user_cache_dir`"""
        return self.user_cache_dir

    @property
    def user_state_dir(self) -> str:
        """:return: state directory tied to the user, same as `user_data_dir`"""
        return self.user_data_dir

    @property
    def user_log_dir(self) -> str:
        """
        :return: log directory tied to the user, same as `user_cache_dir` if not opinionated else ``log`` in it,
          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/log``
        """
        path = self.user_cache_dir
        if self.opinion:
            path = os.path.join(path, "log")  # noqa: PTH118
        return path

    @property
    def user_documents_dir(self) -> str:
        """:return: documents directory tied to the user e.g. ``/storage/emulated/0/Documents``"""
        return _android_documents_folder()

    @property
    def user_downloads_dir(self) -> str:
        """:return: downloads directory tied to the user e.g. ``/storage/emulated/0/Downloads``"""
        return _android_downloads_folder()

    @property
    def user_pictures_dir(self) -> str:
        """:return: pictures directory tied to the user e.g. ``/storage/emulated/0/Pictures``"""
        return _android_pictures_folder()

    @property
    def user_videos_dir(self) -> str:
        """:return: videos directory tied to the user e.g. ``/storage/emulated/0/DCIM/Camera``"""
        return _android_videos_folder()

    @property
    def user_music_dir(self) -> str:
        """:return: music directory tied to the user e.g. ``/storage/emulated/0/Music``"""
        return _android_music_folder()

    @property
    def user_desktop_dir(self) -> str:
        """:return: desktop directory tied to the user e.g. ``/storage/emulated/0/Desktop``"""
        return "/storage/emulated/0/Desktop"

    @property
    def user_runtime_dir(self) -> str:
        """
        :return: runtime directory tied to the user, same as `user_cache_dir` if not opinionated else ``tmp`` in it,
          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/tmp``
        """
        path = self.user_cache_dir
        if self.opinion:
            path = os.path.join(path, "tmp")  # noqa: PTH118
        return path

    @property
    def site_runtime_dir(self) -> str:
        """:return: runtime directory shared by users, same as `user_runtime_dir`"""
        return self.user_runtime_dir


@lru_cache(maxsize=1)
def _android_folder() -> str | None:  # noqa: C901
    """:return: base folder for the Android OS or None if it cannot be found"""
    result: str | None = None
    # type checker isn't happy with our "import android", just don't do this when type checking see
    # https://stackoverflow.com/a/61394121
    if not TYPE_CHECKING:
        try:
            # First try to get a path to android app using python4android (if available)...
            from android import mActivity  # noqa: PLC0415

            context = cast("android.content.Context", mActivity.getApplicationContext())  # noqa: F821
            result = context.getFilesDir().getParentFile().getAbsolutePath()
        except Exception:  # noqa: BLE001
            result = None
    if result is None:
        try:
            # ...and fall back to using plain pyjnius, if python4android isn't available or doesn't deliver any useful
            # result...
            from jnius import autoclass  # noqa: PLC0415

            context = autoclass("android.content.Context")
            result = context.getFilesDir().getParentFile().getAbsolutePath()
        except Exception:  # noqa: BLE001
            result = None
    if result is None:
        # and if that fails, too, find an android folder looking at path on the sys.path
        # warning: only works for apps installed under /data, not adopted storage etc.
        pattern = re.compile(r"/data/(data|user/\d+)/(.+)/files")
        for path in sys.path:
            if pattern.match(path):
                result = path.split("/files")[0]
                break
        else:
            result = None
    if result is None:
        # one last try: find an android folder looking at path on the sys.path taking adopted storage paths into
        # account
        pattern = re.compile(r"/mnt/expand/[a-fA-F0-9-]{36}/(data|user/\d+)/(.+)/files")
        for path in sys.path:
            if pattern.match(path):
                result = path.split("/files")[0]
                break
        else:
            result = None
    return result


@lru_cache(maxsize=1)
def _android_documents_folder() -> str:
    """:return: documents folder for the Android OS"""
    # Get directories with pyjnius
    try:
        from jnius import autoclass  # noqa: PLC0415

        context = autoclass("android.content.Context")
        environment = autoclass("android.os.Environment")
        documents_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOCUMENTS).getAbsolutePath()
    except Exception:  # noqa: BLE001
        documents_dir = "/storage/emulated/0/Documents"

    return documents_dir


@lru_cache(maxsize=1)
def _android_downloads_folder() -> str:
    """:return: downloads folder for the Android OS"""
    # Get directories with pyjnius
    try:
        from jnius import autoclass  # noqa: PLC0415

        context = autoclass("android.content.Context")
        environment = autoclass("android.os.Environment")
        downloads_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOWNLOADS).getAbsolutePath()
    except Exception:  # noqa: BLE001
        downloads_dir = "/storage/emulated/0/Downloads"

    return downloads_dir


@lru_cache(maxsize=1)
def _android_pictures_folder() -> str:
    """:return: pictures folder for the Android OS"""
    # Get directories with pyjnius
    try:
        from jnius import autoclass  # noqa: PLC0415

        context = autoclass("android.content.Context")
        environment = autoclass("android.os.Environment")
        pictures_dir: str = context.getExternalFilesDir(environment.DIRECTORY_PICTURES).getAbsolutePath()
    except Exception:  # noqa: BLE001
        pictures_dir = "/storage/emulated/0/Pictures"

    return pictures_dir


@lru_cache(maxsize=1)
def _android_videos_folder() -> str:
    """:return: videos folder for the Android OS"""
    # Get directories with pyjnius
    try:
        from jnius import autoclass  # noqa: PLC0415

        context = autoclass("android.content.Context")
        environment = autoclass("android.os.Environment")
        videos_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DCIM).getAbsolutePath()
    except Exception:  # noqa: BLE001
        videos_dir = "/storage/emulated/0/DCIM/Camera"

    return videos_dir


@lru_cache(maxsize=1)
def _android_music_folder() -> str:
    """:return: music folder for the Android OS"""
    # Get directories with pyjnius
    try:
        from jnius import autoclass  # noqa: PLC0415

        context = autoclass("android.content.Context")
        environment = autoclass("android.os.Environment")
        music_dir: str = context.getExternalFilesDir(environment.DIRECTORY_MUSIC).getAbsolutePath()
    except Exception:  # noqa: BLE001
        music_dir = "/storage/emulated/0/Music"

    return music_dir


__all__ = [
    "Android",
]


"""Windows."""

from __future__ import annotations

import os
import sys
from functools import lru_cache
from typing import TYPE_CHECKING

from .api import PlatformDirsABC

if TYPE_CHECKING:
    from collections.abc import Callable


class Windows(PlatformDirsABC):
    """
    `MSDN on where to store app data files <https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid>`_.

    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `appauthor
    <platformdirs.api.PlatformDirsABC.appauthor>`, `version <platformdirs.api.PlatformDirsABC.version>`, `roaming
    <platformdirs.api.PlatformDirsABC.roaming>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists
    <platformdirs.api.PlatformDirsABC.ensure_exists>`.

    """

    @property
    def user_data_dir(self) -> str:
        """
        :return: data directory tied to the user, e.g.
         ``%USERPROFILE%\\AppData\\Local\\$appauthor\\$appname`` (not roaming) or
         ``%USERPROFILE%\\AppData\\Roaming\\$appauthor\\$appname`` (roaming)
        """
        const = "CSIDL_APPDATA" if self.roaming else "CSIDL_LOCAL_APPDATA"
        path = os.path.normpath(get_win_folder(const))
        return self._append_parts(path)

    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:
        params = []
        if self.appname:
            if self.appauthor is not False:
                author = self.appauthor or self.appname
                params.append(author)
            params.append(self.appname)
            if opinion_value is not None and self.opinion:
                params.append(opinion_value)
            if self.version:
                params.append(self.version)
        path = os.path.join(path, *params)  # noqa: PTH118
        self._optionally_create_directory(path)
        return path

    @property
    def site_data_dir(self) -> str:
        """:return: data directory shared by users, e.g. ``C:\\ProgramData\\$appauthor\\$appname``"""
        path = os.path.normpath(get_win_folder("CSIDL_COMMON_APPDATA"))
        return self._append_parts(path)

    @property
    def user_config_dir(self) -> str:
        """:return: config directory tied to the user, same as `user_data_dir`"""
        return self.user_data_dir

    @property
    def site_config_dir(self) -> str:
        """:return: config directory shared by the users, same as `site_data_dir`"""
        return self.site_data_dir

    @property
    def user_cache_dir(self) -> str:
        """
        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.
         ``%USERPROFILE%\\AppData\\Local\\$appauthor\\$appname\\Cache\\$version``
        """
        path = os.path.normpath(get_win_folder("CSIDL_LOCAL_APPDATA"))
        return self._append_parts(path, opinion_value="Cache")

    @property
    def site_cache_dir(self) -> str:
        """:return: cache directory shared by users, e.g. ``C:\\ProgramData\\$appauthor\\$appname\\Cache\\$version``"""
        path = os.path.normpath(get_win_folder("CSIDL_COMMON_APPDATA"))
        return self._append_parts(path, opinion_value="Cache")

    @property
    def user_state_dir(self) -> str:
        """:return: state directory tied to the user, same as `user_data_dir`"""
        return self.user_data_dir

    @property
    def user_log_dir(self) -> str:
        """:return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it"""
        path = self.user_data_dir
        if self.opinion:
            path = os.path.join(path, "Logs")  # noqa: PTH118
            self._optionally_create_directory(path)
        return path

    @property
    def user_documents_dir(self) -> str:
        """:return: documents directory tied to the user e.g. ``%USERPROFILE%\\Documents``"""
        return os.path.normpath(get_win_folder("CSIDL_PERSONAL"))

    @property
    def user_downloads_dir(self) -> str:
        """:return: downloads directory tied to the user e.g. ``%USERPROFILE%\\Downloads``"""
        return os.path.normpath(get_win_folder("CSIDL_DOWNLOADS"))

    @property
    def user_pictures_dir(self) -> str:
        """:return: pictures directory tied to the user e.g. ``%USERPROFILE%\\Pictures``"""
        return os.path.normpath(get_win_folder("CSIDL_MYPICTURES"))

    @property
    def user_videos_dir(self) -> str:
        """:return: videos directory tied to the user e.g. ``%USERPROFILE%\\Videos``"""
        return os.path.normpath(get_win_folder("CSIDL_MYVIDEO"))

    @property
    def user_music_dir(self) -> str:
        """:return: music directory tied to the user e.g. ``%USERPROFILE%\\Music``"""
        return os.path.normpath(get_win_folder("CSIDL_MYMUSIC"))

    @property
    def user_desktop_dir(self) -> str:
        """:return: desktop directory tied to the user, e.g. ``%USERPROFILE%\\Desktop``"""
        return os.path.normpath(get_win_folder("CSIDL_DESKTOPDIRECTORY"))

    @property
    def user_runtime_dir(self) -> str:
        """
        :return: runtime directory tied to the user, e.g.
         ``%USERPROFILE%\\AppData\\Local\\Temp\\$appauthor\\$appname``
        """
        path = os.path.normpath(os.path.join(get_win_folder("CSIDL_LOCAL_APPDATA"), "Temp"))  # noqa: PTH118
        return self._append_parts(path)

    @property
    def site_runtime_dir(self) -> str:
        """:return: runtime directory shared by users, same as `user_runtime_dir`"""
        return self.user_runtime_dir


def get_win_folder_from_env_vars(csidl_name: str) -> str:
    """Get folder from environment variables."""
    result = get_win_folder_if_csidl_name_not_env_var(csidl_name)
    if result is not None:
        return result

    env_var_name = {
        "CSIDL_APPDATA": "APPDATA",
        "CSIDL_COMMON_APPDATA": "ALLUSERSPROFILE",
        "CSIDL_LOCAL_APPDATA": "LOCALAPPDATA",
    }.get(csidl_name)
    if env_var_name is None:
        msg = f"Unknown CSIDL name: {csidl_name}"
        raise ValueError(msg)
    result = os.environ.get(env_var_name)
    if result is None:
        msg = f"Unset environment variable: {env_var_name}"
        raise ValueError(msg)
    return result


def get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:
    """Get a folder for a CSIDL name that does not exist as an environment variable."""
    if csidl_name == "CSIDL_PERSONAL":
        return os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Documents")  # noqa: PTH118

    if csidl_name == "CSIDL_DOWNLOADS":
        return os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Downloads")  # noqa: PTH118

    if csidl_name == "CSIDL_MYPICTURES":
        return os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Pictures")  # noqa: PTH118

    if csidl_name == "CSIDL_MYVIDEO":
        return os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Videos")  # noqa: PTH118

    if csidl_name == "CSIDL_MYMUSIC":
        return os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Music")  # noqa: PTH118
    return None


def get_win_folder_from_registry(csidl_name: str) -> str:
    """
    Get folder from the registry.

    This is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer
    for all CSIDL_* names.

    """
    shell_folder_name = {
        "CSIDL_APPDATA": "AppData",
        "CSIDL_COMMON_APPDATA": "Common AppData",
        "CSIDL_LOCAL_APPDATA": "Local AppData",
        "CSIDL_PERSONAL": "Personal",
        "CSIDL_DOWNLOADS": "{374DE290-123F-4565-9164-39C4925E467B}",
        "CSIDL_MYPICTURES": "My Pictures",
        "CSIDL_MYVIDEO": "My Video",
        "CSIDL_MYMUSIC": "My Music",
    }.get(csidl_name)
    if shell_folder_name is None:
        msg = f"Unknown CSIDL name: {csidl_name}"
        raise ValueError(msg)
    if sys.platform != "win32":  # only needed for mypy type checker to know that this code runs only on Windows
        raise NotImplementedError
    import winreg  # noqa: PLC0415

    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
    directory, _ = winreg.QueryValueEx(key, shell_folder_name)
    return str(directory)


def get_win_folder_via_ctypes(csidl_name: str) -> str:
    """Get folder with ctypes."""
    # There is no 'CSIDL_DOWNLOADS'.
    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.
    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid

    import ctypes  # noqa: PLC0415

    csidl_const = {
        "CSIDL_APPDATA": 26,
        "CSIDL_COMMON_APPDATA": 35,
        "CSIDL_LOCAL_APPDATA": 28,
        "CSIDL_PERSONAL": 5,
        "CSIDL_MYPICTURES": 39,
        "CSIDL_MYVIDEO": 14,
        "CSIDL_MYMUSIC": 13,
        "CSIDL_DOWNLOADS": 40,
        "CSIDL_DESKTOPDIRECTORY": 16,
    }.get(csidl_name)
    if csidl_const is None:
        msg = f"Unknown CSIDL name: {csidl_name}"
        raise ValueError(msg)

    buf = ctypes.create_unicode_buffer(1024)
    windll = getattr(ctypes, "windll")  # noqa: B009 # using getattr to avoid false positive with mypy type checker
    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)

    # Downgrade to short path name if it has high-bit chars.
    if any(ord(c) > 255 for c in buf):  # noqa: PLR2004
        buf2 = ctypes.create_unicode_buffer(1024)
        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):
            buf = buf2

    if csidl_name == "CSIDL_DOWNLOADS":
        return os.path.join(buf.value, "Downloads")  # noqa: PTH118

    return buf.value


def _pick_get_win_folder() -> Callable[[str], str]:
    try:
        import ctypes  # noqa: PLC0415
    except ImportError:
        pass
    else:
        if hasattr(ctypes, "windll"):
            return get_win_folder_via_ctypes
    try:
        import winreg  # noqa: PLC0415, F401
    except ImportError:
        return get_win_folder_from_env_vars
    else:
        return get_win_folder_from_registry


get_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())

__all__ = [
    "Windows",
]

"""Main entry point."""

from __future__ import annotations

from pip._vendor.platformdirs import PlatformDirs, __version__

PROPS = (
    "user_data_dir",
    "user_config_dir",
    "user_cache_dir",
    "user_state_dir",
    "user_log_dir",
    "user_documents_dir",
    "user_downloads_dir",
    "user_pictures_dir",
    "user_videos_dir",
    "user_music_dir",
    "user_runtime_dir",
    "site_data_dir",
    "site_config_dir",
    "site_cache_dir",
    "site_runtime_dir",
)


def main() -> None:
    """Run the main entry point."""
    app_name = "MyApp"
    app_author = "MyCompany"

    print(f"-- platformdirs {__version__} --")  # noqa: T201

    print("-- app dirs (with optional 'version')")  # noqa: T201
    dirs = PlatformDirs(app_name, app_author, version="1.0")
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201

    print("\n-- app dirs (without optional 'version')")  # noqa: T201
    dirs = PlatformDirs(app_name, app_author)
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201

    print("\n-- app dirs (without optional 'appauthor')")  # noqa: T201
    dirs = PlatformDirs(app_name)
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201

    print("\n-- app dirs (with disabled 'appauthor')")  # noqa: T201
    dirs = PlatformDirs(app_name, appauthor=False)
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201


if __name__ == "__main__":
    main()

import platform
import ctypes


def windows_only(func):
    if platform.system() != 'Windows':
        return lambda *args, **kwargs: None
    return func


@windows_only
def hide_file(path):
    """
    Set the hidden attribute on a file or directory.

    From http://stackoverflow.com/questions/19622133/

    `path` must be text.
    """
    __import__('ctypes.wintypes')
    SetFileAttributes = ctypes.windll.kernel32.SetFileAttributesW
    SetFileAttributes.argtypes = ctypes.wintypes.LPWSTR, ctypes.wintypes.DWORD
    SetFileAttributes.restype = ctypes.wintypes.BOOL

    FILE_ATTRIBUTE_HIDDEN = 0x02

    ret = SetFileAttributes(path, FILE_ATTRIBUTE_HIDDEN)
    if not ret:
        raise ctypes.WinError()

class SetuptoolsDeprecationWarning(Warning):
    """
    Base class for warning deprecations in ``setuptools``

    This class is not derived from ``DeprecationWarning``, and as such is
    visible by default.
    """

"""PyPI and direct package downloading"""
import sys
import os
import re
import io
import shutil
import socket
import base64
import hashlib
import itertools
import warnings
import configparser
import html
import http.client
import urllib.parse
import urllib.request
import urllib.error
from functools import wraps

import setuptools
from pkg_resources import (
    CHECKOUT_DIST, Distribution, BINARY_DIST, normalize_path, SOURCE_DIST,
    Environment, find_distributions, safe_name, safe_version,
    to_filename, Requirement, DEVELOP_DIST, EGG_DIST,
)
from distutils import log
from distutils.errors import DistutilsError
from fnmatch import translate
from setuptools.wheel import Wheel
from setuptools.extern.more_itertools import unique_everseen


EGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.+!]+)$')
HREF = re.compile(r"""href\s*=\s*['"]?([^'"> ]+)""", re.I)
PYPI_MD5 = re.compile(
    r'<a href="([^"#]+)">([^<]+)</a>\n\s+\(<a (?:title="MD5 hash"\n\s+)'
    r'href="[^?]+\?:action=show_md5&amp;digest=([0-9a-f]{32})">md5</a>\)'
)
URL_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).match
EXTENSIONS = ".tar.gz .tar.bz2 .tar .zip .tgz".split()

__all__ = [
    'PackageIndex', 'distros_for_url', 'parse_bdist_wininst',
    'interpret_distro_name',
]

_SOCKET_TIMEOUT = 15

_tmpl = "setuptools/{setuptools.__version__} Python-urllib/{py_major}"
user_agent = _tmpl.format(
    py_major='{}.{}'.format(*sys.version_info), setuptools=setuptools)


def parse_requirement_arg(spec):
    try:
        return Requirement.parse(spec)
    except ValueError as e:
        raise DistutilsError(
            "Not a URL, existing file, or requirement spec: %r" % (spec,)
        ) from e


def parse_bdist_wininst(name):
    """Return (base,pyversion) or (None,None) for possible .exe name"""

    lower = name.lower()
    base, py_ver, plat = None, None, None

    if lower.endswith('.exe'):
        if lower.endswith('.win32.exe'):
            base = name[:-10]
            plat = 'win32'
        elif lower.startswith('.win32-py', -16):
            py_ver = name[-7:-4]
            base = name[:-16]
            plat = 'win32'
        elif lower.endswith('.win-amd64.exe'):
            base = name[:-14]
            plat = 'win-amd64'
        elif lower.startswith('.win-amd64-py', -20):
            py_ver = name[-7:-4]
            base = name[:-20]
            plat = 'win-amd64'
    return base, py_ver, plat


def egg_info_for_url(url):
    parts = urllib.parse.urlparse(url)
    scheme, server, path, parameters, query, fragment = parts
    base = urllib.parse.unquote(path.split('/')[-1])
    if server == 'sourceforge.net' and base == 'download':  # XXX Yuck
        base = urllib.parse.unquote(path.split('/')[-2])
    if '#' in base:
        base, fragment = base.split('#', 1)
    return base, fragment


def distros_for_url(url, metadata=None):
    """Yield egg or source distribution objects that might be found at a URL"""
    base, fragment = egg_info_for_url(url)
    for dist in distros_for_location(url, base, metadata):
        yield dist
    if fragment:
        match = EGG_FRAGMENT.match(fragment)
        if match:
            for dist in interpret_distro_name(
                url, match.group(1), metadata, precedence=CHECKOUT_DIST
            ):
                yield dist


def distros_for_location(location, basename, metadata=None):
    """Yield egg or source distribution objects based on basename"""
    if basename.endswith('.egg.zip'):
        basename = basename[:-4]  # strip the .zip
    if basename.endswith('.egg') and '-' in basename:
        # only one, unambiguous interpretation
        return [Distribution.from_location(location, basename, metadata)]
    if basename.endswith('.whl') and '-' in basename:
        wheel = Wheel(basename)
        if not wheel.is_compatible():
            return []
        return [Distribution(
            location=location,
            project_name=wheel.project_name,
            version=wheel.version,
            # Increase priority over eggs.
            precedence=EGG_DIST + 1,
        )]
    if basename.endswith('.exe'):
        win_base, py_ver, platform = parse_bdist_wininst(basename)
        if win_base is not None:
            return interpret_distro_name(
                location, win_base, metadata, py_ver, BINARY_DIST, platform
            )
    # Try source distro extensions (.zip, .tgz, etc.)
    #
    for ext in EXTENSIONS:
        if basename.endswith(ext):
            basename = basename[:-len(ext)]
            return interpret_distro_name(location, basename, metadata)
    return []  # no extension matched


def distros_for_filename(filename, metadata=None):
    """Yield possible egg or source distribution objects based on a filename"""
    return distros_for_location(
        normalize_path(filename), os.path.basename(filename), metadata
    )


def interpret_distro_name(
        location, basename, metadata, py_version=None, precedence=SOURCE_DIST,
        platform=None
):
    """Generate alternative interpretations of a source distro name

    Note: if `location` is a filesystem filename, you should call
    ``pkg_resources.normalize_path()`` on it before passing it to this
    routine!
    """
    # Generate alternative interpretations of a source distro name
    # Because some packages are ambiguous as to name/versions split
    # e.g. "adns-python-1.1.0", "egenix-mx-commercial", etc.
    # So, we generate each possible interpretation (e.g. "adns, python-1.1.0"
    # "adns-python, 1.1.0", and "adns-python-1.1.0, no version").  In practice,
    # the spurious interpretations should be ignored, because in the event
    # there's also an "adns" package, the spurious "python-1.1.0" version will
    # compare lower than any numeric version number, and is therefore unlikely
    # to match a request for it.  It's still a potential problem, though, and
    # in the long run PyPI and the distutils should go for "safe" names and
    # versions in distribution archive names (sdist and bdist).

    parts = basename.split('-')
    if not py_version and any(re.match(r'py\d\.\d$', p) for p in parts[2:]):
        # it is a bdist_dumb, not an sdist -- bail out
        return

    for p in range(1, len(parts) + 1):
        yield Distribution(
            location, metadata, '-'.join(parts[:p]), '-'.join(parts[p:]),
            py_version=py_version, precedence=precedence,
            platform=platform
        )


def unique_values(func):
    """
    Wrap a function returning an iterable such that the resulting iterable
    only ever yields unique items.
    """

    @wraps(func)
    def wrapper(*args, **kwargs):
        return unique_everseen(func(*args, **kwargs))

    return wrapper


REL = re.compile(r"""<([^>]*\srel\s{0,10}=\s{0,10}['"]?([^'" >]+)[^>]*)>""", re.I)
# this line is here to fix emacs' cruddy broken syntax highlighting


@unique_values
def find_external_links(url, page):
    """Find rel="homepage" and rel="download" links in `page`, yielding URLs"""

    for match in REL.finditer(page):
        tag, rel = match.groups()
        rels = set(map(str.strip, rel.lower().split(',')))
        if 'homepage' in rels or 'download' in rels:
            for match in HREF.finditer(tag):
                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))

    for tag in ("<th>Home Page", "<th>Download URL"):
        pos = page.find(tag)
        if pos != -1:
            match = HREF.search(page, pos)
            if match:
                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))


class ContentChecker:
    """
    A null content checker that defines the interface for checking content
    """

    def feed(self, block):
        """
        Feed a block of data to the hash.
        """
        return

    def is_valid(self):
        """
        Check the hash. Return False if validation fails.
        """
        return True

    def report(self, reporter, template):
        """
        Call reporter with information about the checker (hash name)
        substituted into the template.
        """
        return


class HashChecker(ContentChecker):
    pattern = re.compile(
        r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5)='
        r'(?P<expected>[a-f0-9]+)'
    )

    def __init__(self, hash_name, expected):
        self.hash_name = hash_name
        self.hash = hashlib.new(hash_name)
        self.expected = expected

    @classmethod
    def from_url(cls, url):
        "Construct a (possibly null) ContentChecker from a URL"
        fragment = urllib.parse.urlparse(url)[-1]
        if not fragment:
            return ContentChecker()
        match = cls.pattern.search(fragment)
        if not match:
            return ContentChecker()
        return cls(**match.groupdict())

    def feed(self, block):
        self.hash.update(block)

    def is_valid(self):
        return self.hash.hexdigest() == self.expected

    def report(self, reporter, template):
        msg = template % self.hash_name
        return reporter(msg)


class PackageIndex(Environment):
    """A distribution index that scans web pages for download URLs"""

    def __init__(
            self, index_url="https://pypi.org/simple/", hosts=('*',),
            ca_bundle=None, verify_ssl=True, *args, **kw
    ):
        Environment.__init__(self, *args, **kw)
        self.index_url = index_url + "/" [:not index_url.endswith('/')]
        self.scanned_urls = {}
        self.fetched_urls = {}
        self.package_pages = {}
        self.allows = re.compile('|'.join(map(translate, hosts))).match
        self.to_scan = []
        self.opener = urllib.request.urlopen

    # FIXME: 'PackageIndex.process_url' is too complex (14)
    def process_url(self, url, retrieve=False):  # noqa: C901
        """Evaluate a URL as a possible download, and maybe retrieve it"""
        if url in self.scanned_urls and not retrieve:
            return
        self.scanned_urls[url] = True
        if not URL_SCHEME(url):
            self.process_filename(url)
            return
        else:
            dists = list(distros_for_url(url))
            if dists:
                if not self.url_ok(url):
                    return
                self.debug("Found link: %s", url)

        if dists or not retrieve or url in self.fetched_urls:
            list(map(self.add, dists))
            return  # don't need the actual page

        if not self.url_ok(url):
            self.fetched_urls[url] = True
            return

        self.info("Reading %s", url)
        self.fetched_urls[url] = True  # prevent multiple fetch attempts
        tmpl = "Download error on %s: %%s -- Some packages may not be found!"
        f = self.open_url(url, tmpl % url)
        if f is None:
            return
        if isinstance(f, urllib.error.HTTPError) and f.code == 401:
            self.info("Authentication error: %s" % f.msg)
        self.fetched_urls[f.url] = True
        if 'html' not in f.headers.get('content-type', '').lower():
            f.close()  # not html, we can't process it
            return

        base = f.url  # handle redirects
        page = f.read()
        if not isinstance(page, str):
            # In Python 3 and got bytes but want str.
            if isinstance(f, urllib.error.HTTPError):
                # Errors have no charset, assume latin1:
                charset = 'latin-1'
            else:
                charset = f.headers.get_param('charset') or 'latin-1'
            page = page.decode(charset, "ignore")
        f.close()
        for match in HREF.finditer(page):
            link = urllib.parse.urljoin(base, htmldecode(match.group(1)))
            self.process_url(link)
        if url.startswith(self.index_url) and getattr(f, 'code', None) != 404:
            page = self.process_index(url, page)

    def process_filename(self, fn, nested=False):
        # process filenames or directories
        if not os.path.exists(fn):
            self.warn("Not found: %s", fn)
            return

        if os.path.isdir(fn) and not nested:
            path = os.path.realpath(fn)
            for item in os.listdir(path):
                self.process_filename(os.path.join(path, item), True)

        dists = distros_for_filename(fn)
        if dists:
            self.debug("Found: %s", fn)
            list(map(self.add, dists))

    def url_ok(self, url, fatal=False):
        s = URL_SCHEME(url)
        is_file = s and s.group(1).lower() == 'file'
        if is_file or self.allows(urllib.parse.urlparse(url)[1]):
            return True
        msg = (
            "\nNote: Bypassing %s (disallowed host; see "
            "http://bit.ly/2hrImnY for details).\n")
        if fatal:
            raise DistutilsError(msg % url)
        else:
            self.warn(msg, url)

    def scan_egg_links(self, search_path):
        dirs = filter(os.path.isdir, search_path)
        egg_links = (
            (path, entry)
            for path in dirs
            for entry in os.listdir(path)
            if entry.endswith('.egg-link')
        )
        list(itertools.starmap(self.scan_egg_link, egg_links))

    def scan_egg_link(self, path, entry):
        with open(os.path.join(path, entry)) as raw_lines:
            # filter non-empty lines
            lines = list(filter(None, map(str.strip, raw_lines)))

        if len(lines) != 2:
            # format is not recognized; punt
            return

        egg_path, setup_path = lines

        for dist in find_distributions(os.path.join(path, egg_path)):
            dist.location = os.path.join(path, *lines)
            dist.precedence = SOURCE_DIST
            self.add(dist)

    def _scan(self, link):
        # Process a URL to see if it's for a package page
        NO_MATCH_SENTINEL = None, None
        if not link.startswith(self.index_url):
            return NO_MATCH_SENTINEL

        parts = list(map(
            urllib.parse.unquote, link[len(self.index_url):].split('/')
        ))
        if len(parts) != 2 or '#' in parts[1]:
            return NO_MATCH_SENTINEL

        # it's a package page, sanitize and index it
        pkg = safe_name(parts[0])
        ver = safe_version(parts[1])
        self.package_pages.setdefault(pkg.lower(), {})[link] = True
        return to_filename(pkg), to_filename(ver)

    def process_index(self, url, page):
        """Process the contents of a PyPI page"""

        # process an index page into the package-page index
        for match in HREF.finditer(page):
            try:
                self._scan(urllib.parse.urljoin(url, htmldecode(match.group(1))))
            except ValueError:
                pass

        pkg, ver = self._scan(url)  # ensure this page is in the page index
        if not pkg:
            return ""  # no sense double-scanning non-package pages

        # process individual package page
        for new_url in find_external_links(url, page):
            # Process the found URL
            base, frag = egg_info_for_url(new_url)
            if base.endswith('.py') and not frag:
                if ver:
                    new_url += '#egg=%s-%s' % (pkg, ver)
                else:
                    self.need_version_info(url)
            self.scan_url(new_url)

        return PYPI_MD5.sub(
            lambda m: '<a href="%s#md5=%s">%s</a>' % m.group(1, 3, 2), page
        )

    def need_version_info(self, url):
        self.scan_all(
            "Page at %s links to .py file(s) without version info; an index "
            "scan is required.", url
        )

    def scan_all(self, msg=None, *args):
        if self.index_url not in self.fetched_urls:
            if msg:
                self.warn(msg, *args)
            self.info(
                "Scanning index of all packages (this may take a while)"
            )
        self.scan_url(self.index_url)

    def find_packages(self, requirement):
        self.scan_url(self.index_url + requirement.unsafe_name + '/')

        if not self.package_pages.get(requirement.key):
            # Fall back to safe version of the name
            self.scan_url(self.index_url + requirement.project_name + '/')

        if not self.package_pages.get(requirement.key):
            # We couldn't find the target package, so search the index page too
            self.not_found_in_index(requirement)

        for url in list(self.package_pages.get(requirement.key, ())):
            # scan each page that might be related to the desired package
            self.scan_url(url)

    def obtain(self, requirement, installer=None):
        self.prescan()
        self.find_packages(requirement)
        for dist in self[requirement.key]:
            if dist in requirement:
                return dist
            self.debug("%s does not match %s", requirement, dist)
        return super(PackageIndex, self).obtain(requirement, installer)

    def check_hash(self, checker, filename, tfp):
        """
        checker is a ContentChecker
        """
        checker.report(
            self.debug,
            "Validating %%s checksum for %s" % filename)
        if not checker.is_valid():
            tfp.close()
            os.unlink(filename)
            raise DistutilsError(
                "%s validation failed for %s; "
                "possible download problem?"
                % (checker.hash.name, os.path.basename(filename))
            )

    def add_find_links(self, urls):
        """Add `urls` to the list that will be prescanned for searches"""
        for url in urls:
            if (
                self.to_scan is None  # if we have already "gone online"
                or not URL_SCHEME(url)  # or it's a local file/directory
                or url.startswith('file:')
                or list(distros_for_url(url))  # or a direct package link
            ):
                # then go ahead and process it now
                self.scan_url(url)
            else:
                # otherwise, defer retrieval till later
                self.to_scan.append(url)

    def prescan(self):
        """Scan urls scheduled for prescanning (e.g. --find-links)"""
        if self.to_scan:
            list(map(self.scan_url, self.to_scan))
        self.to_scan = None  # from now on, go ahead and process immediately

    def not_found_in_index(self, requirement):
        if self[requirement.key]:  # we've seen at least one distro
            meth, msg = self.info, "Couldn't retrieve index page for %r"
        else:  # no distros seen for this name, might be misspelled
            meth, msg = (
                self.warn,
                "Couldn't find index page for %r (maybe misspelled?)")
        meth(msg, requirement.unsafe_name)
        self.scan_all()

    def download(self, spec, tmpdir):
        """Locate and/or download `spec` to `tmpdir`, returning a local path

        `spec` may be a ``Requirement`` object, or a string containing a URL,
        an existing local filename, or a project/version requirement spec
        (i.e. the string form of a ``Requirement`` object).  If it is the URL
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one
        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is
        automatically created alongside the downloaded file.

        If `spec` is a ``Requirement`` object or a string containing a
        project/version requirement spec, this method returns the location of
        a matching distribution (possibly after downloading it to `tmpdir`).
        If `spec` is a locally existing file or directory name, it is simply
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath
        of `tmpdir`, and the local filename is returned.  Various errors may be
        raised if a problem occurs during downloading.
        """
        if not isinstance(spec, Requirement):
            scheme = URL_SCHEME(spec)
            if scheme:
                # It's a url, download it to tmpdir
                found = self._download_url(scheme.group(1), spec, tmpdir)
                base, fragment = egg_info_for_url(spec)
                if base.endswith('.py'):
                    found = self.gen_setup(found, fragment, tmpdir)
                return found
            elif os.path.exists(spec):
                # Existing file or directory, just return it
                return spec
            else:
                spec = parse_requirement_arg(spec)
        return getattr(self.fetch_distribution(spec, tmpdir), 'location', None)

    def fetch_distribution(  # noqa: C901  # is too complex (14)  # FIXME
            self, requirement, tmpdir, force_scan=False, source=False,
            develop_ok=False, local_index=None):
        """Obtain a distribution suitable for fulfilling `requirement`

        `requirement` must be a ``pkg_resources.Requirement`` instance.
        If necessary, or if the `force_scan` flag is set, the requirement is
        searched for in the (online) package index as well as the locally
        installed packages.  If a distribution matching `requirement` is found,
        the returned distribution's ``location`` is the value you would have
        gotten from calling the ``download()`` method with the matching
        distribution's URL or filename.  If no matching distribution is found,
        ``None`` is returned.

        If the `source` flag is set, only source distributions and source
        checkout links will be considered.  Unless the `develop_ok` flag is
        set, development and system eggs (i.e., those using the ``.egg-info``
        format) will be ignored.
        """
        # process a Requirement
        self.info("Searching for %s", requirement)
        skipped = {}
        dist = None

        def find(req, env=None):
            if env is None:
                env = self
            # Find a matching distribution; may be called more than once

            for dist in env[req.key]:

                if dist.precedence == DEVELOP_DIST and not develop_ok:
                    if dist not in skipped:
                        self.warn(
                            "Skipping development or system egg: %s", dist,
                        )
                        skipped[dist] = 1
                    continue

                test = (
                    dist in req
                    and (dist.precedence <= SOURCE_DIST or not source)
                )
                if test:
                    loc = self.download(dist.location, tmpdir)
                    dist.download_location = loc
                    if os.path.exists(dist.download_location):
                        return dist

        if force_scan:
            self.prescan()
            self.find_packages(requirement)
            dist = find(requirement)

        if not dist and local_index is not None:
            dist = find(requirement, local_index)

        if dist is None:
            if self.to_scan is not None:
                self.prescan()
            dist = find(requirement)

        if dist is None and not force_scan:
            self.find_packages(requirement)
            dist = find(requirement)

        if dist is None:
            self.warn(
                "No local packages or working download links found for %s%s",
                (source and "a source distribution of " or ""),
                requirement,
            )
        else:
            self.info("Best match: %s", dist)
            return dist.clone(location=dist.download_location)

    def fetch(self, requirement, tmpdir, force_scan=False, source=False):
        """Obtain a file suitable for fulfilling `requirement`

        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For
        backward compatibility, this routine is identical but returns the
        ``location`` of the downloaded distribution instead of a distribution
        object.
        """
        dist = self.fetch_distribution(requirement, tmpdir, force_scan, source)
        if dist is not None:
            return dist.location
        return None

    def gen_setup(self, filename, fragment, tmpdir):
        match = EGG_FRAGMENT.match(fragment)
        dists = match and [
            d for d in
            interpret_distro_name(filename, match.group(1), None) if d.version
        ] or []

        if len(dists) == 1:  # unambiguous ``#egg`` fragment
            basename = os.path.basename(filename)

            # Make sure the file has been downloaded to the temp dir.
            if os.path.dirname(filename) != tmpdir:
                dst = os.path.join(tmpdir, basename)
                from setuptools.command.easy_install import samefile
                if not samefile(filename, dst):
                    shutil.copy2(filename, dst)
                    filename = dst

            with open(os.path.join(tmpdir, 'setup.py'), 'w') as file:
                file.write(
                    "from setuptools import setup\n"
                    "setup(name=%r, version=%r, py_modules=[%r])\n"
                    % (
                        dists[0].project_name, dists[0].version,
                        os.path.splitext(basename)[0]
                    )
                )
            return filename

        elif match:
            raise DistutilsError(
                "Can't unambiguously interpret project/version identifier %r; "
                "any dashes in the name or version should be escaped using "
                "underscores. %r" % (fragment, dists)
            )
        else:
            raise DistutilsError(
                "Can't process plain .py files without an '#egg=name-version'"
                " suffix to enable automatic setup script generation."
            )

    dl_blocksize = 8192

    def _download_to(self, url, filename):
        self.info("Downloading %s", url)
        # Download the file
        fp = None
        try:
            checker = HashChecker.from_url(url)
            fp = self.open_url(url)
            if isinstance(fp, urllib.error.HTTPError):
                raise DistutilsError(
                    "Can't download %s: %s %s" % (url, fp.code, fp.msg)
                )
            headers = fp.info()
            blocknum = 0
            bs = self.dl_blocksize
            size = -1
            if "content-length" in headers:
                # Some servers return multiple Content-Length headers :(
                sizes = headers.get_all('Content-Length')
                size = max(map(int, sizes))
                self.reporthook(url, filename, blocknum, bs, size)
            with open(filename, 'wb') as tfp:
                while True:
                    block = fp.read(bs)
                    if block:
                        checker.feed(block)
                        tfp.write(block)
                        blocknum += 1
                        self.reporthook(url, filename, blocknum, bs, size)
                    else:
                        break
                self.check_hash(checker, filename, tfp)
            return headers
        finally:
            if fp:
                fp.close()

    def reporthook(self, url, filename, blocknum, blksize, size):
        pass  # no-op

    # FIXME:
    def open_url(self, url, warning=None):  # noqa: C901  # is too complex (12)
        if url.startswith('file:'):
            return local_open(url)
        try:
            return open_with_auth(url, self.opener)
        except (ValueError, http.client.InvalidURL) as v:
            msg = ' '.join([str(arg) for arg in v.args])
            if warning:
                self.warn(warning, msg)
            else:
                raise DistutilsError('%s %s' % (url, msg)) from v
        except urllib.error.HTTPError as v:
            return v
        except urllib.error.URLError as v:
            if warning:
                self.warn(warning, v.reason)
            else:
                raise DistutilsError("Download error for %s: %s"
                                     % (url, v.reason)) from v
        except http.client.BadStatusLine as v:
            if warning:
                self.warn(warning, v.line)
            else:
                raise DistutilsError(
                    '%s returned a bad status line. The server might be '
                    'down, %s' %
                    (url, v.line)
                ) from v
        except (http.client.HTTPException, socket.error) as v:
            if warning:
                self.warn(warning, v)
            else:
                raise DistutilsError("Download error for %s: %s"
                                     % (url, v)) from v

    def _download_url(self, scheme, url, tmpdir):
        # Determine download filename
        #
        name, fragment = egg_info_for_url(url)
        if name:
            while '..' in name:
                name = name.replace('..', '.').replace('\\', '_')
        else:
            name = "__downloaded__"  # default if URL has no path contents

        if name.endswith('.egg.zip'):
            name = name[:-4]  # strip the extra .zip before download

        filename = os.path.join(tmpdir, name)

        # Download the file
        #
        if scheme == 'svn' or scheme.startswith('svn+'):
            return self._download_svn(url, filename)
        elif scheme == 'git' or scheme.startswith('git+'):
            return self._download_git(url, filename)
        elif scheme.startswith('hg+'):
            return self._download_hg(url, filename)
        elif scheme == 'file':
            return urllib.request.url2pathname(urllib.parse.urlparse(url)[2])
        else:
            self.url_ok(url, True)  # raises error if not allowed
            return self._attempt_download(url, filename)

    def scan_url(self, url):
        self.process_url(url, True)

    def _attempt_download(self, url, filename):
        headers = self._download_to(url, filename)
        if 'html' in headers.get('content-type', '').lower():
            return self._download_html(url, headers, filename)
        else:
            return filename

    def _download_html(self, url, headers, filename):
        file = open(filename)
        for line in file:
            if line.strip():
                # Check for a subversion index page
                if re.search(r'<title>([^- ]+ - )?Revision \d+:', line):
                    # it's a subversion index page:
                    file.close()
                    os.unlink(filename)
                    return self._download_svn(url, filename)
                break  # not an index page
        file.close()
        os.unlink(filename)
        raise DistutilsError("Unexpected HTML page found at " + url)

    def _download_svn(self, url, filename):
        warnings.warn("SVN download support is deprecated", UserWarning)
        url = url.split('#', 1)[0]  # remove any fragment for svn's sake
        creds = ''
        if url.lower().startswith('svn:') and '@' in url:
            scheme, netloc, path, p, q, f = urllib.parse.urlparse(url)
            if not netloc and path.startswith('//') and '/' in path[2:]:
                netloc, path = path[2:].split('/', 1)
                auth, host = _splituser(netloc)
                if auth:
                    if ':' in auth:
                        user, pw = auth.split(':', 1)
                        creds = " --username=%s --password=%s" % (user, pw)
                    else:
                        creds = " --username=" + auth
                    netloc = host
                    parts = scheme, netloc, url, p, q, f
                    url = urllib.parse.urlunparse(parts)
        self.info("Doing subversion checkout from %s to %s", url, filename)
        os.system("svn checkout%s -q %s %s" % (creds, url, filename))
        return filename

    @staticmethod
    def _vcs_split_rev_from_url(url, pop_prefix=False):
        scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)

        scheme = scheme.split('+', 1)[-1]

        # Some fragment identification fails
        path = path.split('#', 1)[0]

        rev = None
        if '@' in path:
            path, rev = path.rsplit('@', 1)

        # Also, discard fragment
        url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''))

        return url, rev

    def _download_git(self, url, filename):
        filename = filename.split('#', 1)[0]
        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)

        self.info("Doing git clone from %s to %s", url, filename)
        os.system("git clone --quiet %s %s" % (url, filename))

        if rev is not None:
            self.info("Checking out %s", rev)
            os.system("git -C %s checkout --quiet %s" % (
                filename,
                rev,
            ))

        return filename

    def _download_hg(self, url, filename):
        filename = filename.split('#', 1)[0]
        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)

        self.info("Doing hg clone from %s to %s", url, filename)
        os.system("hg clone --quiet %s %s" % (url, filename))

        if rev is not None:
            self.info("Updating to %s", rev)
            os.system("hg --cwd %s up -C -r %s -q" % (
                filename,
                rev,
            ))

        return filename

    def debug(self, msg, *args):
        log.debug(msg, *args)

    def info(self, msg, *args):
        log.info(msg, *args)

    def warn(self, msg, *args):
        log.warn(msg, *args)


# This pattern matches a character entity reference (a decimal numeric
# references, a hexadecimal numeric reference, or a named reference).
entity_sub = re.compile(r'&(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?').sub


def decode_entity(match):
    what = match.group(0)
    return html.unescape(what)


def htmldecode(text):
    """
    Decode HTML entities in the given text.

    >>> htmldecode(
    ...     'https://../package_name-0.1.2.tar.gz'
    ...     '?tokena=A&amp;tokenb=B">package_name-0.1.2.tar.gz')
    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B">package_name-0.1.2.tar.gz'
    """
    return entity_sub(decode_entity, text)


def socket_timeout(timeout=15):
    def _socket_timeout(func):
        def _socket_timeout(*args, **kwargs):
            old_timeout = socket.getdefaulttimeout()
            socket.setdefaulttimeout(timeout)
            try:
                return func(*args, **kwargs)
            finally:
                socket.setdefaulttimeout(old_timeout)

        return _socket_timeout

    return _socket_timeout


def _encode_auth(auth):
    """
    Encode auth from a URL suitable for an HTTP header.
    >>> str(_encode_auth('username%3Apassword'))
    'dXNlcm5hbWU6cGFzc3dvcmQ='

    Long auth strings should not cause a newline to be inserted.
    >>> long_auth = 'username:' + 'password'*10
    >>> chr(10) in str(_encode_auth(long_auth))
    False
    """
    auth_s = urllib.parse.unquote(auth)
    # convert to bytes
    auth_bytes = auth_s.encode()
    encoded_bytes = base64.b64encode(auth_bytes)
    # convert back to a string
    encoded = encoded_bytes.decode()
    # strip the trailing carriage return
    return encoded.replace('\n', '')


class Credential:
    """
    A username/password pair. Use like a namedtuple.
    """

    def __init__(self, username, password):
        self.username = username
        self.password = password

    def __iter__(self):
        yield self.username
        yield self.password

    def __str__(self):
        return '%(username)s:%(password)s' % vars(self)


class PyPIConfig(configparser.RawConfigParser):
    def __init__(self):
        """
        Load from ~/.pypirc
        """
        defaults = dict.fromkeys(['username', 'password', 'repository'], '')
        configparser.RawConfigParser.__init__(self, defaults)

        rc = os.path.join(os.path.expanduser('~'), '.pypirc')
        if os.path.exists(rc):
            self.read(rc)

    @property
    def creds_by_repository(self):
        sections_with_repositories = [
            section for section in self.sections()
            if self.get(section, 'repository').strip()
        ]

        return dict(map(self._get_repo_cred, sections_with_repositories))

    def _get_repo_cred(self, section):
        repo = self.get(section, 'repository').strip()
        return repo, Credential(
            self.get(section, 'username').strip(),
            self.get(section, 'password').strip(),
        )

    def find_credential(self, url):
        """
        If the URL indicated appears to be a repository defined in this
        config, return the credential for that repository.
        """
        for repository, cred in self.creds_by_repository.items():
            if url.startswith(repository):
                return cred


def open_with_auth(url, opener=urllib.request.urlopen):
    """Open a urllib2 request, handling HTTP authentication"""

    parsed = urllib.parse.urlparse(url)
    scheme, netloc, path, params, query, frag = parsed

    # Double scheme does not raise on macOS as revealed by a
    # failing test. We would expect "nonnumeric port". Refs #20.
    if netloc.endswith(':'):
        raise http.client.InvalidURL("nonnumeric port: ''")

    if scheme in ('http', 'https'):
        auth, address = _splituser(netloc)
    else:
        auth = None

    if not auth:
        cred = PyPIConfig().find_credential(url)
        if cred:
            auth = str(cred)
            info = cred.username, url
            log.info('Authenticating as %s for %s (from .pypirc)', *info)

    if auth:
        auth = "Basic " + _encode_auth(auth)
        parts = scheme, address, path, params, query, frag
        new_url = urllib.parse.urlunparse(parts)
        request = urllib.request.Request(new_url)
        request.add_header("Authorization", auth)
    else:
        request = urllib.request.Request(url)

    request.add_header('User-Agent', user_agent)
    fp = opener(request)

    if auth:
        # Put authentication info back into request URL if same host,
        # so that links found on the page will work
        s2, h2, path2, param2, query2, frag2 = urllib.parse.urlparse(fp.url)
        if s2 == scheme and h2 == address:
            parts = s2, netloc, path2, param2, query2, frag2
            fp.url = urllib.parse.urlunparse(parts)

    return fp


# copy of urllib.parse._splituser from Python 3.8
def _splituser(host):
    """splituser('user[:passwd]@host[:port]')
    --> 'user[:passwd]', 'host[:port]'."""
    user, delim, host = host.rpartition('@')
    return (user if delim else None), host


# adding a timeout to avoid freezing package_index
open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)


def fix_sf_url(url):
    return url  # backward compatibility


def local_open(url):
    """Read a local path, with special support for directories"""
    scheme, server, path, param, query, frag = urllib.parse.urlparse(url)
    filename = urllib.request.url2pathname(path)
    if os.path.isfile(filename):
        return urllib.request.urlopen(url)
    elif path.endswith('/') and os.path.isdir(filename):
        files = []
        for f in os.listdir(filename):
            filepath = os.path.join(filename, f)
            if f == 'index.html':
                with open(filepath, 'r') as fp:
                    body = fp.read()
                break
            elif os.path.isdir(filepath):
                f += '/'
            files.append('<a href="{name}">{name}</a>'.format(name=f))
        else:
            tmpl = (
                "<html><head><title>{url}</title>"
                "</head><body>{files}</body></html>")
            body = tmpl.format(url=url, files='\n'.join(files))
        status, message = 200, "OK"
    else:
        status, message, body = 404, "Path not found", "Not found"

    headers = {'content-type': 'text/html'}
    body_stream = io.StringIO(body)
    return urllib.error.HTTPError(url, status, message, headers, body_stream)

"""Utilities for extracting common archive formats"""

import zipfile
import tarfile
import os
import shutil
import posixpath
import contextlib
from distutils.errors import DistutilsError

from pkg_resources import ensure_directory

__all__ = [
    "unpack_archive", "unpack_zipfile", "unpack_tarfile", "default_filter",
    "UnrecognizedFormat", "extraction_drivers", "unpack_directory",
]


class UnrecognizedFormat(DistutilsError):
    """Couldn't recognize the archive type"""


def default_filter(src, dst):
    """The default progress/filter callback; returns True for all files"""
    return dst


def unpack_archive(
        filename, extract_dir, progress_filter=default_filter,
        drivers=None):
    """Unpack `filename` to `extract_dir`, or raise ``UnrecognizedFormat``

    `progress_filter` is a function taking two arguments: a source path
    internal to the archive ('/'-separated), and a filesystem path where it
    will be extracted.  The callback must return the desired extract path
    (which may be the same as the one passed in), or else ``None`` to skip
    that file or directory.  The callback can thus be used to report on the
    progress of the extraction, as well as to filter the items extracted or
    alter their extraction paths.

    `drivers`, if supplied, must be a non-empty sequence of functions with the
    same signature as this function (minus the `drivers` argument), that raise
    ``UnrecognizedFormat`` if they do not support extracting the designated
    archive type.  The `drivers` are tried in sequence until one is found that
    does not raise an error, or until all are exhausted (in which case
    ``UnrecognizedFormat`` is raised).  If you do not supply a sequence of
    drivers, the module's ``extraction_drivers`` constant will be used, which
    means that ``unpack_zipfile`` and ``unpack_tarfile`` will be tried, in that
    order.
    """
    for driver in drivers or extraction_drivers:
        try:
            driver(filename, extract_dir, progress_filter)
        except UnrecognizedFormat:
            continue
        else:
            return
    else:
        raise UnrecognizedFormat(
            "Not a recognized archive type: %s" % filename
        )


def unpack_directory(filename, extract_dir, progress_filter=default_filter):
    """"Unpack" a directory, using the same interface as for archives

    Raises ``UnrecognizedFormat`` if `filename` is not a directory
    """
    if not os.path.isdir(filename):
        raise UnrecognizedFormat("%s is not a directory" % filename)

    paths = {
        filename: ('', extract_dir),
    }
    for base, dirs, files in os.walk(filename):
        src, dst = paths[base]
        for d in dirs:
            paths[os.path.join(base, d)] = src + d + '/', os.path.join(dst, d)
        for f in files:
            target = os.path.join(dst, f)
            target = progress_filter(src + f, target)
            if not target:
                # skip non-files
                continue
            ensure_directory(target)
            f = os.path.join(base, f)
            shutil.copyfile(f, target)
            shutil.copystat(f, target)


def unpack_zipfile(filename, extract_dir, progress_filter=default_filter):
    """Unpack zip `filename` to `extract_dir`

    Raises ``UnrecognizedFormat`` if `filename` is not a zipfile (as determined
    by ``zipfile.is_zipfile()``).  See ``unpack_archive()`` for an explanation
    of the `progress_filter` argument.
    """

    if not zipfile.is_zipfile(filename):
        raise UnrecognizedFormat("%s is not a zip file" % (filename,))

    with zipfile.ZipFile(filename) as z:
        for info in z.infolist():
            name = info.filename

            # don't extract absolute paths or ones with .. in them
            if name.startswith('/') or '..' in name.split('/'):
                continue

            target = os.path.join(extract_dir, *name.split('/'))
            target = progress_filter(name, target)
            if not target:
                continue
            if name.endswith('/'):
                # directory
                ensure_directory(target)
            else:
                # file
                ensure_directory(target)
                data = z.read(info.filename)
                with open(target, 'wb') as f:
                    f.write(data)
            unix_attributes = info.external_attr >> 16
            if unix_attributes:
                os.chmod(target, unix_attributes)


def _resolve_tar_file_or_dir(tar_obj, tar_member_obj):
    """Resolve any links and extract link targets as normal files."""
    while tar_member_obj is not None and (
            tar_member_obj.islnk() or tar_member_obj.issym()):
        linkpath = tar_member_obj.linkname
        if tar_member_obj.issym():
            base = posixpath.dirname(tar_member_obj.name)
            linkpath = posixpath.join(base, linkpath)
            linkpath = posixpath.normpath(linkpath)
        tar_member_obj = tar_obj._getmember(linkpath)

    is_file_or_dir = (
        tar_member_obj is not None and
        (tar_member_obj.isfile() or tar_member_obj.isdir())
    )
    if is_file_or_dir:
        return tar_member_obj

    raise LookupError('Got unknown file type')


def _iter_open_tar(tar_obj, extract_dir, progress_filter):
    """Emit member-destination pairs from a tar archive."""
    # don't do any chowning!
    tar_obj.chown = lambda *args: None

    with contextlib.closing(tar_obj):
        for member in tar_obj:
            name = member.name
            # don't extract absolute paths or ones with .. in them
            if name.startswith('/') or '..' in name.split('/'):
                continue

            prelim_dst = os.path.join(extract_dir, *name.split('/'))

            try:
                member = _resolve_tar_file_or_dir(tar_obj, member)
            except LookupError:
                continue

            final_dst = progress_filter(name, prelim_dst)
            if not final_dst:
                continue

            if final_dst.endswith(os.sep):
                final_dst = final_dst[:-1]

            yield member, final_dst


def unpack_tarfile(filename, extract_dir, progress_filter=default_filter):
    """Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`

    Raises ``UnrecognizedFormat`` if `filename` is not a tarfile (as determined
    by ``tarfile.open()``).  See ``unpack_archive()`` for an explanation
    of the `progress_filter` argument.
    """
    try:
        tarobj = tarfile.open(filename)
    except tarfile.TarError as e:
        raise UnrecognizedFormat(
            "%s is not a compressed or uncompressed tar file" % (filename,)
        ) from e

    for member, final_dst in _iter_open_tar(
            tarobj, extract_dir, progress_filter,
    ):
        try:
            # XXX Ugh
            tarobj._extract_member(member, final_dst)
        except tarfile.ExtractError:
            # chown/chmod/mkfifo/mknode/makedev failed
            pass

    return True


extraction_drivers = unpack_directory, unpack_zipfile, unpack_tarfile

"""
Re-implementation of find_module and get_frozen_object
from the deprecated imp module.
"""

import os
import importlib.util
import importlib.machinery

from .py34compat import module_from_spec


PY_SOURCE = 1
PY_COMPILED = 2
C_EXTENSION = 3
C_BUILTIN = 6
PY_FROZEN = 7


def find_spec(module, paths):
    finder = (
        importlib.machinery.PathFinder().find_spec
        if isinstance(paths, list) else
        importlib.util.find_spec
    )
    return finder(module, paths)


def find_module(module, paths=None):
    """Just like 'imp.find_module()', but with package support"""
    spec = find_spec(module, paths)
    if spec is None:
        raise ImportError("Can't find %s" % module)
    if not spec.has_location and hasattr(spec, 'submodule_search_locations'):
        spec = importlib.util.spec_from_loader('__init__.py', spec.loader)

    kind = -1
    file = None
    static = isinstance(spec.loader, type)
    if spec.origin == 'frozen' or static and issubclass(
            spec.loader, importlib.machinery.FrozenImporter):
        kind = PY_FROZEN
        path = None  # imp compabilty
        suffix = mode = ''  # imp compatibility
    elif spec.origin == 'built-in' or static and issubclass(
            spec.loader, importlib.machinery.BuiltinImporter):
        kind = C_BUILTIN
        path = None  # imp compabilty
        suffix = mode = ''  # imp compatibility
    elif spec.has_location:
        path = spec.origin
        suffix = os.path.splitext(path)[1]
        mode = 'r' if suffix in importlib.machinery.SOURCE_SUFFIXES else 'rb'

        if suffix in importlib.machinery.SOURCE_SUFFIXES:
            kind = PY_SOURCE
        elif suffix in importlib.machinery.BYTECODE_SUFFIXES:
            kind = PY_COMPILED
        elif suffix in importlib.machinery.EXTENSION_SUFFIXES:
            kind = C_EXTENSION

        if kind in {PY_SOURCE, PY_COMPILED}:
            file = open(path, mode)
    else:
        path = None
        suffix = mode = ''

    return file, path, (suffix, mode, kind)


def get_frozen_object(module, paths=None):
    spec = find_spec(module, paths)
    if not spec:
        raise ImportError("Can't find %s" % module)
    return spec.loader.get_code(module)


def get_module(module, paths, info):
    spec = find_spec(module, paths)
    if not spec:
        raise ImportError("Can't find %s" % module)
    return module_from_spec(spec)

import ast
import io
import os
import sys

import warnings
import functools
import importlib
from collections import defaultdict
from functools import partial
from functools import wraps
from glob import iglob
import contextlib

from distutils.errors import DistutilsOptionError, DistutilsFileError
from setuptools.extern.packaging.version import LegacyVersion, parse
from setuptools.extern.packaging.specifiers import SpecifierSet


class StaticModule:
    """
    Attempt to load the module by the name
    """

    def __init__(self, name):
        spec = importlib.util.find_spec(name)
        with open(spec.origin) as strm:
            src = strm.read()
        module = ast.parse(src)
        vars(self).update(locals())
        del self.self

    def __getattr__(self, attr):
        try:
            return next(
                ast.literal_eval(statement.value)
                for statement in self.module.body
                if isinstance(statement, ast.Assign)
                for target in statement.targets
                if isinstance(target, ast.Name) and target.id == attr
            )
        except Exception as e:
            raise AttributeError(
                "{self.name} has no attribute {attr}".format(**locals())
            ) from e


@contextlib.contextmanager
def patch_path(path):
    """
    Add path to front of sys.path for the duration of the context.
    """
    try:
        sys.path.insert(0, path)
        yield
    finally:
        sys.path.remove(path)


def read_configuration(filepath, find_others=False, ignore_option_errors=False):
    """Read given configuration file and returns options from it as a dict.

    :param str|unicode filepath: Path to configuration file
        to get options from.

    :param bool find_others: Whether to search for other configuration files
        which could be on in various places.

    :param bool ignore_option_errors: Whether to silently ignore
        options, values of which could not be resolved (e.g. due to exceptions
        in directives such as file:, attr:, etc.).
        If False exceptions are propagated as expected.

    :rtype: dict
    """
    from setuptools.dist import Distribution, _Distribution

    filepath = os.path.abspath(filepath)

    if not os.path.isfile(filepath):
        raise DistutilsFileError('Configuration file %s does not exist.' % filepath)

    current_directory = os.getcwd()
    os.chdir(os.path.dirname(filepath))

    try:
        dist = Distribution()

        filenames = dist.find_config_files() if find_others else []
        if filepath not in filenames:
            filenames.append(filepath)

        _Distribution.parse_config_files(dist, filenames=filenames)

        handlers = parse_configuration(
            dist, dist.command_options, ignore_option_errors=ignore_option_errors
        )

    finally:
        os.chdir(current_directory)

    return configuration_to_dict(handlers)


def _get_option(target_obj, key):
    """
    Given a target object and option key, get that option from
    the target object, either through a get_{key} method or
    from an attribute directly.
    """
    getter_name = 'get_{key}'.format(**locals())
    by_attribute = functools.partial(getattr, target_obj, key)
    getter = getattr(target_obj, getter_name, by_attribute)
    return getter()


def configuration_to_dict(handlers):
    """Returns configuration data gathered by given handlers as a dict.

    :param list[ConfigHandler] handlers: Handlers list,
        usually from parse_configuration()

    :rtype: dict
    """
    config_dict = defaultdict(dict)

    for handler in handlers:
        for option in handler.set_options:
            value = _get_option(handler.target_obj, option)
            config_dict[handler.section_prefix][option] = value

    return config_dict


def parse_configuration(distribution, command_options, ignore_option_errors=False):
    """Performs additional parsing of configuration options
    for a distribution.

    Returns a list of used option handlers.

    :param Distribution distribution:
    :param dict command_options:
    :param bool ignore_option_errors: Whether to silently ignore
        options, values of which could not be resolved (e.g. due to exceptions
        in directives such as file:, attr:, etc.).
        If False exceptions are propagated as expected.
    :rtype: list
    """
    options = ConfigOptionsHandler(distribution, command_options, ignore_option_errors)
    options.parse()

    meta = ConfigMetadataHandler(
        distribution.metadata,
        command_options,
        ignore_option_errors,
        distribution.package_dir,
    )
    meta.parse()

    return meta, options


class ConfigHandler:
    """Handles metadata supplied in configuration files."""

    section_prefix = None
    """Prefix for config sections handled by this handler.
    Must be provided by class heirs.

    """

    aliases = {}
    """Options aliases.
    For compatibility with various packages. E.g.: d2to1 and pbr.
    Note: `-` in keys is replaced with `_` by config parser.

    """

    def __init__(self, target_obj, options, ignore_option_errors=False):
        sections = {}

        section_prefix = self.section_prefix
        for section_name, section_options in options.items():
            if not section_name.startswith(section_prefix):
                continue

            section_name = section_name.replace(section_prefix, '').strip('.')
            sections[section_name] = section_options

        self.ignore_option_errors = ignore_option_errors
        self.target_obj = target_obj
        self.sections = sections
        self.set_options = []

    @property
    def parsers(self):
        """Metadata item name to parser function mapping."""
        raise NotImplementedError(
            '%s must provide .parsers property' % self.__class__.__name__
        )

    def __setitem__(self, option_name, value):
        unknown = tuple()
        target_obj = self.target_obj

        # Translate alias into real name.
        option_name = self.aliases.get(option_name, option_name)

        current_value = getattr(target_obj, option_name, unknown)

        if current_value is unknown:
            raise KeyError(option_name)

        if current_value:
            # Already inhabited. Skipping.
            return

        skip_option = False
        parser = self.parsers.get(option_name)
        if parser:
            try:
                value = parser(value)

            except Exception:
                skip_option = True
                if not self.ignore_option_errors:
                    raise

        if skip_option:
            return

        setter = getattr(target_obj, 'set_%s' % option_name, None)
        if setter is None:
            setattr(target_obj, option_name, value)
        else:
            setter(value)

        self.set_options.append(option_name)

    @classmethod
    def _parse_list(cls, value, separator=','):
        """Represents value as a list.

        Value is split either by separator (defaults to comma) or by lines.

        :param value:
        :param separator: List items separator character.
        :rtype: list
        """
        if isinstance(value, list):  # _get_parser_compound case
            return value

        if '\n' in value:
            value = value.splitlines()
        else:
            value = value.split(separator)

        return [chunk.strip() for chunk in value if chunk.strip()]

    @classmethod
    def _parse_list_glob(cls, value, separator=','):
        """Equivalent to _parse_list() but expands any glob patterns using glob().

        However, unlike with glob() calls, the results remain relative paths.

        :param value:
        :param separator: List items separator character.
        :rtype: list
        """
        glob_characters = ('*', '?', '[', ']', '{', '}')
        values = cls._parse_list(value, separator=separator)
        expanded_values = []
        for value in values:

            # Has globby characters?
            if any(char in value for char in glob_characters):
                # then expand the glob pattern while keeping paths *relative*:
                expanded_values.extend(sorted(
                    os.path.relpath(path, os.getcwd())
                    for path in iglob(os.path.abspath(value))))

            else:
                # take the value as-is:
                expanded_values.append(value)

        return expanded_values

    @classmethod
    def _parse_dict(cls, value):
        """Represents value as a dict.

        :param value:
        :rtype: dict
        """
        separator = '='
        result = {}
        for line in cls._parse_list(value):
            key, sep, val = line.partition(separator)
            if sep != separator:
                raise DistutilsOptionError(
                    'Unable to parse option value to dict: %s' % value
                )
            result[key.strip()] = val.strip()

        return result

    @classmethod
    def _parse_bool(cls, value):
        """Represents value as boolean.

        :param value:
        :rtype: bool
        """
        value = value.lower()
        return value in ('1', 'true', 'yes')

    @classmethod
    def _exclude_files_parser(cls, key):
        """Returns a parser function to make sure field inputs
        are not files.

        Parses a value after getting the key so error messages are
        more informative.

        :param key:
        :rtype: callable
        """

        def parser(value):
            exclude_directive = 'file:'
            if value.startswith(exclude_directive):
                raise ValueError(
                    'Only strings are accepted for the {0} field, '
                    'files are not accepted'.format(key)
                )
            return value

        return parser

    @classmethod
    def _parse_file(cls, value):
        """Represents value as a string, allowing including text
        from nearest files using `file:` directive.

        Directive is sandboxed and won't reach anything outside
        directory with setup.py.

        Examples:
            file: README.rst, CHANGELOG.md, src/file.txt

        :param str value:
        :rtype: str
        """
        include_directive = 'file:'

        if not isinstance(value, str):
            return value

        if not value.startswith(include_directive):
            return value

        spec = value[len(include_directive) :]
        filepaths = (os.path.abspath(path.strip()) for path in spec.split(','))
        return '\n'.join(
            cls._read_file(path)
            for path in filepaths
            if (cls._assert_local(path) or True) and os.path.isfile(path)
        )

    @staticmethod
    def _assert_local(filepath):
        if not filepath.startswith(os.getcwd()):
            raise DistutilsOptionError('`file:` directive can not access %s' % filepath)

    @staticmethod
    def _read_file(filepath):
        with io.open(filepath, encoding='utf-8') as f:
            return f.read()

    @classmethod
    def _parse_attr(cls, value, package_dir=None):
        """Represents value as a module attribute.

        Examples:
            attr: package.attr
            attr: package.module.attr

        :param str value:
        :rtype: str
        """
        attr_directive = 'attr:'
        if not value.startswith(attr_directive):
            return value

        attrs_path = value.replace(attr_directive, '').strip().split('.')
        attr_name = attrs_path.pop()

        module_name = '.'.join(attrs_path)
        module_name = module_name or '__init__'

        parent_path = os.getcwd()
        if package_dir:
            if attrs_path[0] in package_dir:
                # A custom path was specified for the module we want to import
                custom_path = package_dir[attrs_path[0]]
                parts = custom_path.rsplit('/', 1)
                if len(parts) > 1:
                    parent_path = os.path.join(os.getcwd(), parts[0])
                    module_name = parts[1]
                else:
                    module_name = custom_path
            elif '' in package_dir:
                # A custom parent directory was specified for all root modules
                parent_path = os.path.join(os.getcwd(), package_dir[''])

        with patch_path(parent_path):
            try:
                # attempt to load value statically
                return getattr(StaticModule(module_name), attr_name)
            except Exception:
                # fallback to simple import
                module = importlib.import_module(module_name)

        return getattr(module, attr_name)

    @classmethod
    def _get_parser_compound(cls, *parse_methods):
        """Returns parser function to represents value as a list.

        Parses a value applying given methods one after another.

        :param parse_methods:
        :rtype: callable
        """

        def parse(value):
            parsed = value

            for method in parse_methods:
                parsed = method(parsed)

            return parsed

        return parse

    @classmethod
    def _parse_section_to_dict(cls, section_options, values_parser=None):
        """Parses section options into a dictionary.

        Optionally applies a given parser to values.

        :param dict section_options:
        :param callable values_parser:
        :rtype: dict
        """
        value = {}
        values_parser = values_parser or (lambda val: val)
        for key, (_, val) in section_options.items():
            value[key] = values_parser(val)
        return value

    def parse_section(self, section_options):
        """Parses configuration file section.

        :param dict section_options:
        """
        for (name, (_, value)) in section_options.items():
            try:
                self[name] = value

            except KeyError:
                pass  # Keep silent for a new option may appear anytime.

    def parse(self):
        """Parses configuration file items from one
        or more related sections.

        """
        for section_name, section_options in self.sections.items():

            method_postfix = ''
            if section_name:  # [section.option] variant
                method_postfix = '_%s' % section_name

            section_parser_method = getattr(
                self,
                # Dots in section names are translated into dunderscores.
                ('parse_section%s' % method_postfix).replace('.', '__'),
                None,
            )

            if section_parser_method is None:
                raise DistutilsOptionError(
                    'Unsupported distribution option section: [%s.%s]'
                    % (self.section_prefix, section_name)
                )

            section_parser_method(section_options)

    def _deprecated_config_handler(self, func, msg, warning_class):
        """this function will wrap around parameters that are deprecated

        :param msg: deprecation message
        :param warning_class: class of warning exception to be raised
        :param func: function to be wrapped around
        """

        @wraps(func)
        def config_handler(*args, **kwargs):
            warnings.warn(msg, warning_class)
            return func(*args, **kwargs)

        return config_handler


class ConfigMetadataHandler(ConfigHandler):

    section_prefix = 'metadata'

    aliases = {
        'home_page': 'url',
        'summary': 'description',
        'classifier': 'classifiers',
        'platform': 'platforms',
    }

    strict_mode = False
    """We need to keep it loose, to be partially compatible with
    `pbr` and `d2to1` packages which also uses `metadata` section.

    """

    def __init__(
        self, target_obj, options, ignore_option_errors=False, package_dir=None
    ):
        super(ConfigMetadataHandler, self).__init__(
            target_obj, options, ignore_option_errors
        )
        self.package_dir = package_dir

    @property
    def parsers(self):
        """Metadata item name to parser function mapping."""
        parse_list = self._parse_list
        parse_file = self._parse_file
        parse_dict = self._parse_dict
        exclude_files_parser = self._exclude_files_parser

        return {
            'platforms': parse_list,
            'keywords': parse_list,
            'provides': parse_list,
            'requires': self._deprecated_config_handler(
                parse_list,
                "The requires parameter is deprecated, please use "
                "install_requires for runtime dependencies.",
                DeprecationWarning,
            ),
            'obsoletes': parse_list,
            'classifiers': self._get_parser_compound(parse_file, parse_list),
            'license': exclude_files_parser('license'),
            'license_file': self._deprecated_config_handler(
                exclude_files_parser('license_file'),
                "The license_file parameter is deprecated, "
                "use license_files instead.",
                DeprecationWarning,
            ),
            'license_files': parse_list,
            'description': parse_file,
            'long_description': parse_file,
            'version': self._parse_version,
            'project_urls': parse_dict,
        }

    def _parse_version(self, value):
        """Parses `version` option value.

        :param value:
        :rtype: str

        """
        version = self._parse_file(value)

        if version != value:
            version = version.strip()
            # Be strict about versions loaded from file because it's easy to
            # accidentally include newlines and other unintended content
            if isinstance(parse(version), LegacyVersion):
                tmpl = (
                    'Version loaded from {value} does not '
                    'comply with PEP 440: {version}'
                )
                raise DistutilsOptionError(tmpl.format(**locals()))

            return version

        version = self._parse_attr(value, self.package_dir)

        if callable(version):
            version = version()

        if not isinstance(version, str):
            if hasattr(version, '__iter__'):
                version = '.'.join(map(str, version))
            else:
                version = '%s' % version

        return version


class ConfigOptionsHandler(ConfigHandler):

    section_prefix = 'options'

    @property
    def parsers(self):
        """Metadata item name to parser function mapping."""
        parse_list = self._parse_list
        parse_list_semicolon = partial(self._parse_list, separator=';')
        parse_bool = self._parse_bool
        parse_dict = self._parse_dict
        parse_cmdclass = self._parse_cmdclass

        return {
            'zip_safe': parse_bool,
            'include_package_data': parse_bool,
            'package_dir': parse_dict,
            'scripts': parse_list,
            'eager_resources': parse_list,
            'dependency_links': parse_list,
            'namespace_packages': parse_list,
            'install_requires': parse_list_semicolon,
            'setup_requires': parse_list_semicolon,
            'tests_require': parse_list_semicolon,
            'packages': self._parse_packages,
            'entry_points': self._parse_file,
            'py_modules': parse_list,
            'python_requires': SpecifierSet,
            'cmdclass': parse_cmdclass,
        }

    def _parse_cmdclass(self, value):
        def resolve_class(qualified_class_name):
            idx = qualified_class_name.rfind('.')
            class_name = qualified_class_name[idx + 1 :]
            pkg_name = qualified_class_name[:idx]

            module = __import__(pkg_name)

            return getattr(module, class_name)

        return {k: resolve_class(v) for k, v in self._parse_dict(value).items()}

    def _parse_packages(self, value):
        """Parses `packages` option value.

        :param value:
        :rtype: list
        """
        find_directives = ['find:', 'find_namespace:']
        trimmed_value = value.strip()

        if trimmed_value not in find_directives:
            return self._parse_list(value)

        findns = trimmed_value == find_directives[1]

        # Read function arguments from a dedicated section.
        find_kwargs = self.parse_section_packages__find(
            self.sections.get('packages.find', {})
        )

        if findns:
            from setuptools import find_namespace_packages as find_packages
        else:
            from setuptools import find_packages

        return find_packages(**find_kwargs)

    def parse_section_packages__find(self, section_options):
        """Parses `packages.find` configuration file section.

        To be used in conjunction with _parse_packages().

        :param dict section_options:
        """
        section_data = self._parse_section_to_dict(section_options, self._parse_list)

        valid_keys = ['where', 'include', 'exclude']

        find_kwargs = dict(
            [(k, v) for k, v in section_data.items() if k in valid_keys and v]
        )

        where = find_kwargs.get('where')
        if where is not None:
            find_kwargs['where'] = where[0]  # cast list to single val

        return find_kwargs

    def parse_section_entry_points(self, section_options):
        """Parses `entry_points` configuration file section.

        :param dict section_options:
        """
        parsed = self._parse_section_to_dict(section_options, self._parse_list)
        self['entry_points'] = parsed

    def _parse_package_data(self, section_options):
        parsed = self._parse_section_to_dict(section_options, self._parse_list)

        root = parsed.get('*')
        if root:
            parsed[''] = root
            del parsed['*']

        return parsed

    def parse_section_package_data(self, section_options):
        """Parses `package_data` configuration file section.

        :param dict section_options:
        """
        self['package_data'] = self._parse_package_data(section_options)

    def parse_section_exclude_package_data(self, section_options):
        """Parses `exclude_package_data` configuration file section.

        :param dict section_options:
        """
        self['exclude_package_data'] = self._parse_package_data(section_options)

    def parse_section_extras_require(self, section_options):
        """Parses `extras_require` configuration file section.

        :param dict section_options:
        """
        parse_list = partial(self._parse_list, separator=';')
        self['extras_require'] = self._parse_section_to_dict(
            section_options, parse_list
        )

    def parse_section_data_files(self, section_options):
        """Parses `data_files` configuration file section.

        :param dict section_options:
        """
        parsed = self._parse_section_to_dict(section_options, self._parse_list_glob)
        self['data_files'] = [(k, v) for k, v in parsed.items()]

import pkg_resources

try:
    __version__ = pkg_resources.get_distribution('setuptools').version
except Exception:
    __version__ = 'unknown'

MZ                @                                       	!L!This program cannot be run in DOS mode.

$       
W^W^W^p^T^W^
^0^S^I-^s^I-^]^I-^:^I-^V^RichW^                PE  d Q         # 	     j      x+        @                      p                                                      (            ` 	                                                                                               .text                             `.rdata  )      *                 @  @.data   5                      @  .pdata  	   `  
                @  @                                                                                                                                                                                                                                                                                                                                                                                        H\$Hl$Ht$H|$ ATAUAVH LH3I   HD	HyHc@  33Lc "HXL~e    A,\u'"u ~D\HZ  H+\H3A,HHI;C|~D\H%  HHl$HHt$PH|$X"C H\$@IH A^A]A\H\$WH`  H H3H$P  HH	HtH/u@\uH$@  L$@  LD$@HT$0HHD$ ?  |$0    |$@\   H$@  L$@  LD$@HT$0HHD$   H3H|$@HD$@HHHH9\uH9\tHD$@H;r H9\uLD$@HT$0H$@  LHD$     
       |
  H$@       c
  HA  HH  HH$P  H3  H$  H`  _H\$Hl$Ht$H|$ ATAUAVH HH3LHPHH	  3HA} LE3HU  tD  KH@  u+H@t[@(  tEtI@\u@"u@u3E@2DtL\H	  H3@t@.HtL\H	  H3 AE IcE HI4@t&  tKH  u; GH\$@Hl$HHt$PH|$XIH A^A]A\H(u
! t36     H(H\$WH   33HHL$pDGh3$   HD$PHD$XHD$`  WH
D$ph     L\$PHD$pL\$HHD$@H|$8H|$0E3E3H3|$(D$      u(  H  HH`b  3H$   H   _D$`HL$P  _  HL$PH$   D  u(  H,  HH`  3H$   H   _$   H$   H   _H\$Hl$Ht$WATAUH LH3   IIcH;HHLLQ}J<H3IHDL;|IcH  H  MHL  H3IH;HLi}0LIcH  I  H<H3HHDH;|H\$@Hl$HHt$PIH A]A\_@SWAVAWHX  H
 H3H$0  LDD$ LcHT$0A   3  H3H|$0HHD/HL$0H;v 8.tHT$0  HH;w  3HH|$03H:  HL$0HG2  fG)  G	  u"  LD$0H  HH`&  C  H$0  A   H$  1  HcH0  _  H$0  HHH;st<
t<
u H$0  Hs  A     t%HM  H$0  HD  A>  AHT$$H$2  HT$0H8HHjHHu   H  LHH`B  E  H$P  t$$L$H  L$@  E,7   AEHc  HLI$I|$~"HfHHHHHGuHL$0   HI;HG}IHHI;HG||$  H$P  H    t*IH    H  HH`L`      EIHsH;L$H  L$@  H$  H$0  H3s
  HX  A_A^_[E3HHPHHL@LH SVWATH8H3H;;u'L&      H\$ E3E333b%    H;;u'&      H\$ E3E333/%     Ld$p  G@   H#  t*t%HcHHL) HkXIH
5
 H
,
 HL) B8u%ttHcHHHkXIA8t"j%      H\$ E3E333$  ;u*H	  ME3HT$hH  H  H  H8A\_^[H @SH l;    u   ;LHc   I; %  H+ Hu$PH,; %  H + Hu   x3H+ HH0HHt	H* E3H" EHILx( IHIHkXLItItMuIH0Iu3H [H(C)  =4  t&  H
V* H(}&  @SH HH
| H;r:H  H;w.HH*H+HHHH?L*  k
HK0c  H [@SH H}*  k
HJ05  H [H(H H;r7Hu H;w+qH+H*HHHH?Lk)  
H0  H(H(}rB)  
HJ0  H(@SH d$@ LD$@_*  HHu9D$@t"  Ht"  L$@HH [ff     HIrSIII@rHtL+HHMI?Iu9MIItfffHHIuMt
HIu@ fffffI   s0HHQHQH@HQHQIHQHQHQufD  HHQHQH@HQHQIHQHQHQu$ Tff     LMt$H+t(   HItuIHHHIr&I~LLIM3I MtI      HItx$tuHItiHtbHItV$tSHItGHt@HIt4$t1HIt%tHIt$tHI<IHH3IrEt
HII rHHQHQHQH I sI Ir	HHIIrHI@SH EHLAA LtA@McPLHcL#IcJHCHHKAtAHLL3IH [  H(MA8HI   H(H8HD$`HD$(LL$ MLH'  H8H\$LD$UVWATAUAVAWH0L$   L$   HL3MT$pH;t
L;uL;t     L;tL;uH9$   u
H9$   tL;uH9$   u
H9$   tL;uH9$   u
H9$   t   H8tHHH;w;:u,L;t!I;  A   LHI(  3H{L;tAHHH8te(  3;tH</t
<\t	<.u	HHkH8uH;t/L;t%LL+L9$      LHIT(  3HL;tAH;tQH;rLL;t!LL+L9$   vqLHI(  3L;tPH+H9$   vNLLHI'  /L;t!H+H9$   v(LLHI'  3L;tA$3   L$pL$   L;tL;vAL;t
H9$   vAL;tH9$   vAU L;tH9$   vA$H;u%  Hd$     E3E333.  ;u  "   H\$xH0A_A^A]A\_^]H\$Ht$WHPIHA   HH$   HHIMM#HHML\$@HL$8M#HHHLT$0LL$(I#HLMHT$ HAHH\$`Ht$hHP_ff     H;
y  uHfuH]&  @SH HA H   4  HCH   HH   HKH
 H;t   	 u2  HHs H9CtHC   
e	 u	)  HCHC   u   CoHH [@SH@=  HcuHk
 XVHL$ 3&HD$   ~LD$    5  DH@  DXA|$8 tHD$0   AH@[HT$LD$LL$ SH`Hu%  Hd$  E3E333      UHtHL$@HL$0L$   HL$0E3D$8D$HB   Z
  l$8x
HL$0 HT$03;6  H`[ff     MtuH+LI tB	H:uWItNtJH   uJ	ffwHJ	H;uHII~vHLI3ItH3HHt't#HttHtttuH3@SH 9  6  H
  0     H [H@SH H
    HtH  H  HtH [@SH      .      "  H;s-H\$WH HHHHtHH;rH\$0H _H\$WH 3HHH;suHHtHH;rH\$0H _H\$WH H=  tH
 :  t~ 9  H  H
[  ~uZH
9  F9  H/  H=0  HHtHH;rH=3  tH
* M:  tE33AP 3H\$0H _H\$Ht$DD$WATAUAVAWH@ED     =
    
    D%
    H
 .  HHD$0H   H
k .  HHD$ LHt$(LHD$8HH|$ H;r.  H9uH;r\H.  H.  HH
 z.  HH
 k.  L;uL;t LH\$(HH\$0LHD$8HHD$ H  H
  H  H
  Et
     Eu&    AL$  AA3  H\$pHt$xH@A_A^A]A\_E33jE3AP\33DBO   3D=@SH u-  HH=  HR=  H  H:=  H*=  H:  H8  H8  H
-  H  H [H\$WH0MZ  f9
uVHc=H
H8PE  t3\$@;  f9Ht3\$@(   w3\$@39   \$@3\$@   C  u"=E t4     l2     =/  u"= ts4     A2     6    y
   .  H @  H
 ?  y
   <  y
	   tL>
 L?
 H 
 

 D$ u|$@ uH\$HH0_H(7B  H(VHHXHhHp HPWATAUAVAWH@MyM!Iq8M+AfMHL   3HHL@9>+  H^CL;   CL;   {    ;tHL$0HI   ~sA} csmu(H=K  tH
B 5  t   I+ KA   HIGB  IF@SMcM HD$(IF(IMHHD$   JB  H;>sj>3fIy 3I+9.vTH^KL;r>CL;s6H;rH;sAE u/; t	H;t#HT$xIIDCMAH;.r   L\$@I[0Ik@IsHIA_A^A]A\_H\$H|$ATH H  A     H0H;u3H`H;uw    C  ucL%& HcI< u+   J  IHuHC HCH   C$CIC$   C   HKHK     3H\$0H|$8H A\t0SH bHsH  cc$ H# Hc H [@SH B@ItHz uA &Bx
HH,  u	H [~LH\$Hl$Ht$WH II@LH@?tH\$0Hl$8Ht$@H _H\$Hl$Ht$WH A@@IIHtIx uA7~3M LHH?u=  8*uLH?H\$0Hl$8Ht$@H _H\$UVWATAUAVAWH  HJ  H3H$  3HHL$hHHL$xIMD$`DD$TDD$HD$XD$PE3I;uA  3E3E333    H\$   8$   tH$        AC@L
   H
  H  A;t(t#LcL
IAHMkXMC 
LL
A@8u)A;ttHcHHHkXIC B8tA  3E3E333    H\$ 
  8$   tH$      A1  E3I;t@/ADT$@DT$DAL$   A:  H$   A   HA;H$     E<XwHB  AHcHcHB
  T$\A;y    /          <  @d~    A@  C   E.  G%  StmX  Zta  c   H  IE II;t/HXI;t&A sD$P   +  DT$P  H    A0  uAI] E;ADIA    I;D$P   HD`  H   A0  uAIA  t,EMH$   HL$DM@  E3A;tD$X   AED$D   $   H$   M  D$p   @ A@E;H$   A-  A   k  e  g~i   n   o   ptesu   x  '   SfD9t	HA;uH+H!I;HDF  H
D8tHA;u+L$D  A   A   D$`A   Ey`QD$L0AQD$MSA   EyDA	=I} I<  E3A;xA tf77D$X   l  A@A
   T$HArAs
ME I.IA tA@tMEEEA@tMcEEEA@t
M;}IAAr
ArEE;}A   AE;EOD|$`IH$  H#L$HAAA;M;t 3IIcHLB09~AHH$  A+HA	D$D  A;t	;0  HD$D0   u@guAA   9E;EOA   ~)A]  Hcy
  H$   HtHA   IE H
  I@HcH$   P!  HL$xDHL$0L$pLL$(H$   HDt$ A3   tD;uH
  !  HT$xH3@gu;uH
w     HT$xH;-uAHH9  E3D$DD9T$XK  A@t1AsD$L-AtD$L+   |$HAtD$L |$Ht$THl$h+t$D+AuLL$@L LL$@HL$LLAtAuLL$@L0|$D39D$Ptu;~qHDM H$  H$   A   H;  E3A;u2$   A;t&LD$hLL$@H$  E3A;uHl$h#Hl$hAD$@LL$@LHdE3D$@A;|AtLL$@L E3H$   I;tHA
  E3L$   H$   t$@T$\L
/A   @/A:$D8$   tH$      H$  H32H$   H  A_A^A]A\_^]@It:@ht+@lt
@wuA?lu
HAAwA nA<6u4uHAO<3u2uHA7<d/<i'<o<u<x<XDT$\HT$x@DT$Pl6  3;t!HT$hLD$@@<@/H@:  HT$hLD$@@E3@*uEu IE;EC@DtH}Eu@*uAE IA;D$TZAD$T@DHD$T:@ tA@#t1@+t"@-t@0AAAAADT$pDT$XDT$TDT$HEEDT$PR  E3E333Ht$     h  @8$   wHHXHpHxL` AUAVAWH   HL$   X   DbI  LE3I;u{  H A
 H   L;sCE{IAC	
E{E{8AC9
AC:
E{PE{LIXH H   L;r
z fD9|$bI  HD$hI;;  LhHc0I   9L   ;   L5P X   I  LI;tiI A I   L;sAE{IAC	
E{Ac8AC9
AC:
E{PE{LIXIH   L;r H;| L5 AA;~~H>tkH>teAE t^AE uH  A;tILcIHAMkXM$HI$AE AD$IL$  *  A;tAD$   IH;|EIHHkXH) H;tH;tKCAD$E;D  HHtJI;tEH  A;t7H3uK@	uKHK  "*  A;tC.K@HAHHQ
j l  3L$   I[ Is(I{0Mc8IA_A^A]H8Hu%*  Hd$  E3E333    ?  AH8H
Y  @SH  d$p HL$t3A   PL\$pH$  H$  L\$HHD$P  H$  HT$@HE3q  Ht;Hd$8 HT$@HL$`HL$0HL$XLHL$(H$  LHL$ 3-   H$  H$  H$  H$  H$  D$p D$t   H$   e  3S  HL$H@  uuHl4  "   H  H  [H\$Hl$Ht$WH0HH
  AIH@  HtLT$`DLHHLT$ %   3  L\$`DLHHL\$ hH\$@Hl$HHt$PH0_L
)  3ID@;
t+I-rAw
   D   AFHADH(w  Hu	H;  HH(H(W  Hu	H  HH(@SH 3  Hu	H  H  L  HtLP;AH [H\$Hl$Ht$WH 3HH2  HHu(9  v   D  D;  AG;uHl$8Ht$@HH\$0H _HHXHhHpHx ATH 3HHAE3HHi  HHu*93  v"  D  D;  AAGA;uHl$8Ht$@H|$HHH\$0H A\HHXHhHpHx ATH 3HHAHH2  HHu/Ht*9  v"  D  D;  AAGA;uHl$8Ht$@H|$HHH\$0H A\H\$Hl$Ht$WATAUH 3IHALLHI2  HHu/Ht*9   v"  D  D;  AAGA;uHl$HHt$PHH\$@H A]A\_Ht7SH LH
L  3  uSH  H [H\$Ht$ATH03Nj  ^\$ ; }iLcH\ J< tPJAt&3  tt$$|1H/ JH0  H
 JAL
 K$ \$      H\$@Ht$HH0A\H\$Ht$WH A3H$<u?A  t69+y~-HSDV:  ;uCyCK HKc Ht$8HH\$0H _@SH HHu5   ,jtcsH;  3H [Ht$H|$Ld$AUAVAWH0DE33N  3|$ A;=    LcH J< tjJBt`H JAt5Au9A;t%ADd$$EuAtA;ADt$(Hl J|$ n   @  AADHt$PH|$XLd$`H0A_A^A]   H\$Ht$H|$ATH L%   33I{u%Hc  HH  HH"  t-H  HH;|   H\$0Ht$8H|$@H A\HcHI$ 3H\$Hl$Ht$WH Hu  H-  HH7HttH$  H|H' HH;|HHt{u  HH;|H\$0Hl$8Ht$@H _HcH  HHH%l  H\$Ht$H|$AUH Hc   H=_   u  N     ZHHL-  I|  t{(   HHu.    3Z
   f   I|  u/  H   uH    3I\ 	HbH
    H\$0Ht$8H|$@H A]H\$WH HcH=  HH< uuHHH\$0H _H%8  H\$WH0IHHt23HBHH;s$HHd$  E3E333    ]3]H   HHD3HwH
  PL~  Hu-=   tH  uHt   Ht   H\$@H0_H\$Hl$Ht$WH0HHH   H   3HMt!A t   H;   HY:HIMtAA9 t;HH;   HH: uIL8  8/t8\tHH;sm\HHL$`HtHH;sSHH9 uHL$hHt1t+<.t"HH;s(.HHH;sHH9 uHGH;vE  "    3#   Hd$  E3E333H\$@Hl$HHt$PH0_H\$Ht$WH@HHL$ AA<HD$(DA|utHD$ H@  BY#3t   |$8 tHL$0   H\$PHt$XH@_HA   HE3nA   E33ZH8Hd$  6  H8HL$H   H
    L  L\$XE3HT$`HL$XKs  HD$PH|$P tAHD$8    HD$HHD$0HD$@HD$(H  HD$ LL$PLD$XHT$`3r  "H$   HX  H$   HH  H>  H  H$   H    	      H%  HD$hH!  HD$p       "(  3  H
    =   u
   '    	 H  H   H\$Hl$Ht$WH HYH  HL3E3H}AKAD]D]D]fH=  H+HHuH     9HHuH\$0Hl$8Ht$@H _H\$Ht$WH  H  H3H$p  HIHT$P     =  3HT$pH;rD$VD$p H|$V)WDD;wA+IJLpDB HuFd$8 LD$pD$0FDD$(H$p     3HD$ ?  d$@ FVD$8H$p  \$0HD$(LL$pD3\$ ;  d$@ FVD$8H$p  \$0HD$(LL$pA   3\$ ;  L$p  HN3At	p  At	 p         HHIHu?3HNDBA@ w	B Aw	 B       H;rH$p  H3L$  I[Is I_H\$WH 
  H   
  tH    t	H   n
   H   H\$0H;_  tDHtuH  HL$0H;tH5  H   H'  HD$0 H\$0
   HuK HH\$8H _@SH@HL$ 3%)   u%       |$8 tSHL$0   Eu     b  uHD$      @|$8 tHD$0   H@[H\$UVWATAUH@H  H3HD$8HI3;u
H  L-1  HIA   98'  AIH0r           ;   HT$   ;   HN3A  ]~^D9d$    HD$&8\$&t-8Xt(8H;w+HT7A
II+uH8uHF   II+uN  t(t
tA;t        FDf^H~   f   9B     HN3A  Hlm L  HA   MDIA8t18Yt,A;wLL2AAAAM;vH8uIMM+u~  Dft$t
tA;u        ^HVI|   HfHI+uH|3HL$8H3H$   H@A]A\_^]HHXHpHxL` AUH0A  HH   D;C     \H3H;|  H   HA   Y:  ;HAD;$  H   uH   L%  I;tL%  H      	       
   C^  CY  CT  T$ L}HcDKfAH= T$ T$   }HcDB * T$ |$    }Hc  B0+ |$ Hk   uH
^  I;tHM  
   +u&L%  I;tHW    3DAH\$@Ht$HH|$PLd$XH0A]H(=a   uK     3H(H\$Ht$WH H(  HHtyH
  H;tmH  Hta8 u\H   Ht9 u;H(  =  H  Ht9 uH(  M=  H  H(  H0  HtG8 uBH8  H   HH     H+HP  H+H0  HX  Ht  H;t`   u:  HX  uH{X   H  H9GtHHt
9 uMH tHOHt
9 u3H HuHH\$0Ht$8H _H  Ht H   Ht H  Ht H0  Ht HAXA   H  H9PtHHtHx t
HPHtH IuHX  `  H   AD	H  HtDH   HtDH  HtDH0  HtDHAXA   Hf  H9PtHHtD
Hx t
HPHtD
H IuHX  D`  H@SH HHtAHt<LL;t/HHMtI%A: uH  L;tH3H [@SH   H   
  tH    t  H   +   H   H  VH   HuK HH [H%  3H%  H%
  H(
  t
  
  H(H\$WH HHH  H   A         t  C  CH  H   
   +H    
      H   HuH  H   H      H\$0H _H\$WH   
    HHuHH  AHHt3
  H  Ht3  HK3  HH\$0H _@SH qHHuHqHH [H+  H\$WH HHI8Ht<HKHHt.HKXHt HKhHtHKpHtHKxHtH   HtH   H  H;t
   H   HL$0HtuH  HL$0H;t
   N   DH   Ht+HH;=$  tH  H;t? u	H   H6H\$8H _@SH t`H
_    tH     YHHt1
  H  t3H  HK   3H [Hl$Ht$WH`HcHL$@ID_A   wHD$@H@  y   HT$@@     t@$   @$   $    DJ@$   $    DHL$@T$8L$   AD$0AHL$@D$(HD$pHD$ a0  u8D$XtHD$P   3D$p#|$X tHL$P   L\$`IkIs I_HHXHhHp HWH HHKHcu 	   K 4  @t
 "   3t{   HCHKC{C  u/wH0H;tiH`H;u  ;uHE;  C     +HS+kHBHC$;C~D2!  W K?t#tHHH  HHkXHH
l  A t3DB9  HHKD$0   HT$0D   ;D$0H\$8Hl$@Ht$HH _H\$H|$Ll$ AVH0L5  3I;tHr     s<  |     `<  u
=  a       H=l  A  L_  HI5  tHd$  E3E333HM  A  3B   w  u1L  H
&    5  tHd$  E3E333H
    HH<vFH
    H  L  HL8A   H+t4  tHd$  E3E333/Lh  IH3  tHd$  E3E333LcIHMOD3  tHd$  E3E333H  A  H8  E  HHt2Ht,HcHIL%  ITHd$  LL$HLHY  H\$@H|$PLl$XH0A^H(   :  t   s:  u=  u      H(@SH    JHH~H'  H  HuCH# 3H [H\$Ht$H|$ATAUAVH LH
  >LH
  /HI;   HI+LoI   I9  HI;sT   H;HBHH;rI3H;u3HV H;rFIH;t9HHHHG  IHHKH$  I3HH\$@Ht$HH|$PH A^A]A\H(HH(H\$WH H  H=  HHtHH;rH\$0H _H\$WH Ho  H=h  HHtHH;rH\$0H _H\$WH H  
   HHHHuH\$0H _HMZ  f9t3HcH<H39PE  u  f9QLcA<E3LLA@EXJL EtQL;r
AL;rAH(E;r3HH(LL
Ijt"M+IIHt@$3H(H(?H   Ht 8  H(H(H
H  H(  H\$Hl$Ht$WH HbE3HI;  H   Lc	  H9:tIHHHH;rIHHH;s9:tII;C  LBM;6  Iu
LZA@%  Iu  H   H   J   Lcu  
s  AMD;}*IH   AIM\
G  E  D;|:     u      v:  u      b:  u      N:  u      ::  u      &:  u      :  u
            A   LZAH   3H\$0Hl$8Ht$@H _H
  H
  H
  H
  H
  H\$Ht$WATAUAVAWH@3|$p3	              tMt,t_    H!t$ E3E333  L%  H
      |$p   L%  H
     |$p   L%  H
     |$puHHuk  H   HLcK  9YtHIHHH;rIHHH;s9Yt3LaM,$L%P  H
I     |$pOLIu3   Mu
AMyt3tttL|$8Dt$p1L   L|$8H    uD         Dt$pu9
i  L$0a  ;}*HcHH   Hd T$0
8  I$t36   ;u
   AA;t
tuL   ;uD   3L\$@I[8Is@IA_A^A]A\_H
9  H
A  H
A  H8f  DD$ =  u   #  E3D\$ AH8H
	  @SH HH
  HtHt   3H [H(H8csmu+xu%@ = t=!t="t= @u3H(H(H
  3H(H\$Hl$Ht$WH0=   uZH  3Hu   <=tH  H\uG   Hc;HH5  HtHi  ; teH  ;=ptCHc   H HHtrLHH+  tHd$  E3E333HHcH; uH  HGH%   H'      3H\$@Hl$HHt$PH0_H
  H%v   HHXHhHpHx ATAUAVH Ll$`MIAe  LHA   HtLI3;"u3@"H9AE HtH3H)tAE HtHH@tu@ t@	uHt	G H3;    ; t;	uH;    MtI<$IA   3H;\t;"u6utHC8"uH33Ht\HAE utOu< tG<	tCt7LHttHHAE HtHAE AE HYHt HAE MtI$$ AH\$@Hl$HHt$PH|$XH A^A]A\H\$Ht$ WH0=   u_H=\  A  3HN   ,  H  H=v  Ht; uHHD$HLL$@E33HHD$ Hct$@HH;s\HcL$HHsQHH;rHHHHt8LHD$HLL$@HHHD$ gD\$@H=  A3D  H\$PHt$XH0_HHXHhHpHx ATH@
q  E3IAt$A;u2  HI;tI     !  
;  xD
/     I;u[  HI;u3  HfD9#tHfD9'uHfD9'uLd$8Ld$0H+HL3DO3Dd$(Ld$   HcA;tAH^HI;t1Ld$8Ld$0DOL33l$(HD$   A;uH%IH  Hs;t	A;L  HI;:D8 tHD8 uHD8 u+HcHHI;uH8   LHH  H  HH\$PHl$XHt$`H|$hH@A\L$H(E3   3  H  Ht#LD$0A   3HD$0        H(H\$WH H  Hd$0 H2-+  H;tHH  vHL$0  H\$0  DI34  DI3  HL$8DI3w  L\$8L3H  L#H3-+  L;LDLj  ILh  H\$@H _ff     H  M3M3Hd$ LD$(N  H  fD  HL$HT$DD$I ff     H8u
v 	   Rx.;
d  s&HcHp  HHHkXHD@"7Hd$  E3E333 	   L3H8@SH@HL$ HD$ DH@  BY%   |$8 tHL$0   H@[@SH@HL$ 3HD$ DH@  BY%   |$8 tHL$0   H@[ff     HHH   tfHt_uI~I HMHLHI3I#tHPtQtGHt9t/Ht!tt
uHDHDHDHDHDHDHDHDH
  3HH9
  H\$fDL$ UVWH`3IHHH;uL;vH;t)3   H;t	Iv$]   E3E333Hl$ roH$   HL$@$L\$@A9k   $      f;vLH;tH;v
L3Hl *    @8l$XtHL$P   H$   H`_^]H;tCH;w<"   E3E333Hl$ @8l$XHHL$P   7H;t   @8l$XHD$P   H$   $   AKHD$8Hl$0L$   A   3|$(Ht$ ,  ;t9$   H;td~  zH;tH;v
L3HL"   E3E333Hl$ @8l$XgHD$P   VH8Hd$  H8%y   H\$Ht$WH HHw|   HHEH
9  Hu       /H
  L3}  HHu,9  tHt
        H    3H\$0Ht$8H _H\$Ht$WH HHHu
H&jHu\HwCH
o     HHDL3L}  HHuo9W  tPHt+HvH>    3H\$0Ht$8H _!H|  Ho|  HH\$Ht$WH03HHHt13HGHI;s#H!|$ E3E333    3=IHt%  HHHHHtH;sH+H3LHH\$@Ht$HH0_H\$WH0HHu#:H!\$ E3E333    PFAt:H*  H(  yHK(Ht
iHc( c H\$@H0_H\$HL$WH0H3Hu$    Hd$  E3E333&A@ta ~HHH\$HH0_H\$ UVWATAUAVAW0  j  H+H  H3H$   33ELHcl$@Eu3  Hu.!8H!|$ E3E333    	  LLH  IAJLt$PMkXAt8@@@t@u	AtAD t
3DB    H|  JAD  S3HT$XH   HR  9YJIz    t	@  kz  !|$LID$XEw  Dt$X
   @  HT$PE3
H-  HT AA|P t ADLL$]A   D$\AdP HT$\It4IH+IH  HL$DA   H5*  v  HA   HHL$D*  U  Hd$8 Hd$0 L$XHD$\LD$DA   3D$(   HHD$ #y    HD$PHd$  H
  HLL$LHT$\IDx  B  A+|$@9l$L   
   E   HD$PHd$  @l$\H
  LL$LDEHHT$\I`x     |$L|{D$@e@t@uE3f
fD$DAH@t@u6L$Dh&  f;D$D   Etfl$DI&  f;D$DuxD$@A+A;\$LLt$Pl$@  z  e   	   Lt$PJL ADLJD ADP   \$Lv  \$LH  JAD  3I@   E  S
Dt$@H$   3A+A;s&E H<
uAHHHHH  rH!\$ H$   DD+H  Dt$@Lt$PLL$HH$   JIv  t5|$HH$   H+HcD$HH;
   A+A;Nu  @   E"  
   Dt$@H$   3A+A;s1E Hf
ufAHHHfHH  rH!\$ H$   DD+H!  Dt$@Lt$PLL$HH$   JIu  J|$HH$   H+HcD$HH;
   A+A;?EN  A
   HL$p3A+A;s.E Hf
ufDHHHfHH  rHd$8 Hd$0 HD$p+LD$pD$(U
    +3DH$   HD$ -u  D3HD$PHd$  HcH   EH
   HLL$HD+It  tt$HD;-t  D;A
   A+A;IH!|$ LL$HEIgt  t|$H3s  ~Hh  JAD@tA<$.4    I  H+H$   H3H$  H0  A_A^A]A\_^]H\$Ht$L$WATAUAVAWH0ELHcu38 	      3;   ;     HLIL=  HkXKL0u+8c 	   H|$ E3E333ym%  KD0tEI 	   08d&  )8 	   H|$ E3E333
H\$hHt$pH0A_A^A]A\_H\$L$VWATH0Hcu 	         ;=     HHHL%  HkXILu%Q 	   Hd$  E3E333fz$  IDt+K$  H~r  u
tq  3t 	   >%  # 	   Hd$  E3E333H\$`H0A\_^H\$WHPHHHu$Hd$  E3E333    3vHtH;sHL$0IPL\$8A{ u|$H HCtHHL$@   :HSHH;wBDuHH+H+|$H tHL$@   HCH\$`HP_E3<H\$Hl$Ht$WATAUHPE3IIHHM;uI;uI;u 3>I;tI;vM;uD)M;u?D)   E3E333Ll$ L\$PI[ Ik(Is0IA]A\_H$   HL$08L\$8HHE9ku LLX  D8l$HtHL$@   HuHHA:t.Hu&HHA:tHtHuI;uD)HI;  D8.tHuYLaIL;rHT$0A;tHH;sA+t*E,$*   D8l$HtHL$@   Hu\HvOHt+HH;rHT$0MA;tHH;s+t D.D8l$HtHD$@   P   Dl+D+"   E3E333Ll$ 
D8l$HaHL$@   PHH+H|YHqHH;rHT$0A;tHH;s+t+D.|*   D8l$HHD$@   D8l$HHD$@   @UATAUAVAWH`Hl$@H]PHuXH}`Hn  H3HED     3MLMDE DUHDnD;uOLax  E   3|$(H|$ Ln  ;tED-  m  D  xDDD  L]DMpD;~5AIA+@88t
I;uA+A+A;}
DHDMpDEpD;\  D;S  E;  D   D;uHD`   MA|$(H|$ Am  LcD;<  HA  A   ~[3HBIHrLKL?I;w.HAH;wHHZ\  H+H|$@H    HHtD0HH  DMpLE   AD|$(H|$ l  3;K  U L$(HL$ MELl  E3HcA;!  DU A
s;   A;  ;   MD$(HExELAHD$ ol     A;~`3HBHHrQHL6I;w*HAH;wHHW[  H+H\$@I;t  E3HI;tD0HDU II;tnMELAt$(H\$ k  3;t?   3HL$8DLHL$0;uL$(HL$ 
D$(HExHD$ A/k  HKD91uHOD91u  HLD;uHDpDu   uHxAh   Du3  L}xLE;<  3LMp\$(H\$    HH;tDMpU LA\$(H\$ j  LcDMD;u  D;A  ~bIIwYHH   w4HYH;w
HHHY  H+H\$@Ht%  HHtD0HDMHu3Mc3HKD]DMpU MD\$(LH\$ *j  Eu3.   LMLD$(AL|$   }L3L;DHKD91u(!   DMpU D$(AL|$ i  3H;tHL;t
M;tIHMH3H]PHuXH}`He A_A^A]A\]H\$Ht$WHpHHL$PIA$   D$   HL$PD\$@D$8$   D$0H$   LHD$($   DD$ O|$h tHL$`   L\$pI[IsI_DL$ UATAUAVAWH@Hl$0H]@HuHH}PH  H3HED
,     3MDLwD;u=LM Hr  Dh  ;t=  6\g  D
  xDDD
  D;&  D;  D;C  uh;uIE p]xDMXM\$(H\$ h  LcD;  A  ~hHL;wYKL$H   w5HAH;w
HHV  H+H|$0H;     HH;tD(HHH;   M3HMlDMXM   Dd$(H|$ Vg  ;tLM`DHAWg  HOD9)u7   DepHD;uIE D`uh;uIE pA"  u3U;t$LMXM\$(H\$ P  HH;tLHE`DMXMAAHD$ f  H;tHHMH3H]@HuHH}PHeA_A^A]A\]H\$Ht$WH`HHL$@AI$   D$   HL$@D\$8D$0$   D$(H$   DLHD$ .|$X tHL$P   H\$pHt$xH`_ff     LH+  Irat6t
IHtf
IfHt

IHMIuQMItH
HHIuIMuI@ 
HIuIfffffff     fffffI    sBH
LT
H HALQHD
LT
IHALQuIqfff     fH   r    
D
@H   uH   @   L
LT
L	LQLL
LT
LILQLL
 LT
(H@LILQLL
LT
LILQuI   I   q$ ffff     fffffffIIrat6tH
ItHf
Ift
H
IMIuPMItHH
IHuIMuI H
IuIfffffff     fffffI    sBHD
LT
H HALQHD
L
IHALuIsffff     fH w    H   
D
@uH   @   LL
LT
LILQLL
LT
LILQLL
LT
H@LILQLL
L
LILuI   I   q$ H  SH HHIHKHKHK wHK(nHK0eH]HK@THKHKHKPBHKX9HK`0HKh'HK8HKpHKxH    H   H   H   H   H   H   H   H   H   H   H   |H   pH   dH   XH   LH   @H  4H  (H  H   H(  H0  H8  H@  HH  HP  H [HtBSH HH	H;
	  tHKH;
  tHKH;
  t~H [H   SH HHIH;
  tUHK H;
  tCHK(H;
  t1HK0H;
  tHK8H;
  t
HK@H;
  tHKHH;
  tH [@SH0LHt
HtMu,D8   Hd$  E3E333LH0[9 t	HHuHuAA IHtHuHuA"   3@SH0MMuHuHu 3?HtHtMuD	Mu,D   Hd$  E3E333H0[LLIuAIAIt,Iu$AIAItItIuMuE
MfIuDDA@P "   m@SH0Ht
HtMu,D   Hd$  E3E333H0[LA IAItHuHu"   3ff     H+LtB	:uVHtWH   uI J	ffwHJ	H;uI~LHHI3ItHH3ffft't#HttHtttu3HHff     H+Ir"tf:
u,HIuMIuMt:
uHIuH3It7HH;
u[HAH;D
uLHAH;D
u=HAH;D
u.H IuIMItHH;
uHIuIHHHHHHH;H\$WH HcAHT$8
  Hu 	   HWT$8LD$<DH@\  D$8uZ  t	HHH  HHHkXdHD$8H\$0H _H\$Ht$L$WATAUAVAWH0ELHcu:38 	   H   3;   ;     HLIL=  HkXKL0u,8 	   H|$ E3E333HqK
  KD0tEIHp 	   8H
  H*n8G 	   H|$ E3E333]HH\$hHt$pH0A_A^A]A\_@SH   H   HCHt
KC$   KHC C$   HCHCc HH [H\$Hl$VWATAUAVH@ALL(3HH9     H
m  iY  HH  Hm  HEX  Hs  HHm  HHC  X  HHNm  HH,  W  HHm  HH  W  HwLH
  Ht!Hl  HW  HPH  H  H  L  H;tcL;t^H2H
  H#LHt?Ht:Ht-H$   A   LD$0HL$ AQHAtD$8u>H
I  H;t2Ht(HHtH
1  H;tHtHHH
  HtDMIH3H\$pHl$xH@A^A]A\_^H8x ~
u  1  
  #Hd$  E3E333    H8H8Hu&jHd$  E3E333    HLH
'  3W  H8   H  n  t

   Ht
   G  t_H$   GV  HL$03A   EH$  3HD$@HD$0D$0  @HD$ H$   HD$(U  HL$ U     hHHXHhHpHx ATAUAVHPLHHHEMFMtMu Mu*;Hd$  E3E333    P|$H   EtA|A$A.LD$03I^A  ~LD$0@   LD$0I@  @Ht@+H$   @-u@+u@+HES  AI  A$?  Eu(@0tA
   8;xt
;XtA   &A   Au@0u;xt;Xu@kHM@  3AD@EJAt	@0A  t,E@<w A;sA;r"u;vMuH@uMIE3YA@+H@u@u:t   wu';v# "   @t
@$MtI] @t|$H tHL$@   MtMu @8|$HtHD$@   3L\$PI[ Ik(Is0I{8IA^A]A\H83ELD$ H9  u	H
2  3QH8H\$WH Hc  HtYH     u	@   u
;u@`t     H  H;t  HT  u
R  3  LHHAHS  HMkXBD tb3H\$0H _H\$Ht$ L$WATAUH0Hcu38 	      3;   ;     HLIL-  HkXKD L0u+8 	   H|$ E3E333a  KD D0tI 	     )P8) 	   H|$ E3E333?H\$`Ht$hH0A]A\_@SH AHt"AtHIbc3HHCCH [HhH
  H3HD$P=   fL$@tfH
  Hu  H
  H   Hd$  LL$DHT$@A   0R     =     P  xu}%   Q  Hd$8 Hd$0 HD$HLD$@A   3D$(   HD$ Q  H
)  Ht0Hd$  LL$DHT$HDQ  tfD$@!       HL$PH3HhH\$Hl$Ht$WHP3IHHH;tL;t
@8*uH;tf)3H\$`Hl$hHt$pHP_HL$0IJL\$0A9ku%H;tf@8l$HtHD$@      HT$0;   HL$0D  A~0A;|+IH;L	   D$(H\$ TP  HL$0;uHc  H;r(@8ot"  @8l$H4HL$@   # *   @8l$HtHD$@   A   H;AQLD$(HD$0H\$ HO  ;E3H\$Hl$Ht$WH Hxi;
  saHcH-  HHHkXHD H<u==J  u'ttuO  HD H3 	     H\$0Hl$8Ht$@H _H\$Hl$WH xs;
_  skHcH-k  HHHkXHD DtGH<t@=  u)ttu3N  HD H3 	     H\$0Hl$8H _H8u   	   ]x1;
  s)HcH
  HHHkXHDtH,  lHd$  E3E333 	   HH8HHXHpHxL` AUH HcLIL-6  HkXKt    |3 u3O	J|3 uHL3  o#D3
   tKL HLK  H\$0Ht$8H|$@Ld$HH A]HcH
  HHHkXHHLH%HK  H\$H|$Ld$AUAVAWH@IEE3AL$uA     3|$$H?  @  LcJH   H\$0JH   H;   C   { u;
   ({ u HK  OuDpDt$(C
   Eu HKdJ  CtHK\J  HIEu?CL#L  K+H..HLIIH?LDDl$ HXH\$0IHF   E;   |$$H+  X   JHD$0HttHcL  I   IH   H;s@ L @	
` HXHD$0|$ HcHHHkXIDHADD|$    AH\$`H|$hLd$pH@A_A^A]H8H|  H3HD$(LD$ A     D$& J  u
HL$   HL$(H3{H8@USVWATAUAVAWH   Hl$@H@|  H3HE0L   E!3IH} LMDDH];  HU4I  ;   }   HUAI  ;   }uzE    At`A   HcHH;   HL	H   wlHAH;w
HH8  H+H\$@Ht<  NHxEL   A|$(H|$ hI  o37  VHHt   H3HtLc3HMtLEE   A|$(H\$ 	I  E3A;   M;t;   L|$8L|$0D$(DL3ALt$ fH  A;   I   D9} u,L|$8L|$0DL3AD|$(L|$ *H  A;tWHc   HI;tBL|$8L|$0DL3A|$(HD$ G  A;u
HMIAtHMHK9  u+HHM0H3lyHeHA_A^A]A\_^[]3DB
yLMt<E
IAAwA 
HAw It
EtD;tD+A3HHXHhHpWHPIHHM   HHIxHu=Hd$  E3E333    |$H tHD$@      HtHwHD$0x u#LHH|$H tZHL$@   LM HT$0  HT$0H  HHtt;t+|$H tHL$@   3H\$`Hl$hHt$pHP_H8=E   uAHu'Hd$  E3E333    HtIwXE3H8HHHd$0 d$( A   H
PZ  E3   @DD$ mF  H  HHH(H
  HtHtF  H
  HtHtF  H(H\$Ht$WH =V   H  HtmHuH9  t_+  uVH  HtJHtEHHHHt2zH;vH<9=uLH  tHHHD83H\$0Ht$8H _H\$Ht$H|$ATH0IHH   3Hu&f   Hd$  E3E333z   H' HtH# 3Hu#'   Hd$  E3E333;zHHHu3fH   L$InHHu    1LIHtHd$  E3E333HtL#3   H\$@Ht$HH|$PH0A\Hl$WHpHcHL$PMu   sbHT$P  ~LD$P   HT$PH@  xtHH  8   |$h tHD$`      HD$P  ~6HT$P@t@$   @$   $            *   @$   $    HL$PD$@   L$   AA   D$8H$   D$0   HD$(T$ QHL$PC2$   t
$   |$h tHL$`   H$   Hp_HHXHhHpWH`HHHHIIIsHu8\$XtHD$P   3   Hu:Hd$  E3E333    |$X tHD$P   pHtHwHL$Hy uLLHH  1AQHL$@D$8\$0LA  H|$(\$ 	  t|$X tHL$P   L\$`I[IkIs I_E3H\$Hl$WH@Hd$P H  HH   Hd$8 Hd$0 d$( Hd$  DL33@  Hc   H   nHD$PHtzHd$8 Hd$0 LD33|$(HD$ c@  tGHL$P3  yHL$PHtHd$P HHHY3H\$XHl$`H@_HL$P~@USVWATAUAVAWHhHl$0H+r  H3HE(H   DU   A   3MDELH}Ec;uOLJ  E33Dd$(LD$ m@  ;t
AE\$>  W  A   xADDU @  D   D;~YAIA+8t	I;u+DD   D   D;~5AHA+8t	I;u+DD   D;}3  D;|A;  ;  A;uD   D;uIDiD;t	D;   E;uA\  E;~AO  E;~
   @  HUA=  ;tD   D;~2}r8]HEt8XtA:r:HvH8     9   ~+}r8]HEt8Xz:r:HvH8M	   A\$(H\$ W>  LcD;I~d3HBIHrUKL6H   w.HAH;wIH5-  H+Ht$0H;  HH;t   HHH;pD   MAADt$(Ht$ =  ;   D   L	   A\$(H\$ =  LcD;   ~g3HBIHrXKL$H   w1HAH;w
HHg,  H+H|$0H;t  )HH;t   HHH;tVD   LE   ADd$(H|$ <  ;tUM ELDd$(H|$ 6=  HO9  uHN9  u   HLD;uIDPDU D   D;uID`AD; A;teL   MA\$(H\$ HH;LEL   AA\$(H\$ LH;u
H
LLLE   D   UM D$(LD$ M4<  H;tHIHM(H3lHe8A_A^A]A\_^[]H\$Ht$WH`HHL$@IAlD$   $   HL$@D\$8D$0H$   HD$($   LDD$ |$X tHL$P   H\$pHt$xH`_H\$Ht$WH`HHHL$@II[lHu8\$XtHD$P   3   Hu=;Hd$  E3E333    P|$X tHD$P      HtHwHD$@PuLL$@LHH>@HL$@LD$8\$0A  H|$(\$ u    y|$X tHL$P   H\$pHt$xH`_H\$T$UVWATAUAVAWH0E3LAI;u$CE3E333Ll$     Y   L!M;   =   I  HHD$pI;   L;   D8hH5|  EAH;5|  upHAI;uIUHL9.u   HcHHI;u	   'mH  HHHHE I;uL/H|$pl$xH5^|  I;   A;t9L9-Y|  t0fA;tj@    H$   H0A_A^A]A\_^]E;t3   H{  I;tL(L9-{  u   rH{  I;tL(H5{  HI;tHHA+LcHt?HMIuHA| =   A8\    HHHuH5r{  H+HE3A;   L9m    HcHL E;tfL9l tHLHHHD HL9l uHcHH;   H
 {  A   I;t|sH5z  H+HrLd M.]E;   A;}G;LcHL;n   HI;XHcL$LlM.Htz  D9l$x   I   HHOHI;tlIMHHPHA;tE3E333Ll$ +HHI+HT$pD*HE;IE6  A;u *   HoE;tIbM.IPM.H\$Ht$WH0HHtF<HHHHHt-HVLHtHd$  E3E333pH3H\$@Ht$HH0_H\$Ht$WHPHHL$0I'g3H;uD#E3E333Ht$     9@8t$HtHD$@   3H\$`Ht$hHP_HT$89ruH   @8t$HtHL$@   f;t3DtH@83t;u
HC;tH;l@8t$HtHD$@   HfE3 :t
Hu:uH3%03  %3  %3  H8Hu&Hd$  E3E333    +H9 tHtHHt8 tE3  H8HT$L$SUVWATAUAVAWHXAHcADd$4\$8A;u38 	     3;  ;t    HLL
AIKC HkXD1  vU8.      ;    H;tD|18A   EAAtutLdtA;ABMLH;u        =  $   3DBL
!ALKC L\0@KC IA
   D0H   L0	A:   ;   AM KC AAIUAhDD0	D:tbKC L09A:tQ;tM
KC AHAhDD09Au.KC L0:A:t;t
KC HAhADD0:KC LL$0DH1H|$ 2  ;  HcT$0;  H;  L@KC D0y  A  ;tA} 
uL0d0HcIMIHD$@L;:  
   A$<
  @:t
HI   HD$@HL;sID$8
u	I   L   KC LL$0H$   H1A   IH|$ 1  ;u
0  ;u{9|$0tuL0?KC D0Ht"$   
t'@+KC $   D1	GI;u$   
u
3$   A   H]$   
L>tL>@+HL;d$@KC D0@uL0	A$HA+A  ;  A   I+uI   AI;rI+AB8 4 tB4 ;u} *   A  ;uHcH^KC D0Ht;IL0	|KC ID19uKC ID1:HcH+$   EHc2D$8L$   A+DMD$(3  L|$ e/  ;uI.  }A  Dd$4;HS=JC @|0H  ;
   tfA9U uL0d0HcIMN<(M;{  
   A$fE  f;tfHI%  IGL;sID$f9u	I   L   KC LL$0H$   H1A   IH|$ .  ;u]-  ;   9|$0   Ll<KC D0HtF
   f9$   tKf+$   KC D1	$   KC D19KC T0:WI;u
   f9$   uf>$   HDBo
   L;f9$   t
   L;f+HM;"KC D0@uL0A$fHA+Dd$4L$   M;tI`}ADDAi5,  uz 	   z    muDz3)z8z 	   E3E333H|$ yHXA_A^A]A\_^][H\$Ht$L$WATAUAVAWH0ALHcuBz3z 	     3;   ;=}     LLIL=}  AMkXKBL u.yy 	   H\$ E3E333x   A;u+yy    H\$ E3E333xnKBD tDIs:y 	   Oy):yy 	   H\$ E3E333)xH\$hHt$pH0A_A^A]A\_HHXL@HHUVWATAUAVAWH   3AAH@   ox@$   HxEtxAl$pDHL$T  ;tE3E333H|$ ivr @ u
|$T   tE
A      A#   ;tT+t:;t1@x8x   E3E333H|$ +w  D@t   uA   @D$   A   t,t#tt@uD;AA   L$H#tF=   t8=   t*=   t=   t*=   t&=   t;t/A   
   AA   Dl$Psm  "$   AEDDDl$P@@tAADl$PL$Hs
ADl$P@ tA@t
ADl$PIu!v8v    v   H$   DD$HH$   H|$0LL$`ADl$(    l$ B)  HD$XH      A#;uC   @t9DD$HH$   H|$0ALL$`Dl$(Al$ (  HD$XHu;HcL-z  HHHkXID dJ'  vu8  H&  ;uMHcL-y  HHHkXID d'  uHL$X6(  ;uuu 
   A;uA@	uAHT$X%HcL-[y  H   HD
ID HkXDtHcHHHkXID d8A$HD$L   E  AtxE	  D$Dut8   tPHT$@A   @|$@;u|$@uHcT$D  tE33E	  t   E<   @ uD$T#u#= @  tJ=   t,= @ t%=   t+= @ t$=   t= @ u($     #;uD$   @$        |$DA@  A%   =   @$  =   t|=     ;  A;vv8l  $   A   A+   A;P  D$D    E3H;tE33nH|HT$DA   baA;t uk|$D uD@D$      D$D=  u%r     =  u#E3A  D$      E33p  ;;vqA;E3H;E33Hu8D$D A   HcEHTDD+NmD;A   Hc@$   H@HHkXID d8@l8HcHHHkXIL d8D8@8|$Lu!@tHcHHHkXID L A%   =      A   HL$X>$  D$PDD$HH$   H|$0D$(ALL$`D$    A1$  Hu6"  ~qLcIAHMkXID BdBHcHHHkXIL H
H$   H   A_A^A]A\_^]HPL@LH VWHXH` E3HAEu(p    Hd$  E3E333o   H$   HD@d$0 DD$(D$ @   DLHT$@HL$DvD$H|$D t9t(Hc|$@HHHLCt  HkXId|$@n|$@to0HX_^@SH0MHHHu&oHd$  E3E333    nHUHtHL$ LL$XLD$@IH  tLL$XLD$@H     HL$@HqHL$XqHH0[H\$LD$UVWATAUAVAWH0E3MLHHI;u("oE3E333Lt$     8nH  D81tI;tHI;tD80t\   v  /   HHf  A   I;   I;   AW9HRHI;   H.IHXH{oHI;sLL5  HHuA;tE3E333Lt$ XlLHHA;tE3E333Lt$ 1lH~
I;tH;vHHHS/
  HI;t&3  A;   MIHH   lIL`InHI;   LIHA;tE3E333Lt$ kH"L4mM+D8I<L%0c  HD$pM$HIhtHd$  E3E333Kk3HQ  tHb  IL;HD$p}mL$   IHD8HHoH;tHsoHH\$xH0A_A^A]A\_^]HHXHhHpHx ATAUAWH H33DGLHtPDG3Ht=HH+H;     A   WHM  HH;u1Nl    Cl H\$@Hl$HHt$PH|$XH A_A]A\   v  DDI;HEMtHH+H;~	l8uk 
   HA+    LH3/  U}]E3HHTH  HHHHu%vk 
   kH  HE3IiH3H\$Ht$WH HcANHuk 	   RDE3H  uV  3t	kHHHn  HHHkXdH\$0Ht$8H _H\$LcHn  MAIMkXJBD8F\A   DA @  tX   tH   t(   t    uHBLJBd 8BL 80BLJBd 8BL 8BdBLJBd8Eu   A%    @  H\$H8Hu'iHd$  E3E333    h   
m  3H8LL$ HT$SUWATAUAVAWH   3GDgDD;tt~A;~;uAM@bi8;iE3E333    H|$ Qh@  IA88uA8xtA  IA88uh   HL$p3LfF\$pl  Ll  ;t/SHcHHHkXI@8|u;u;  q       fLf$   riH$   H;  ;H$   LcHHIT~WLDL^l  MIAHMkXMABu
IH@9H
IHHIuH$   LcD:t2A;HHITDLD;~A@9H
HHHuA   gH$(  E38HD$PE3HD$HHD$pIHD$@H$8  H|$8HD$0Dt$(D$    $    H$   Di;u
Agru3&Q;u+HL$P  HL$PH$     Hc$   	   ;u
HL$P  H|$PHL$X  Hf    HH   A_A^A]A\_][@SUVWATAUAVAWH   HK  H3HD$xHz-  E3HHT$hEfMHf-  LL$XfBY-  MB
HHL$`ADt$0Lt$8Dt$4HAHH|HI;u   HD$HgII;u"Mu f     f      LD$hHL$83AA;t   E3E333Lt$ ctHL$hKHL$8A<H|$PI;t3H|$PI;Z  HE HHHEdHI;uH[  I;u+HH[  I;uIgM7Mu    E=D82t(H:tHK[  ElIcHA:uEIc/@8qt0y:u*8Yu%AFHcHpH	[  EtIcH8tAHA+DDd$@H9u t'HL$h9HHT$hL  tRHH93uDA   heHL$XHHuKIfE3M7Td    id    	  D$4   Dd$0Mu Dl$0Dt$0Dd$@H|$`ILMuH8HT$HHtH!t$ E3E333aHmHHHHHtVHt$HILHH+HtHd$  E3E333aH HHcH HHHut$0L|$XC  I?H  E+IcHH|Y  IcLE3HL9u tKALE HHH+I!A;tE3E333Lt$ aHM HHHL9u uD9t$4   Hc\$PLD$hHHA;tE3E333Lt$ `L:  HH?A;tE3E333Lt$ `HL$8I;t'LHHA;tE3E333Lt$ U`HE3I;tI;?uD7HD7H
cX  I;tdHL$8L5MX  I;tdHL$xH3EH   A_A^A]A\_^][@SH0Hu-a  aHd$     E3E333`Pu  u  aa 'u!tta    ha 
   3H0[H\$Ht$WHPHHL$0I3-EHu6+aH!|$ E3E333    A`@8|$HtHD$@   3LD$8A9xuHQ  @8|$HtcHL$@   UHBDt%Ht;uH{HuH;HDHu8L$HtHL$@   HH\$`Ht$hHP_E3H\$Hl$Ht$WHP3IHHL;u3  HL$0I DL\$8A9kuLHHE  H;u< `E3E333Hl$     _@8l$HtHD$@     H;tHHBDtA@8+ufKfHffA;KrfA;KwfAK)fA;Kr"fA;KwfAKBDt	B  HBDtA@8/ufKfHffA;SrfA;SwfAS)fA;Sr"fA;SwfASBDt	B  f;u*f;t	H;$@8l$HHD$@   @8l$HtHL$@   H\$`Hl$hHt$pHP_E34LE3HA:uHI;t8u8LDIff     HL$L\$M3LT$L+MBeL%   M;sfA M A M;uL$L\$H@UH0HHM`:H0]@UH H    t
    dH ]@UH HHHH ]@UH H   cH ]@UH HHcM HHc  Hm:H ]@UH H   cH ]@UH HH
8D  
  H ]@UH H
   mcH ]@UH H   TcH ]@UH H
   ;cH ]@UH H   cH ]@UH HCH ]@UH HH38  H ]@UH0H}p t3bH0]@UH HHE38  AAH ]@UH0HHM@8H0]@UH0HMPH0]@UH0HM`iH0]@UH H
   <bH ]@UH H
   #bH ]@UH H   bH ]@UH0H   aH0]@UH@H}D t7}H t'HcU@HHHL_  HkXIdU@H@]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  0     H     `     t     |                                                  *     >     Z     x                                                       *     :     J     X     f     p                                              2     H     b     x                                             $     4     J     Z     l     ~                                                  "     4     \     h     x                                          h @   <S @   T_ @   g @                    @   L @                           failed to get exit code from process.
  failed to create process.
   %s %s      Could not exec %s       Cannot find Python executable %s
       #!python.exe    #!      Cannot open %s
 -script.py      CorExitProcess  m s c o r e e . d l l   ( n u l l )     (null)                 EEE50 P    ( 8PX 700WP        `h````  xpxxxx              8@   8@   	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ =       runtime error   
      TLOSS error
   SING error
    DOMAIN error
  R6034
An application has made an attempt to load the C runtime library incorrectly.
Please contact the application's support team for more information.
      R6033
- Attempt to use MSIL code from this assembly during native code initialization
This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain.
  R6032
- not enough space for locale information
      R6031
- Attempt to initialize the CRT more than once.
This indicates a bug in your application.
      R6030
- CRT not initialized
  R6028
- unable to initialize heap
    R6027
- not enough space for lowio initialization
    R6026
- not enough space for stdio initialization
    R6025
- pure virtual function call
   R6024
- not enough space for _onexit/atexit table
    R6019
- unable to open console device
        R6018
- unexpected heap error
        R6017
- unexpected multithread lock error
    R6016
- not enough space for thread data
             
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
   R6009
- not enough space for environment
     R6008
- not enough space for arguments
       R6002
- floating point support not loaded
    Microsoft Visual C++ Runtime Library    

  ... <program name unknown>  Runtime Error!

Program:                                                                                                                                            EEE  00P  ('8PW  700PP    (   `h`hhhxppwpp                                                                                                                                                                                                                                                                                             ( ( ( ( (                                     H                                                                                                                                                                                                                                                                                                                                                                                     h ( ( ( (                                     H                                                                                                             H                                               	

 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~HH:mm:ss        dddd, MMMM dd, yyyy     MM/dd/yy    PM  AM      December        November        October September   August  July    June    April   March       February        January Dec Nov Oct Sep Aug Jul Jun May Apr Mar Feb Jan Saturday    Friday      Thursday        Wednesday       Tuesday Monday  Sunday  Sat Fri Thu Wed Tue Mon Sun     GetProcessWindowStation GetUserObjectInformationA       GetLastActivePopup      GetActiveWindow MessageBoxA     USER32.DLL      SunMonTueWedThuFriSat   JanFebMarAprMayJunJulAugSepOctNovDec    CONOUT$ .com    .exe    .bat    .cmd    .\      SystemRoot                                       t d
 T	 4 2 
4 
 p    P  
 
4 
 p  
 d
 T	 4 2p!       < !       ( !   H  I     ( ! H I dJ     ( ! TR     <   K p0  0   bp`0  +     |  I  `      
 4 R
p`P r0 0 20 4 2p
 d 4 rp+     '  (  x      	
 
4	 
Rp+     *  S+    S+   B     d  T  4  rp t 4 2	 	20 d T 4 2p) 4d Z 
p`P      	 
    t  d  4     +     `:  l:     =  	 	 0  
 t	 d T 4 2
 
20 d	 4 R+     KB  B        
  t d
 R+     D  MD        C  jD         t d 4 2 d T 4 2p t d 4 2+     OF  F        
 
4 
Rp d
 T	 4 Rp d 4
 rp  $ d 4  p    p  
 
4 
2p+     M  N  4       4 r
p`P  8   
  t
 d	 4 R+     -R  R  4       20+     V  V  M      
 
4 
2p+     W  W  f      W  W         4 2p+     .Y  \Y  f      qY  Y         d T p d	 T 4 2p  t
 4 R
 t
 d	 4 2+     _  {`         2P	 B  +     a  b    b  	 B  +     9b  =b     =b  
 d 4 r
p+     e  sf        	 b  +     f  g    g   t d
 T	 4 2 d 4
 Rp
 t
 d T 4
 r B  
 
4 
2p       b   4 p
`P d	 4 Rp 4	 Rp+     u  v        / 4qf
p`P       
 d 4
 Rp+     ,~  ]~  N       4 R
p
`+     ?    7      
 
4 
p
 d T 4 p-
Et d 4 C
P    X    d 4 p1
5#t d 4 3r
P    8    d 4 p 2
0 R0
 d 4
 Rp+       	  N      
 T 4 rp`   t d T 4 
 
4 
2p d
 4 Rp+       (  7           P       T 4 2p
 	 t d 4 2+     k    e      
  t
 4 r+         ~      4           b    (   'EC 
	p`0P    p       RP t
 d	 4 R+               
 
T 
p d T 4 p T 4 rp$
53
	p`0P  X   
 4 Rp`
P	 
p`P
0  
 d 4
 Rp+       >  N      !
 !4 !p`P rP p`  +                t d
 T	 4 2 d 4 2p 4 	  
pP0  #
  
	p`P0  x    d
 4 p d T
 4 p         N                                                          0     H     `     t     |                                                  *     >     Z     x                                                       *     :     J     X     f     p                                              2     H     b     x                                             $     4     J     Z     l     ~                                                  "     4     \     h     x                  SGenerateConsoleCtrlEvent  GetExitCodeProcess  rWaitForSingleObject  CreateProcessA  SetConsoleCtrlHandler GetModuleFileNameA   EnterCriticalSection  LeaveCriticalSection  GetModuleHandleW  /Sleep "GetProcAddress  ExitProcess qGetCommandLineA RtlUnwindEx SetHandleCount  >GetStdHandle  GetFileType <GetStartupInfoA  DeleteCriticalSection ;TerminateProcess  GetCurrentProcess LUnhandledExceptionFilter  #SetUnhandledExceptionFilter IsDebuggerPresent RtlVirtualUnwind  RtlLookupFunctionEntry  RtlCaptureContext GetLastError  HeapFree  HeapAlloc ]GetCPInfo TGetACP  GetOEMCP  IsValidCodePage  EncodePointer  DecodePointer @FlsGetValue AFlsSetValue ?FlsFree SetLastError  GetCurrentThreadId  >FlsAlloc  WriteFile LoadLibraryA  InitializeCriticalSectionAndSpinCount LFreeEnvironmentStringsA GetEnvironmentStrings MFreeEnvironmentStringsW WideCharToMultiByte GetEnvironmentStringsW  HeapSetInformation  HeapCreate  SQueryPerformanceCounter jGetTickCount  GetCurrentProcessId SGetSystemTimeAsFileTime HeapReAlloc GetConsoleCP  GetConsoleMode  CFlushFileBuffers  LCMapStringA  MultiByteToWideChar LCMapStringW  @GetStringTypeA  CGetStringTypeW  GetLocaleInfoA  SetFilePointer  HeapSize  D CloseHandle WriteConsoleA GetConsoleOutputCP  WriteConsoleW 
SetStdHandle  z CreateFileA S CompareStringA  V CompareStringW  SetEnvironmentVariableA KERNEL32.dll  hReadFile  SetEndOfFile  &GetProcessHeap  GetFileAttributesA                                                                                                  E@           E@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2-+  ] fL) @            @    @   
                                                                                                                 
      	               	      
                  
               
               !   
   5      A   
   C      P      R   
   S   
   W      Y      l   
   m       p      r   	            
      
      	            
      )      
                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                                                                                                                                                                                                                                                                                                                                               abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                      (@         `y!                       @~                                    @                                      A         [                       @~    Q  Q^  _j2                   1~     @       C                                                                                                                      @-@                           @-@                           @-@                           @-@                           @-@                                                         P2@                    @   @    @   0@   P-@          P-@    (@                      X @          ( @   	        @   
       ` @          ( @           @           @           @          h @          @ @           @           @           @           @            @            @   !        @   "       P @   x       @ @   y       0 @   z         @           @           @   8 @   8 @   8 @   8 @   8 @   8 @   8 @   8 @   8 @   8 @            
                   @    @   P@   L@   H@   D@   @@   <@   8@   0@   (@    @   @    @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   |@   t@   h@   `@   P@   @@   8@   4@   (@   @    @   	             0@   .               @2@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   P2@      .                        p         PST                                                             PDT                                                             2@    3@                              ;   Z   x                 0  N  m         :   Y   w                 /  M  l                                                                                                                                                                                                              8@   0@   (@    @                                                                                                                                                                                                                       x   Y   `    x                    <     (   e   e                 ]  T h  J   L  s   t            Z   \          D              P   "  | "  &#   `#  	$   $  $   $  %%   %  %&   (&  a&   d&  z&   &  &   &  '  ( '  '  ( '  >)   x)  )   )  w+   x+  +   +  --   0-  .  0 .  9.  @ <.  .   .  .  H .  V/  `	 X/  =:  \ @:  -=   0=  f=  P p=  >   >  ?  	 h?  ?   ?  ?   ?  ?   ?  \@  `	 \@  @   @  eA   hA  A   A  -B   0B  B   B  YC  x \C  C   C  D  	 D  .E  L	 0E  E  `	 E  F  t	 F  F  ( F  G  	 G  H  	  I  {I  	 I  I  P I  K  	 K  K  `	 K  M  	 M  <N  	 <N  N   N  CQ  
 DQ  <S  4
 <S  dS   dS  T  x  V  wV   xV  V  d
 W  1W   4W  W  
 W  lX  ( lX  X   X  Y  
 Y  IZ   LZ  U[  
 X[  \  
 \  
_   _  S_   T_  _   _  `  $ `  `   `  `  ( `  (a  ( (a  ^a  ( a  !b  \ $b  Gb  | Hb  db   hb  6d  `	 dd  f   f  %g   0g  bg   dg  g   g  g   g  h  	 h  j   j  k   k  jm   lm  m  0 m  kn  8 n  n  H n  So  P To  o   o  o   p  r  X r  r  P r  s  x s  wt  x xt  u  h u  u  	 u  v  x v  v}   x}  ~   ~       z  
   +  $
 ,  i  <
 l    d
   n  t
 p    
 D  .  
 0  x   x  
  
     
   q  
 t    
     (    W  
 X         
     P   6  P D       j   l    P   X  ( X  p  4 p         `   -   @    `	     x      P              _   `     <  M   P    P     ,   #   $    x     <   l  h l  {  t   v   x  R   T    
     
          h      D    P                  y  8 |    
     |   0  \ 0    x          P               
             ^  p `  x  4 x    T     T     T     T     T   4  T 4  M  T M  f  T f    T     T     T     T     4     T   7  4 7  N  4 N  e  4 e  ~  T ~    T     T     4     0     
MZ                @                                       	!L!This program cannot be run in DOS mode.

$       #^g?g?g?@d?g?:?p\c?ymNC?ym_m?ymI	?ym[f?Richg?        PE  d Q         # 	     l      +        @                      p                                                      (            ` 
                                                                                               .text                             `.rdata  )      *                 @  @.data   5                      @  .pdata  
   `                  @  @                                                                                                                                                                                                                                                                                                                                                                                                H\$Hl$Ht$H|$ ATAUAVH LH3I   HD	HyHcP  33Lc "HXL~e    A,\u'"u ~D\Hj  H+\H3A,HHI;C|~D\H5  HHl$HHt$PH|$X"C H\$@IH A^A]A\H\$WH`  H H3H$P  HH	HtH/u@\uH$@  L$@  LD$@HT$0HHD$ O  |$0    |$@\   H$@  L$@  LD$@HT$0HHD$   H3H|$@HD$@HHHH9\uH9\tHD$@H;r H9\uLD$@HT$0H$@  LHD$     
       
  H$@       s
  HA  HH  HH$P  H3  H$  H`  _H\$Hl$Ht$H|$ ATAUAVH HH3LHPHH	  3HA} LE3He  tD  KHP  u+H@t[@8  tEtI@\u@"u@u3E@2DtL\H	  H3@t@.HtL\H	  H3 AE IcE HI4@t&  tKH  u; GH\$@Hl$HHt$PH|$XIH A^A]A\H(u
! t36     H(H\$WH   33HHL$pDGh3$   HD$PHD$XHD$`  WH
D$ph     L\$PHD$pL\$HHD$@H|$8H|$0E3E3H3|$(D$      u(  H  HH`r  3H$   H   _D$`HL$P  _  HL$PH$   D  u(  H,  HH`  3H$   H   _$   H$   H   _H\$Hl$Ht$WATAUH LH3   IIcH;HHLLQ}J<H3IHDL;|IcH  H  MHL  H3IH;HLi}0LIcH  I  H<H3HHDH;|H\$@Hl$HHt$PIH A]A\_@SWAVAWHX  H
 H3H$0  LDD$ LcHT$0A   3  H3H|$0HHD/HL$0H;v 8.tHT$0  HH;w  3HH|$03H:  HL$0HG3  G  u"  LD$0H  HH`B  C  H$0  A   H$    HcH0  K  H$0  HHH;st<
t<
u H$0  H  A   $  t%HY  H$0  HP  AJ  AHT$$H$2  HT$0H8HHvHHu   H  LHH`^  E
  H$P  t$$L$H  L$@  E,7   AEHc  HL"I$I|$~ HHHHHHGuHL$0   HI;HG}!     IHHI;HG||$  H$P  H    t*IH    H  HH`Lv      EIHyHAL$H  L$@  H$  H$0  H3
  HX  A_A^_[Hi 
_ A   HHPHHL@LH SVWATH8H3H;;u'&      H\$ E3E333%    H;;u']&      H\$ E3E333s%     Ld$p  G@   H#  t*t%HcHHL) HkXIH
%
 H

 HL) B8u%ttHcHHHkXIA8t"%      H\$ E3E333$  ;u*HM  ME3HT$hH`  H   H  H8A\_^[H @SH \;    u   ;LHc   9; &  H
+ Hu$PH; %  H* Hu   x3H HH0HHt	H* E3H EHILh( IHIHkXLItItMuIH0Iu3H [H()  =$  t'  H
F* H(&  @SH HH
l H;r:H H;w.HH*H+HHHH?L<+  k
HK0S  H [@SH H}+  k
HJ0%  H [H(H H;r7He H;w+qH+H*HHHH?L)  
H0  H(H(}r)  
HJ0  H(@SH d$@ LD$@*  HHu9D$@t #  Ht"  L$@HH [ff     HIrSIII@rHtL+HHMI?Iu9MIItfffHHIuMt
HIu@ fffffI   s0HHQHQH@HQHQIHQHQHQufD  HHQHQH@HQHQIHQHQHQu$ Tff     LMt$H+t(   HItuIHHHIr&I~LLIM3I MtI      HItx$tuHItiHtbHItV$tSHItGHt@HIt4$t1HIt%tHIt$tHI<IHH3IrEt
HII rHHQHQHQH I sI Ir	HHIIrHI@SH EHLAA LtA@McPLHcL#IcJHCHHKAtAHLL3IH [  H(MA8HI   H(H8HD$`HD$(LL$ MLH(  H8H\$LD$UVWATAUAVAWH0L$   L$   HL3MT$pH;t
L;uL;t     L;tL;uH9$   u
H9$   tL;uH9$   u
H9$   tL;uH9$   u
H9$   t   H8tHHH;w;:u,L;t!I;  A   LHI)  3H{L;tAHHH8te(  3;tH</t
<\t	<.u	HHkH8uH;t/L;t%LL+L9$      LHI(  3HL;tAH;tQH;rLL;t!LL+L9$   vqLHI[(  3L;tPH+H9$   vNLLHI5(  /L;t!H+H9$   v(LLHI(  3L;tA$3   L$pL$   L;tL;vAL;t
H9$   vAL;tH9$   vAU L;tH9$   vA$H;u%^  Hd$     E3E333r  ;u5  "   H\$xH0A_A^A]A\_^]H\$Ht$WHPIHA   HH$   HHIMM#HHML\$@HL$8M#HHHLT$0LL$(I#HLMHT$ HAHH\$`Ht$hHP_ff     H;
i  uHfuH&  @SH HA H   55  HCH   HH   HKH
 H;t   |	 u	3  HHc H9CtHC   
U	 u	)  HCHC   u   CoHH [@SH@=w  HcuH[
 XVHL$ 3&HD$   ~LD$    76  DH@  DXA|$8 tHD$0   AH@[HT$LD$LL$ SH`Hu%  Hd$  E3E333      UHtHL$@HL$0L$   HL$0E3D$8D$HB   
  l$8x
HL$0 HT$036  H`[ff     MtuH+LI tB	H:uWItNtJH   uJ	ffwHJ	H;uHII~vHLI3ItH3HHt't#HttHtttuH3@SH O9   7  H
  01     H [H@SH H
    HtHo  H  HtH [@SH      r      f  H;s-H\$WH HHHHtHH;rH\$0H _H\$WH 3HHH;suHHtHH;rH\$0H _H\$WH H=  tH
 
;  tn 5:  Hz  H
K  ~uZH
9  9  H  H=   HHtHH;rH=#  tH
 :  tE33AP 3H\$0H _H\$Ht$DD$WATAUAVAWH@ED     =
    
    D%
    H
 3/  HHD$0H   H
[ /  HHD$ LHt$(LHD$8HH|$ H;r.  H9uH;r\H.  H.  HH
 .  HH
 .  L;uL;t LH\$(HH\$0LHD$8HHD$ H  H
  H	  H
  Et
     Eu&~    AL$  AA#  H\$pHt$xH@A_A^A]A\_E33jE3AP\33DBO   3D=@SH -  HH=  H=  H  H=  Hz=  H:  H8  H8  H
b-  H  H [H\$Ht$WH   HL$0[  MZ  f9ubHcH5H8PE  t3$   N  f9Ht3$   8   w3$   $39   $   3$   H5r   C  u!9= u4     2     X/  u!9=
 u4     ]2     6    y
   X  Hy A  H
 |@  y
   i=  y
	   t<  @|$lT$pA
   DEL3HgD$ u$    u   L$   I[Is I_H(B  H(HHXHhHp HPWATAUAVAWH@MyM!Iq8M+AfMHL   3HHL@9>+  H^CL;   CL;   {    ;tHL$0HI   ~sA} csmu(H=  tH
 5  t   I KA   HIB  IF@SMcM HD$(IF(IMHHD$   B  H;>sj>3fIy 3I+9.vTH^KL;r>CL;s6H;rH;sAE u/; t	H;t#HT$xIIDCMAH;.r   L\$@I[0Ik@IsHIA_A^A]A\_H\$H|$ATH H  !B     H0H;u3H`H;uw   n C  ucL% HcI< u+   J  IHuHC HCH   C$CIC$   C   HKHK     3H\$0H|$8H A\t0SH bHsH  cc$ H# Hc H [@SH B@ItHz uA &Bx
HH,  u	H [~LH\$Hl$Ht$WH II@LH@?tH\$0Hl$8Ht$@H _H\$Hl$Ht$WH A@@IIHtIx uA7~3M LHH?u=  8*uLH?H\$0Hl$8Ht$@H _H\$UVWATAUAVAWH  H  H3H$  3HHL$hHHL$xIMD$`DD$TDD$HD$XD$PdE3I;uA  3E3E333    H\$   8$   tH$        AC@L
   H
  Hw  A;t(t#LcL
sIAHMkXMC 
LL
PA@8u)A;ttHcHHHkXIC B8tA  3E3E333    H\$ 
  8$   tH$      A1  E3I;t@/ADT$@DT$DAL$   A:  H$   A   HA;H$     E<XwHB  AHcHcHB
  T$\A;y    /          <  @d~    A@  C   E.  G%  StmX  Zta  c   H  IE II;t/HXI;t&A sD$P   +  DT$P  HM    A0  uAI] E;ADIA    I;D$P   HD  H   A0  uAIA  t,EMH$   HL$DM@  E3A;tD$X   AED$D   $   H$   M  D$p   @ A@E;H$   A-  A   k  e  g~i   n   o   ptesu   x  '   SfD9t	HA;uH+H!I;HD  H
D8tHA;u+L$D  A   A   D$`A   Ey`QD$L0AQD$MSA   EyDA	=I} I,=  E3A;xA tf77D$X   l  A@A
   T$HArAs
ME I.IA tA@tMEEEA@tMcEEEA@t
M;}IAAr
ArEE;}A   AE;EOD|$`IH$  H#L$HAAA;M;t 3IIcHLB09~AHH$  A+HA	D$D  A;t	;0  HD$D0   u@guAA   9E;EOA   ~)A]  Hcy
  H$   HtHA   IE H
  I@HcH$   P!  HL$xDHL$0L$pLL$(H$   HDt$ A3   tD;uH
M  !  HT$xH3@gu;uH
#     HT$xH;-uAHHO:  E3D$DD9T$XK  A@t1AsD$L-AtD$L+   |$HAtD$L |$Ht$THl$h+t$D+AuLL$@L LL$@HL$LLAtAuLL$@L0|$D39D$Ptu;~qHDM H$  H$   A   HB<  E3A;u2$   A;t&LD$hLL$@H$  E3A;uHl$h#Hl$hAD$@LL$@LHdE3D$@A;|AtLL$@L E3H$   I;tHA
  E3L$   H$   t$@T$\L
A   @/A:$D8$   tH$      H$  H3H$   H  A_A^A]A\_^]@It:@ht+@lt
@wuA?lu
HAAwA nA<6u4uHAO<3u2uHA7<d/<i'<o<u<x<XDT$\HT$x@DT$P6  3;t!HT$hLD$@@<@/H@:  HT$hLD$@@E3@*uEu IE;EC@DtH}Eu@*uAE IA;D$TZAD$T@DHD$T:@ tA@#t1@+t"@-t@0AAAAADT$pDT$XDT$TDT$HEEDT$PR  E3E333Ht$     h  @8$   wHHXHpHxL` AUAVAWH   HL$   X   DbI  LE3I;u{  H A
t H   L;sCE{IAC	
E{E{8AC9
AC:
E{PE{LIXHO H   L;r
& fD9|$bI  HD$hI;;  LhHc0I   9L   ;   L5 X   I  LI;tiI A I   L;sAE{IAC	
E{Ac8AC9
AC:
E{PE{LIXIH   L;ro H;|` L5o AA;~~H>tkH>teAE t^AE uHL  A;tILcIHAMkXM$HI$AE AD$IL$  *  A;tAD$   IH;|EIHHkXH H;tH;tKCAD$E;D  HHtJI;tEH  A;t7H3uK@	uKHK  .*  A;tC.K@HAHHQ
    3L$   I[ Is(I{0Mc8IA_A^A]H8Hu%*  Hd$  E3E333    ?  AH8H
  @SH  d$p HL$t3A   L\$pH$  H$  L\$HHD$P  H$  HT$@HE3  Ht;Hd$8 HT$@HL$`HL$0HL$XLHL$(H$  LHL$ 3   H$  H$  H$  H$  H$  D$p D$t   H$     3  HL$H  uuH4     H  H  [H\$Hl$Ht$WH0HH
  AIH@  HtLT$`DLHHLT$ %   4  L\$`DLHHL\$ hH\$@Hl$HHt$PH0_L
  3ID@;
t+I-rAw
   D   AFHADH(w  Hu	H  HH(H(W  Hu	H  HH(@SH 3  Hu	H  H  L  HtLP;AH [H\$Hl$Ht$WH 3HHd3  HHu(9Z  v   D  D;B  AG;uHl$8Ht$@HH\$0H _HHXHhHpHx ATH 3HHAE3HHi  HHu*9  v"M  D  D;  AAGA;uHl$8Ht$@H|$HHH\$0H A\HHXHhHpHx ATH 3HHAHH 3  HHu/Ht*9Y  v"  D  D;A  AAGA;uHl$8Ht$@H|$HHH\$0H A\H\$Hl$Ht$WATAUH 3IHALLHIg3  HHu/Ht*9  v":  D  D;  AAGA;uHl$HHt$PHH\$@H A]A\_Ht7SH LH
  3  uSHf  H [H\$Ht$ATH03Nj  ^\$ ;4 }iLcH J< tPJAt3  tt$$|1H JH0  H
 JAL K$ \$      H\$@Ht$HH0A\H\$Ht$WH A3H$<u?A  t69+y~-HSD:  ;uCyCK HKc Ht$8HH\$0H _@SH HHu5   ,jtcsH;  3H [Ht$H|$Ld$AUAVAWH0DE33N  3|$ A;=    LcH~ J< tjJBt`H^ JAt5Au9A;t%ADd$$EuAtA;ADt$(H J|$ n   @  AADHt$PH|$XLd$`H0A_A^A]   H\$Ht$H|$ATH L%  33I{u%Hc  HH  HH"  t-H  HH;|   H\$0Ht$8H|$@H A\HcHI$ 3H\$Hl$Ht$WH H!  H-Z  HH7HttH  H|H' HH;|HHt{u  HH;|H\$0Hl$8Ht$@H _HcH  HHH%  H\$Ht$H|$AUH Hc   H=   u  N     HHL-U  I|  t{(   HHu.    3Z
   f   I|  u/  H   uH    3I\ 	HbH
v  H  H\$0Ht$8H|$@H A]H\$WH HcH=  HH< uuHHH\$0H _H%  H\$WH0IHHt23HBHH;s$HHd$  E3E333    ]3]H   HHD3HwH
  PL*  Hu-=   tH  uHt   Ht   H\$@H0_H\$Hl$Ht$WH0HHH   H   3HMt!A t   H;   HY:HIMtAA9 t;HH;   HH: uI8  8/t8\tHH;sm\HHL$`HtHH;sSHH9 uHL$hHt1t+<.t"HH;s(.HHH;sHH9 uHGH;vE  "    3#   Hd$  E3E333H\$@Hl$HHt$PH0_H\$Ht$WH@HHL$ AAHD$(DA|utHD$ H@  BY#3t   |$8 tHL$0   H\$PHt$XH@_HA   HE3nA   E33ZH8Hd$  Y7  H8HL$H   H
    Lx  L\$XE3HT$`HL$Xs  HD$PH|$P tAHD$8    HD$HHD$0HD$@HD$(H8  HD$ LL$PLD$XHT$`3s  "H$   H  H$   HH  H  H[  H$   H\  2  	 ,     H  HD$hH  HD$p       (  3  H
K  }  =v   u
   (  \  	 HF  H   H\$Hl$Ht$WH HYH  HL3gE3H}AKAD]D]D]fH=R  H+HHuH     9HHuH\$0Hl$8Ht$@H _H\$Ht$WH  H  H3H$p  HIHT$P     =  3HT$pH;rD$VD$p H|$V)WDD;wA+IJLpDB yHuFd$8 LD$pD$0FDD$(H$p     3HD$ ?  d$@ FVD$8H$p  \$0HD$(LL$pD3\$ d<  d$@ FVD$8H$p  \$0HD$(LL$pA   3\$ .<  L$p  HN3At	p  At	 p         HHIHu?3HNDBA@ w	B Aw	 B       H;rH$p  H3L$  I[Is I_H\$WH 
  H   
F  tH    t	H   n
   H   H\$0H;  tDHtuH  HL$0H;tH  H   H  HD$0 H\$0
   HuK HH\$8H _@SH@HL$ 3%   u%     @  |$8 tSHL$0   Eu       uHD$      @|$8 tHD$0   H@[H\$UVWATAUH@H  H3HD$8HI3;u
H  L-  HIA   98'  AIH0r         _  ;   HT$ 2  ;   HN3A  ~^D9d$    HD$&8\$&t-8Xt(8H;w+HT7A
II+uH8uHF   II+uN  t(t
tA;t        FDf^H~   f   9     HN3A  ?Hlm L{  HA   MDIA8t18Yt,A;wLL2AAAAM;vH8uIMM+u~  Dft$t
tA;u        ^HVI|   HfHI+uH|3HL$8H3H$   H@A]A\_^]HHXHpHxL` AUH0A  HH   D;C     \H3H;|  H   HA   :  ;HAD;$  H   uH   L%  I;tL%  H      	       
   C
  C  C   T$ LW}HcDKfAH= T$ T$   }HcDB * T$ |$    }Hc  B0+ |$ H   uH
  I;tH  
   +u&L%  I;tHW    3DAH\$@Ht$HH|$PLd$XH0A]H(=
   u     3H(H\$Ht$WH H(  HHtyH
s  H;tmH  Hta8 u\H   Ht9 u;H(  C>  H  Ht9 uH(  =  H  H(  H0  HtG8 uBH8  H   HH     H+HP  H+H0  HX  H   H;t`   ua;  HX  uH{X   Ha  H9GtHHt
9 uMH tHOHt
9 u3H HuHH\$0Ht$8H _H  Ht H   Ht H  Ht H0  Ht HAXA   H  H9PtHHtHx t
HPHtH IuHX  `  H   AD	H  HtDH   HtDH  HtDH0  HtDHAXA   H  H9PtHHtD
Hx t
HPHtD
H IuHX  D`  H@SH HHtAHt<LL;t/HHMtI%A: uH  L;tH3H [@SH   H   
R  tH    t  H   +   H   H  VH   HuK HH [H%  3H%  H%  H(
f  t
  
T  H(H\$WH HHHQ  H   A         t  C  CH4  H   
   +H    
      H   HuH  H   H      H\$0H _H\$WH   
~    HHuHH  AHHt3
S  H  Ht3  HK3  HH\$0H _@SH qHHuH-HH [H+  H\$WH HHI8Ht<HKHHt.HKXHt HKhHtHKpHtHKxHtH   HtH   H  H;t
   H   HL$0HtuH`  HL$0H;t
   N   DH   Ht+HH;=  tHg  H;t? u	H   H6H\$8H _@SH at`H
    tH     YHHt1
k  H  t3H  HK   3H [Hl$Ht$WH`HcHL$@ID_A   wHD$@H@  y   HT$@@>     t@$   @$   $    DJ@$   $    DHL$@T$8L$   AD$0AHL$@D$(HD$pHD$ 0  u8D$XtHD$P   3D$p#|$X tHL$P   L\$`IkIs I_HHXHhHp HWH HHKHcu 	   K 4  @t
 "   3t{   HCHKC{C  u/3H0H;t%H`H;ui  ;uH;  C     +HS+kHBHC$;C~D!  W K?t#tHHH  HHkXHH
  A t3DB:  HHKD$0   HT$0DC!  ;D$0H\$8Hl$@Ht$HH _H\$H|$Ll$ AVH0L5  3I;tHr     <  |     <  u
=9  a       H=  A  L  HI6  tHd$  E3E333H  A  3   #  u1L  H
    36  tHd$  E3E333H
    HH<vFH
    H  LK  HL8A   H+ 5  tHd$  E3E333/L  IHI4  tHd$  E3E333LcIHMOD4  tHd$  E3E333H  A  H9  Eo  HHt2Ht,HcHIL  ITHd$  LL$HLH  H\$@H|$PLl$XH0A^H(   ;  t   :  u=L  u      H(@SH    JHH~H  H  HuCH# 3H [H\$Ht$H|$ATAUAVH LH
  >LH
t  /HI;   HI+LoI   I:  HI;sT   H;HBHH;rI3H;u3HV H;rFIH;t9HHHH  IHHKH  I3HH\$@Ht$HH|$PH A^A]A\H(HH(H\$WH HC  H=<  HHtHH;rH\$0H _H\$WH H  H=  HHtHH;rH\$0H _H\$WH H  
   HHHHuH\$0H _HMZ  f9t3HcH<H39PE  u  f9QLcA<E3LLA@EXJL EtQL;r
AL;rAH(E;r3HH(LL
Ijt"M+IIHt@$3H(H(3H   Ht 8  H(H(H
H)  H(  H\$Hl$Ht$WH HVE3HI;  H   Lc  H9:tIHHHH;rIHHH;s9:tII;C  LBM;6  Iu
LZA@%  Iu  H   H   J   Lc  
  AMD;}*IH   AIM\
    D;|:     u      v:  u      b:  u      N:  u      ::  u      &:  u      :  u
            A   LZAH   3H\$0Hl$8Ht$@H _H
Q  H
R  H
S  H
T  H
A  H\$Ht$WATAUAVAWH@3|$p3	              tMt,t_    H!t$ E3E333  L%  H
     |$p   L%  H
     |$p   L%w  H
p     |$puHHuk  H   HLc  9YtHIHHH;rIHHH;s9Yt3LaM,$L%  H
     |$pCLIu3   Mu
AM)t3tttL|$8Dt$p1L   L|$8H    uD         Dt$pu9
	  L$0  ;}*HcHH   Hd T$0
  }I$t3*   ;u
   AA;t
tuL   ;uD   3L\$@I[8Is@IA_A^A]A\_H
  H
  H
  H8  DD$ =  u     E3D\$ AH8H
  @SH HH
  HtHt   3H [H(H8csmu+xu%@ = t=!t="t= @u3H(H(H
  3H(H\$WH 39=v  uWHH  H  HHD; w	; t3t);"u	3vtHH< w	HuHH\$0H _H\$Hl$Ht$WH0=   uH  3Hu   <=tH  H\uG   HcHHY  HtH  ; teH  ;=ptCHc   HxHHtrLHH+  tHd$  E3E333]HHcH; uH#  HH%   H'      3H\$@Hl$HHt$PH0_H
  H%   HHXHhHpHx ATAUAVH Ll$`MIAe  LHA   HtLI3;"u3@"H9AE HtH3HtAE HtHH@tu@ t@	uHt	G H3;    ; t;	uH;    MtI<$IA   3H;\t;"u6utHC8"uH33Ht\HAE utOu< tG<	tCt7HttHHAE HtHAE AE HYHt HAE MtI$$ AH\$@Hl$HHt$PH|$XH A^A]A\H\$Ht$ WH0=   uH=  A  3Hr   P  H  H=  Ht; uHHD$HLL$@E33HHD$ Hct$@HH;s\HcL$HHsQHH;rHHHHt8LHD$HLL$@HHHD$ gD\$@H=  A3D  H\$PHt$XH0_HHXHhHpHx ATH@
  E3IAt$A;u2  HI;tm     !  
_  xD
S     I;u  HI;u3  HfD9#tHfD9'uHfD9'uLd$8Ld$0H+HL3DO3Dd$(Ld$ "  HcA;tAHHI;t1Ld$8Ld$0DOL33l$(HD$   A;uHIH  Hs;t	A;L  HI;:D8 tHD8 uHD8 u+HcHIHI;uH\   LHH  H@  HH\$PHl$XHt$`H|$hH@A\L$H(E3   38  H  Ht#LD$0A   3HD$0        H(H\$WH H  Hd$0 H2-+  H;tHH  vHL$0  H\$0  DI3X  DI3  HL$8DI3  L\$8L3H  L#H3-+  L;LDL  IL  H\$@H _ff     H  M3M3Hd$ LD$(N  H  fD  HL$HT$DD$I ff     H8u
 	   Rx.;
  s&HcH  HHHkXHD@"Hd$  E3E333 	   3H8@SH@HL$ *HD$ DH@  BY%   |$8 tHL$0   H@[@SH@HL$ 3HD$ DH@  BY%   |$8 tHL$0   H@[ff     HHH   tfHt_uI~I HMHLHI3I#tHPtQtGHt9t/Ht!tt
uHDHDHDHDHDHDHDHDH
1  3HH9
  H\$fDL$ UVWH`3IHHH;uL;vH;t)3   H;t	Iv$   E3E333Hl$ oH$   HL$@TL\$@A9k   $      f;vLH;tH;v
L3Hc *   X @8l$XtHL$P   H$   H`_^]H;tCH;w<$"   E3E333Hl$ 9@8l$XHHL$P   7H;t   @8l$XHD$P   H$   $   AKHD$8Hl$0L$   A   3|$(Ht$ L~  ;t9$   H;t}  zH;tH;v
L3H|C"   E3E333Hl$ X@8l$XgHD$P   VH8Hd$  H8%   H\$Ht$WH HHw|   HHEH
Y  Hu c   1   _H
4  L3|  HHu,9+  tHQt
r    g    H+R    3H\$0Ht$8H _H\$Ht$WH HHHu
H&jHu\HwCH
     HHDL3L|  HHuo9w  tPHt+HvH    3H\$0Ht$8H _H{  =|H{  $HH\$Ht$WH03HHHt13HGHI;s#5H!|$ E3E333    K3=IHt%  HHHHHtH;sH+H3LHH\$@Ht$HH0_H\$WH0HHu#H!\$ E3E333    FAt:H*  H;(  yHK(Ht
Hc( c H\$@H0_H\$HL$WH0H3Hu$    Hd$  E3E333+&A@ta HH+H\$HH0_H\$ UVWATAUAVAW0  j  H+H  H3H$   33ELHcl$@Eu3  Hu.!8gH!|$ E3E333    }  LLH  IAJLt$PMkXAt8@@@t@u	AtAD t
3DB    H  JAD  3HT$XH   Hr  9YJIy    t	@  y  !|$LID$XEw  Dt$X
   @  HT$PE3
H-  HT AA|P t ADLL$]A   D$\AdP HT$\It4IH+IH  HL$DA   H5*  v  HA   HHL$D*  U  Hd$8 Hd$0 L$XHD$\LD$DA   3D$(   HHD$ Cx    HD$PHd$  H
'  HLL$LHT$\IDw  B  A+|$@9l$L   
   E   HD$PHd$  @l$\H
  LL$LDEHHT$\Iw     |$L|{D$@e@t@uE3f
fD$DAH@t@u6L$Dh&  f;D$D   Etfl$DI&  f;D$DuxD$@A+A;\$LLt$Pl$@  z  e  7 	   LLt$PJL ADLJD ADP   \$Lv  \$LH  JAD  3I@   E  S
Dt$@H$   3A+A;s&E H<
uAHHHHH  rH!\$ H$   DD+H(  Dt$@Lt$PLL$HH$   JIu  t5|$HH$   H+HcD$HH;
   A+A;Nu  @   E"  
   Dt$@H$   3A+A;s1E Hf
ufAHHHfHH  rH!\$ H$   DD+HA  Dt$@Lt$PLL$HH$   JIt  J|$HH$   H+HcD$HH;
   A+A;?EN  A
   HL$p3A+A;s.E Hf
ufDHHHfHH  rHd$8 Hd$0 HD$p+LD$pD$(U
    +3DH$   HD$ Mt  D3HD$PHd$  HcH   EH
   HLL$HD+Is  tt$HD;Ms  D;A
   A+A;IH!|$ LL$HEIs  t|$H3r  ~H  JAD@tA<$.      H+H$   H3H$  H0  A_A^A]A\_^]H\$Ht$L$WATAUAVAWH0ELHcuV38- 	      3;   ;     HLIL=  HkXKL0u+8 	   H|$ E3E333m%  KD0tEI 	   8d&  )8h 	   H|$ E3E333~H\$hHt$pH0A_A^A]A\_H\$L$VWATH0Hcu 	         ;=     HHHL%  HkXILu% 	   Hd$  E3E333z$  IDt+K$  Hq  u
p  3tb 	   >%  #I 	   Hd$  E3E333^H\$`H0A\_^H\$WHPHHHu$Hd$  E3E333    3vHtH;sHL$0IL\$8A{ u|$H HCtHHL$@   :HSHH;wBDuHH+H+|$H tHL$@   HCH\$`HP_E3<H\$Hl$Ht$WATAUHPE3IIHHM;uI;uI;u 3>I;tI;vM;uD)M;u?D)   E3E333Ll$ L\$PI[ Ik(Is0IA]A\_H$   HL$0hL\$8HHE9ku LLX  D8l$HtHL$@   HuHHA:t.Hu&HHA:tHtHuI;uD)HI;  D8.tHuYLaIL;rHT$0'A;tHH;sA+t*E,$*   D8l$HtHL$@   Hu\HvOHt+HH;rHT$0A;tHH;s+t D.D8l$HtHD$@   P   Dl+D+i"   E3E333Ll$ ~D8l$HaHL$@   PHH+H|YHqHH;rHT$0!A;tHH;s+t+D.*   D8l$HHD$@   D8l$HHD$@   @UATAUAVAWH`Hl$@H]PHuXH}`H  H3HED$     3MLMDE DUHDnD;uOLw  E   3|$(H|$ lm  ;tED-  >l  D  xDDD  L]DMpD;~5AIA+@88t
I;uA+A+A;}
DHDMpDEpD;\  D;S  E;  D   D;uHD`   MA|$(H|$ Al  LcD;<  HA  A   ~[3HBIHrLKL?I;w.HAH;wHHZ\  H+H|$@H    HHtD0HH  DMpLE   AD|$(H|$ k  3;K  U L$(HL$ MELk  E3HcA;!  DU A
s;   A;  ;   MD$(HExELAHD$ k     A;~`3HBHHrQHL6I;w*HAH;wHHW[  H+H\$@I;t  E3HI;tD0HDU II;tnMELAt$(H\$ k  3;t?   3HL$8DLHL$0;uL$(HL$ 
D$(HExHD$ AOj  HKD91uHOD91u  HLD;uHDpDu   uHxAh   Du3  L}xLE;<  3LMp\$(H\$    HH;tDMpU LA\$(H\$ j  LcDMD;u  D;A  ~bIIwYHH   w4HYH;w
HHHY  H+H\$@Ht%  HHtD0HDMHu3Mc3H{D]DMpU MD\$(LH\$ Ji  Eu3.   LMLD$(AL|$   }L3L;DHKD91u(g!   DMpU D$(AL|$ h  3H;tH5L;t
M;tI#HMH3!H]PHuXH}`He A_A^A]A\]H\$Ht$WHpHHL$PIA $   D$   HL$PD\$@D$8$   D$0H$   LHD$($   DD$ O|$h tHL$`   L\$pI[IsI_DL$ UATAUAVAWH@Hl$0H]@HuHH}PH  H3HED
L     3MDLwD;u=LM Hq  Dg  ;t=  6|f  D
  xDDD
  D;&  D;  D;C  uh;uIE p]xDMXM\$(H\$ ,g  LcD;  A  ~hHL;wYKL$H   w5HAH;w
HHV  H+H|$0H;     HH;tD(HHH;   M3HMDMXM   Dd$(H|$ vf  ;tLM`DHAwf  HOD9)u   DepHD;uIE D`uh;uIE pA"  u3U;t$LMXM\$(H\$ P  HH;tLHE`DMXMAAHD$ e  H;tHHMH3H]@HuHH}PHeA_A^A]A\]H\$Ht$WH`HHL$@AI$   D$   HL$@D\$8D$0$   D$(H$   DLHD$ .|$X tHL$P   H\$pHt$xH`_ff     LH+  Irat6t
IHtf
IfHt

IHMIuQMItH
HHIuIMuI@ 
HIuIfffffff     fffffI    sBH
LT
H HALQHD
LT
IHALQuIqfff     fH   r    
D
@H   uH   @   L
LT
L	LQLL
LT
LILQLL
 LT
(H@LILQLL
LT
LILQuI   I   q$ ffff     fffffffIIrat6tH
ItHf
Ift
H
IMIuPMItHH
IHuIMuI H
IuIfffffff     fffffI    sBHD
LT
H HALQHD
L
IHALuIsffff     fH w    H   
D
@uH   @   LL
LT
LILQLL
LT
LILQLL
LT
H@LILQLL
L
LILuI   I   q$ H  SH HHIHKHKHK HK(HK0HHK@HKHHKPHKXHK`HKhHK8HKpHKxH   tH   hH   \H   PH   DH   8H   ,H    H   H   H   H   H   H   H   H   H   H  H  H  H   H(  xH0  lH8  `H@  THH  HHP  <H [HtBSH HH	H;
)  tHKH;
  tHKH;
  tH [H   SH HHIH;
  tHK H;
  tHK(H;
  tHK0H;
  tHK8H;
  tHK@H;
  toHKHH;
  t]H [@SH0LHt
HtMu,D   Hd$  E3E333H0[9 t	HHuHuAA IHtHuHuAN"   3@SH0MMuHuHu 3?HtHtMuD	Mu,D   Hd$  E3E333H0[LLIuAIAIt,Iu$AIAItItIuMuE
MfIuDDA@P u"   m@SH0Ht
HtMu,DK   Hd$  E3E333_H0[LA IAItHuHu"   3ff     H+LtB	:uVHtWH   uI J	ffwHJ	H;uI~LHHI3ItHH3ffft't#HttHtttu3HHff     H+Ir"tf:
u,HIuMIuMt:
uHIuH3It7HH;
u[HAH;D
uLHAH;D
u=HAH;D
u.H IuIMItHH;
uHIuIHHHHHHH;H\$WH HcAHT$8
  Hu- 	   HWT$8LD$<DH`[  D$8uZ  t	2HHH  HHHkXdHD$8H\$0H _H\$Ht$L$WATAUAVAWH0ELHcu38 	   H   3;   ;     HLIL=  HkXKL0u,U8. 	   H|$ E3E333DHqK
  KD0tEIH 	   8H
  H*8 	   H|$ E3E333HH\$hHt$pH0A_A^A]A\_@SH    H   HCHt
KC$   KHC C$   HCHCc HH [H\$Hl$VWATAUAVH@ALL3HH9     H
l  X  HH  Hl  HeW  Hs  HHHl  HHc  =W  H)Hnl  HHL  W  H
H/l  HH5  V  HLH-  Ht!Hk  HV  HH  H  H  L  H;tcL;t^HH
  HLHt?Ht:Ht-H$   A   LD$0HL$ AQHAtD$8u>H
i  H;t2?Ht(HHtH
Q  H;tHtHHH
#  HtDMIH3H\$pHl$xH@A^A]A\_^H8x ~
u  1  
  #Hd$  E3E333    $H8H8Hu&Hd$  E3E333    HLH
G  3W  H8   H    t

   uHt
   rg  t_H$   gU  HL$03A   uH$  3HD$@HD$0D$0  @HD$ H$   HD$(U  HL$ T     HHXHhHpHx ATAUAVHPLHHHEMvMtMu Mu*Hd$  E3E333    |$H   EtA|A$A.LD$03I^A  ~LD$0@   2LD$0I@  @Ht@+H$   @-u@+u@+HES  AI  A$?  Eu(@0tA
   8;xt
;XtA   &A   Au@0u;xt;Xu@kHM@  3AD@EJAt	@0A  t,E@<w A;sA;r"u;vMuH@uMIE3YA@+H@u@u:t   wu';v# "   @t
@$MtI] @t|$H tHL$@   MtMu @8|$HtHD$@   3L\$PI[ Ik(Is0I{8IA^A]A\H83ELD$ H9;  u	H
R  3QH8H\$WH Hc  HtYH     u	@   u
;u@`t     H  H;t  H?S  u
Q  3  LHHAHs  HMkXBD t3H\$0H _H\$Ht$ L$WATAUH0Hcu38W 	      3;   ;     HLIL-  HkXKD L0u+'8  	   H|$ E3E333a  KD D0t 	     )8 	   H|$ E3E333H\$`Ht$hH0A]A\_@SH AHt"AtHIc3HHCCH [HhH-  H3HD$P="   fL$@tfH
  Hu  H
  H   Hd$  LL$DHT$@A   PQ     =     O  xu}%   Q  Hd$8 Hd$0 HD$HLD$@A   3D$(   HD$ 8P  H
I  Ht0Hd$  LL$DHT$HDP  tfD$@A       HL$PH3HhH\$Hl$Ht$WHP3IHHH;tL;t
@8*uH;tf)3H\$`Hl$hHt$pHP_HL$0IzL\$0A9ku%H;tf@8l$HtHD$@      HT$0;   HL$0D  A~0A;|+IH;L	   D$(H\$ tO  HL$0;uHc  H;r(@8ot"  @8l$H4HL$@   # *   @8l$HtHD$@   A   H;AQLD$(HD$0H\$ HN  ;E3H\$Hl$Ht$WH Hxi;
'  saHcH-3  HHHkXHD H<u==j  u'ttuN  HD H3 	   (  H\$0Hl$8Ht$@H _H\$Hl$WH xs;
  skHcH-  HHHkXHD DtGH<t@=  u)ttu3M  HD H3a 	   v  H\$0Hl$8H _H8uR  * 	   ]x1;
  s)HcH
  HHHkXHDtH,  Hd$  E3E333 	   HH8HHXHpHxL` AUH HcLIL-V  HkXKt    |3 u3O	|3 uHL3  #D3
   tKL HLJ  H\$0Ht$8H|$@Ld$HH A]HcH
  HHHkXHHLH%hJ  H\$H|$Ld$AUAVAWH@IEE3AL$#uA     3|$$H_  @  LcJH   H\$0JH   H;   C   { u;
   { u HK  uDpDt$(C
   kEu HKI  CtHK|I  HIEu?CL#L  K+H..HLIIH?LDDl$ HXH\$0IHf   E;   |$$HK  X   JiHD$0HttHcL%  I   IH   H;s@ L @	
` HXHD$0|$ HcHHHkXIDHADD|$    9AH\$`H|$hLd$pH@A_A^A]H8H{  H3HD$(LD$ A     D$& I  u
HL$   HL$(H3{H8@USVWATAUAVAWH   Hl$@H`{  H3HE0L   E!3IH} LMDDH];  HUTH  ;   }   HUA5H  ;   }uzE    At`A   HcHH;   HL	H   wlHAH;w
HH8  H+H\$@Ht<  NHxEL   A|$(H|$ H  o37  VHHt   H3HtLc3HMOsLEE   A|$(H\$ )H  E3A;   M;t;   L|$8L|$0D$(DL3ALt$ G  A;   I   D9} u,L|$8L|$0DL3AD|$(L|$ JG  A;tWHc   fHI;tBL|$8L|$0DL3A|$(HD$ 
G  A;u
HIAtHMHK9  uHHM0H3xHeHA_A^A]A\_^[]3DB
yLMt<E
IAAwA 
HAw It
EtD;tD+A3HHXHhHpWHPIHHM   HHI"xHu=dHd$  E3E333    y|$H tHD$@      HtHwHD$0x u#LHH|$H tZHL$@   LM HT$0  HT$0H  HHtt;t+|$H tHL$@   3H\$`Hl$hHt$pHP_H8=e   uAHu'uHd$  E3E333    HtIwXE3H8HHHd$0 d$( A   H
pY  E3   @DD$ E  H  HHH(H
  HtHt;E  H
  HtHt"E  H(H\$Ht$WH =v   H?  HtmHuH9>  t_+  uVH  HtJHtEHHHHt2zH;vH<9=uLH  tHHHD83H\$0Ht$8H _H\$Ht$H|$ATH0IHH   83Hu&   Hd$  E3E333   H' HtH# 3Hu#   Hd$  E3E333zHHHu3fH   L$I(nHHuC    81LIHtHd$  E3E333HtL#3   EH\$@Ht$HH|$PH0A\Hl$WHpHcHL$P}t   sbHT$P  ~LD$P   HT$PH@  xtHH  8   |$h tHD$`      HD$P  ~6HT$P@t@$   @$   $            *   @$   $    HL$PD$@   L$   AA   D$8H$   D$0   HD$(T$ QHL$PC2$   t
$   |$h tHL$`   H$   Hp_HHXHhHpWH`HHHHIIIrHu8\$XtHD$P   3   Hu:Hd$  E3E333    1|$X tHD$P   pHtHwHL$Hy uLLHH  1AQHL$@D$8\$0LA  H|$(\$ 	  t|$X tHL$P   L\$`I[IkIs I_E3H\$Hl$WH@Hd$P H  HH   Hd$8 Hd$0 d$( Hd$  DL33?  Hc   H   HD$PHtzHd$8 Hd$0 LD33|$(HD$ ?  tGHL$P3  yHL$PHt$Hd$P HHHY3H\$XHl$`H@_HL$P@USVWATAUAVAWHhHl$0HKq  H3HE(H   DU   A   3MDELH}Ec;uOL8I  E33Dd$(LD$ ?  ;t
AE\$=  w  A   xADDU `  D   D;~YAIA+8t	I;u+DD   D   D;~5AHA+8t	I;u+DD   D;}3  D;|A;  ;  A;uD   D;uIDiD;t	D;   E;uA\  E;~AO  E;~
   @  HUA=  ;tD   D;~2}r8]HEt8XtA:r:HvH8     9   ~+}r8]HEt8Xz:r:HvH8M	   A\$(H\$ w=  LcD;I~d3HBIHrUKL6H   w.HAH;wIH5-  H+Ht$0H;  HH;t   HHH;pD   MAADt$(Ht$ <  ;   D   L	   A\$(H\$ <  LcD;   ~g3HBIHrXKL$H   w1HAH;w
HHg,  H+H|$0H;t  )HH;t   HHH;tVD   LE   ADd$(H|$ <  ;tUM ELDd$(H|$ V<  HO9  u/HN9  u   HLD;uIDPDU D   D;uID`AD; A;teL   MA\$(H\$ HH;LEL   AA\$(H\$ LH;u
H~LLLE   D   UM D$(LD$ MT;  H;tH9I1HM(H3/lHe8A_A^A]A\_^[]H\$Ht$WH`HHL$@IAlD$   $   HL$@D\$8D$0H$   HD$($   LDD$ |$X tHL$P   H\$pHt$xH`_H\$Ht$WH`HHHL$@IIkHu8\$XtHD$P   3   Hu=Hd$  E3E333    |$X tHD$P      HtHwHD$@PuLL$@LHH>@HL$@LD$8\$0A  H|$(\$ u    y|$X tHL$P   H\$pHt$xH`_H\$T$UVWATAUAVAWH0E3LAI;u$E3E333Ll$        L!M;   =   I  HHD$pI;   L;   D8hH5{  EAH;5{  upHAI;uIUHL9.u   HcHHI;u	   WlH  HHHHE I;uL/H|$pl$xH5~{  I;   A;t9L9-y{  t0fA;tj    H$   H0A_A^A]A\_^]E;t3   H{  I;tL(L9-{  u   H{  I;tL(H5z  HI;tHHA+LcHt?HMIuHA| =   A8\    HHHuH5z  H+HE3A;   L9m    HcHL JE;tfL9l tHLHHHD HL9l uHcHH;   H
 z  A   qI;t|sH5z  H+HrLd M.]E;   A;}G;LcHL;n   HI;XHcL$LlM.Hy  D9l$x   I   HHHI;tlIMHHPHA;tE3E333Ll$ HHI+HT$pD*HE;IE6  A;ui *   HE;tIM.IM.H\$Ht$WH0HHtF<HHHHHt-HVLHtHd$  E3E333H3H\$@Ht$HH0_H\$Ht$WHPHHL$0IWf3H;uDE3E333Ht$     @8t$HtHD$@   3H\$`Ht$hHP_HT$89ruH   @8t$HtHL$@   f;t3DtH@83t;u
HC;tH;l@8t$HtHD$@   HfE3 :t
Hu:uH3%X2  %2  %2  H8Hu&Hd$  E3E333    H9 tHtHHt8 tE3  H8HT$L$SUVWATAUAVAWHXAHcADd$4\$8A;u,38 	     3;  ;    HLL
AIKC HkXD1  v8      ;    H;tD|18A   EAAtutLdtA;ABLH;u,    A    =  $   3DBL
A@LKC L\0@KC IA
   D0H   L0	A:   ;   AM KC AAIUAhDD0	D:tbKC L09A:tQ;tM
KC AHAhDD09Au.KC L0:A:t;t
KC HAhADD0:KC LL$0DH1H|$ 1  ;  HcT$0;  H;  L3?KC D0y  A  ;tA} 
uL0d0HcIMIHD$@L;:  
   A$<
  @:t
HI   HD$@HL;sID$8
u	I   L   KC LL$0H$   H1A   IH|$ 0  ;u
9/  ;u{9|$0tuLP>KC D0Ht"$   
t'@+KC $   D1	GI;u$   
u
3$   A   H]$   
L=tL=@+HL;d$@KC D0@uL0	A$HA+A  ;  A   I+uI   AI;rI+AB8 4 tB4 ;u} *   A  ;uHcH^KC D0Ht;IL0	|KC ID19uKC ID1:HcH+$   EHc2D$8L$   A+DMD$(3  L|$ .  ;ui-  |A  Dd$4;Hs<JC @|0H  ;
   tfA9U uL0d0HcIMN<(M;{  
   A$fE  f;tfHI%  IGL;sID$f9u	I   L   KC LL$0H$   H1A   IH|$ .  ;u},  ;   9|$0   L;KC D0HtF
   f9$   tKf+$   KC D1	$   KC D19KC T0:WI;u
   f9$   uf>$   HDBo
   L:f9$   t
   L:f+HM;"KC D0@uL0A$fHA+Dd$4L$   M;tI|ADDAiU+  u/z 	   Dz    muDHz3)z8y 	   E3E333H|$ 	yHXA_A^A]A\_^][H\$Ht$L$WATAUAVAWH0ALHcuy3y 	     3;   ;=}     LLIL=}  AMkXKBL u.\y5y 	   H\$ E3E333Kx   A;u+yx    H\$ E3E333
xnKBD tDIsx 	   x)xx 	   H\$ E3E333wH\$hHt$pH0A_A^A]A\_HHXL@HHUVWATAUAVAWH   3AAH@   ox@$   HxEtxAl$pDHL$T  ;tE3E333H|$ ur @ u
|$T   tE
A      A#   ;tT+t:;t1w8w   E3E333H|$ v  D@t   uA   @D$   A   t,t#tt@uD;AA   L$H#tF=   t8=   t*=   t=   t*=   t&=   t;t/A   
   AA   Dl$Ps'l  "$   AEDDDl$P@@tAADl$PL$Hs
ADl$P@ tA@t
ADl$PIu!Iv8v    v   H$   DD$HH$   H|$0LL$`ADl$(    l$ b(  HD$XH      A#;uC   @t9DD$HH$   H|$0ALL$`Dl$(Al$ 
(  HD$XHu;HcL-0y  HHHkXID dj&  uBu8  H%  ;uMHcL-x  HHHkXID d"&  =uHL$XV'  ;ut 
   A;uA@	uAHT$X%HcL-{x  H   HD
ID HkXDtHcHHHkXID d8A$HD$L   E  AtxE	  D$Dudt8   tPHT$@A   @|$@;u|$@uHcT$D  tE33E	  t   E<   @ uD$T#u#= @  tJ=   t,= @ t%=   t+= @ t$=   t= @ u($     #;uD$   @$        |$DA@  A%   =   @$  =   t|=     ;  A;vv8l  $   A   A+   A;P  D$D    E3H;tE33nH|HT$DA   baA;t uk|$D uD@D$      D$D=  u%`r     =  u#E3A  D$      E33p  ;;vqA;E3H;E33Hu8D$D A   HcEHTDD+NmD;A   Hc@$   H@HHkXID d8@l8HcHHHkXIL d8D8@8|$Lu!@tHcHHHkXID L A%   =      A   HL$X^#  D$PDD$HH$   H|$0D$(ALL$`D$    AQ#  Hu6!  pLcIAHMkXID BdBHcHHHkXIL H
H$   H   A_A^A]A\_^]HPL@LH VWHXH` E3HAEu( p    Hd$  E3E3335o   H$   HD@d$0 DD$(D$ @   DLHT$@HL$DvD$H|$D t9t(Hc|$@HHHLcs  HkXId|$@n|$@tso0HX_^@SH0MHHHu&GoHd$  E3E333    \nHUHtHL$ LL$XLD$@IH  tLL$XLD$@H     HL$@HfqHL$X\qHH0[H\$LD$UVWATAUAVAWH0E3MLHHI;u(nE3E333Lt$     mH  D81tI;tHI;tD80t\   v  /   HHf  A   I;   I;   AW9HRHI;   H.IHXHnHI;sLl4  HHuA;tE3E333Lt$ kLHHA;tE3E333Lt$ kH~
I;tH;vHHHS/
  HI;t&3  A;   MIHH   lIL`I-nHI;   LIHA;tE3E333Lt$ kH"L4lM+D8I<L%Pb  HD$pM$HIhtHd$  E3E333j3HQ  tHa  IL;HD$p}lL$   IHD8HHnH;tHnHH\$xH0A_A^A]A\_^]HHXHhHpHx ATAUAWH H33DGLHtPDG3Ht=HH+H;     A   WHM  HH;u1k    k H\$@Hl$HHt$PH|$XH A_A]A\   v  DDI;HEMtHH+H;~}k8uSk 
   HA+    LH3O  U}]E3HHTH  HHHHu%j 
   jH  HE3IiH3H\$Ht$WH HcANHuj 	   RDE3H  uv  3t	jHHH n  HHHkXdH\$0Ht$8H _H\$LcHm  MAIMkXJBD8F\A   DA @  tX   tH   t(   t    uHBLJBd 8BL 80BLJBd 8BL 8BdBLJBd8Eu   A%    @  H\$H8Hu'6iHd$  E3E333    Kh   
l  3H8LL$ HT$SUWATAUAVAWH   3GDgDD;tt~A;~;uAM@h8hE3E333    H|$ g@  IA88uA8xtA  IA88uh   HL$p3LE\$pl  Ll  ;t/SHcHHHkXI@8|u;u;  q       fLf$   hH$   H;  ;H$   LcHHIT~WLDL~k  MIAHMkXMABu
IH@9H
IHHIuH$   LcD:t2A;HHITDLD;~A@9H
HHHuA   TgH$(  E38HD$PE3HD$HHD$pIHD$@H$8  H|$8HD$0Dt$(D$    D    H$   DXi;u
Agru3VP;u+HL$P  HL$PH$     Hc$   	   ;u
HL$P  H|$PHL$X  HVf    HH   A_A^A]A\_][@SUVWATAUAVAWH   H!J  H3HD$xH,  E3HHT$hEfMH,  LL$XfBy,  MB
HHL$`ADt$0Lt$8Dt$4HAHH|HI;u   HD$HfII;u"Mu e    e      LD$hHL$83AA;t   E3E333Lt$ ;ctHL$hKHL$8A<H|$PI;t3H|$PI;Z  HE HHHEdHI;uHZ  I;u+HHZ  I;uI:gM7Mu    E=D82t(H:tHkZ  ElIcHA:uEIc/@8qt0y:u*8Yu%AFHcHpH)Z  EtIcH8tAHA+DDd$@H9u t'HL$h9HHT$hL  tRHH93uDA   dHL$XHHuKI[fE3M7c    c    	  D$4   Dd$0Mu Dl$0Dt$0Dd$@H|$`ILMuH8HT$HHtH!t$ E3E333YaHmHHHHHtVHt$HILHH+HtHd$  E3E333aH HHcH HHHut$0L|$XC  I?H  E+IcHHX  IcLE3HL9u tKALE HHH+I!A;tE3E333Lt$ x`HM HHHL9u uD9t$4   Hc\$PLD$hHHA;tE3E333Lt$ %`LZ  HH?A;tE3E333Lt$ _HL$8I;t'LHHA;tE3E333Lt$ _HE3I;tI;?uD7HD7H
W  I;tdHL$8L5mW  I;tdHL$xH3EH   A_A^A]A\_^][@SH0Hu-ja  BaHd$     E3E333V`Pu  u%  Ba` 'u!tta    ` 
   3H0[H\$Ht$WHPHHL$0I3]DHu6`H!|$ E3E333    _@8|$HtHD$@   3LD$8A9xuHQ  @8|$HtcHL$@   UHBDt%Ht;uH{HuH;HDHu8L$HtHL$@   HH\$`Ht$hHP_E3H\$Hl$Ht$WHP3IHHL;u3  HL$0IPCL\$8A9kuLHHE  H;u<t_E3E333Hl$     ^@8l$HtHD$@     H;tHHBDtA@8+ufKfHffA;KrfA;KwfAK)fA;Kr"fA;KwfAKBDt	B  HBDtA@8/ufKfHffA;SrfA;SwfAS)fA;Sr"fA;SwfASBDt	B  f;u*f;t	H;$@8l$HHD$@   @8l$HtHL$@   H\$`Hl$hHt$pHP_E34LE3HA:uHI;t8u8LDIff     HL$L\$M3LT$L+MBeL%   M;sfA M A M;uL$L\$H@UH0HHM`9H0]@UH H    t
   cH ]@UH HHH8H ]@UH H   _cH ]@UH HHcM HHb  H9H ]@UH H   cH ]@UH HH
XC  *
  H ]@UH H
   bH ]@UH H   bH ]@UH H
   bH ]@UH H   bH ]@UH HCH ]@UH HH38  H ]@UH0H}p t31bH0]@UH HHE38  AAH ]@UH0HHM@8H0]@UH0HMPH0]@UH0HM`iH0]@UH H
   aH ]@UH H
   aH ]@UH H   waH ]@UH0H   ^aH0]@UH@H}D t7}H t'HcU@HHHL^  HkXIdU@H@]                                                                                                                                                                                                                                                                                             2     H     `     x                                                       .     B     V     r                                                  $     0     B     R     b     p     ~                                             0     J     `     z                                             (     <     L     b     r                                             
          (     :     L     t                                                    x @   S @   _ @   h @                    @   \ @                           failed to get exit code from process.
  failed to create process.
   %s %s      Could not exec %s       Cannot find Python executable %s
       #!python.exe    #!      Cannot open %s
 -script.pyw     CorExitProcess  m s c o r e e . d l l   ( n u l l )     (null)                 EEE50 P    ( 8PX 700WP        `h````  xpxxxx              8@   8@   	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ =       runtime error   
      TLOSS error
   SING error
    DOMAIN error
  R6034
An application has made an attempt to load the C runtime library incorrectly.
Please contact the application's support team for more information.
      R6033
- Attempt to use MSIL code from this assembly during native code initialization
This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain.
  R6032
- not enough space for locale information
      R6031
- Attempt to initialize the CRT more than once.
This indicates a bug in your application.
      R6030
- CRT not initialized
  R6028
- unable to initialize heap
    R6027
- not enough space for lowio initialization
    R6026
- not enough space for stdio initialization
    R6025
- pure virtual function call
   R6024
- not enough space for _onexit/atexit table
    R6019
- unable to open console device
        R6018
- unexpected heap error
        R6017
- unexpected multithread lock error
    R6016
- not enough space for thread data
             
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
   R6009
- not enough space for environment
     R6008
- not enough space for arguments
       R6002
- floating point support not loaded
    Microsoft Visual C++ Runtime Library    

  ... <program name unknown>  Runtime Error!

Program:                                                                                                                                            EEE  00P  ('8PW  700PP    (   `h`hhhxppwpp                                                                                                                                                                                                                                                                                             ( ( ( ( (                                     H                                                                                                                                                                                                                                                                                                                                                                                     h ( ( ( (                                     H                                                                                                             H                                               	

 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~HH:mm:ss        dddd, MMMM dd, yyyy     MM/dd/yy    PM  AM      December        November        October September   August  July    June    April   March       February        January Dec Nov Oct Sep Aug Jul Jun May Apr Mar Feb Jan Saturday    Friday      Thursday        Wednesday       Tuesday Monday  Sunday  Sat Fri Thu Wed Tue Mon Sun     GetProcessWindowStation GetUserObjectInformationA       GetLastActivePopup      GetActiveWindow MessageBoxA     USER32.DLL      SunMonTueWedThuFriSat   JanFebMarAprMayJunJulAugSepOctNovDec    CONOUT$ .com    .exe    .bat    .cmd    .\      SystemRoot                                       t d
 T	 4 2 
4 
 p    P  
 
4 
 p  !       $ !        !   H  I      ! H I dJ      ! TR     $   K p0  0   bp`0  +       Y  @      
 4 R
p`P r0 0 4 2p
 
4 
2p
 d 4 rp+     '  (  X       2P	 d 4  p  +     *  *     +  *  +  z  +     d  T  4  rp t 4 2	 	20 d T 4 2p d T 4 2p) 4d Z 
p`P      	 
    t  d  4     +     :  :     \=  	 	 0  
 t	 d T 4 2
 d
 T	 4 2p
 
20 d	 4 R+     B  C        
  t d
 R+     [D  D        "D  D         t d 4 2 t d 4 2+     F  F         d
 T	 4 Rp d 4
 rp  $ d 4  p    p  
 
4 
2p+     N  kN         4 r
p`P  8   
  t
 d	 4 R+     R  ;S         20+     W  !W  -      
 
4 
2p+     W  W  F      W  %X  f       4 2p+     Y  Y  F      Y  Y  f       d T p d	 T 4 2p  t
 4 R
 t
 d	 4 2+     `  `         B  	 B  +     Gb  zb    zb  	 B  +     b  b     b  
 d 4 r
p+     @f  f        	 b  +     Tg  cg    cg   t d
 T	 4 2 d 4
 Rp
 t
 d T 4
 r B  
 
4 
2p       4 p
`P d	 4 Rp
 
4 
Rp RP 4	 Rp+     v  v        / 4qf
p`P       
 d 4
 Rp+       =  .       4 R
p
`+       c        
 
4 
p
 d T 4 p-
Et d 4 C
P    X    d 4 p1
5#t d 4 3r
P    8    d 4 p 2
0
 d 4
 Rp+         .      
 T 4 rp`   t d T 4  d
 4 Rp+                20     P       T 4 2p
 	 t d 4 2+     K  k  E      
  t
 4 r+     m    ^          ~       b    (   'EC 
	p`0P    p    b      t
 d	 4 R+               
 
T 
p d T 4 p T 4 rp$
53
	p`0P  X   
 4 Rp`
P d
 4 p	 
p`P
0  
 d 4
 Rp+         .      !
 !4 !p`P rP p`  +                R0 t d
 T	 4 2 d 4 2p 4 	  
pP0  #
  
	p`P0  x    d T
 4 p0         f                                                     2     H     `     x                                                       .     B     V     r                                                  $     0     B     R     b     p     ~                                             0     J     `     z                                             (     <     L     b     r                                             
          (     :     L     t                            SGenerateConsoleCtrlEvent  GetExitCodeProcess  rWaitForSingleObject  CreateProcessA  SetConsoleCtrlHandler GetModuleFileNameA   EnterCriticalSection  LeaveCriticalSection  GetModuleHandleW  /Sleep "GetProcAddress  ExitProcess qGetCommandLineA <GetStartupInfoA RtlUnwindEx SetHandleCount  >GetStdHandle  GetFileType  DeleteCriticalSection ;TerminateProcess  GetCurrentProcess LUnhandledExceptionFilter  #SetUnhandledExceptionFilter IsDebuggerPresent RtlVirtualUnwind  RtlLookupFunctionEntry  RtlCaptureContext GetLastError  HeapFree  HeapAlloc ]GetCPInfo TGetACP  GetOEMCP  IsValidCodePage  EncodePointer  DecodePointer @FlsGetValue AFlsSetValue ?FlsFree SetLastError  GetCurrentThreadId  >FlsAlloc  WriteFile LoadLibraryA  InitializeCriticalSectionAndSpinCount LFreeEnvironmentStringsA GetEnvironmentStrings MFreeEnvironmentStringsW WideCharToMultiByte GetEnvironmentStringsW  HeapSetInformation  HeapCreate  SQueryPerformanceCounter jGetTickCount  GetCurrentProcessId SGetSystemTimeAsFileTime HeapReAlloc GetConsoleCP  GetConsoleMode  CFlushFileBuffers  LCMapStringA  MultiByteToWideChar LCMapStringW  @GetStringTypeA  CGetStringTypeW  GetLocaleInfoA  SetFilePointer  HeapSize  D CloseHandle WriteConsoleA GetConsoleOutputCP  WriteConsoleW 
SetStdHandle  z CreateFileA S CompareStringA  V CompareStringW  SetEnvironmentVariableA KERNEL32.dll  hReadFile  SetEndOfFile  &GetProcessHeap  GetFileAttributesA                                                                          E@           E@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2-+  ] f\) @            @    @   
                                                                                                                 
      	               	      
                  
               
               !   
   5      A   
   C      P      R   
   S   
   W      Y      l   
   m       p      r   	            
      
      	            
      )      
                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                                                                                                                                                                                                                                                                                                                                               abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                      (@         `y!                       @~                                    @                                      A         [                       @~    Q  Q^  _j2                   1~     @       C                                                                                                                      @-@                           @-@                           @-@                           @-@                           @-@                                                         P2@                    @   @    @   0@   P-@          P-@    (@                      X @          ( @   	        @   
       ` @          ( @           @           @           @          h @          @ @           @           @           @           @            @            @   !        @   "       P @   x       @ @   y       0 @   z         @           @           @    @    @    @    @    @    @    @    @    @    @            
                   @    @   P@   L@   H@   D@   @@   <@   8@   0@   (@    @   @    @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   @   |@   t@   h@   `@   P@   @@   8@   4@   (@   @    @   	             0@   .               @2@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   lB@   P2@      .                        p         PST                                                             PDT                                                             2@    3@                              ;   Z   x                 0  N  m         :   Y   w                 /  M  l                                                                                                                                                                                                              8@   0@   (@    @                                                                                                                                                                                                                       x   Y   `    x     d               $        _   _                 m  < x  Z  h \    d     h     h   j  d l    d     h T    h     d     <     "  d "  6#   p#  $  h $  $  | $  5%   &  5&  h 8&  q&  h t&  &  h &  &   &  '   '  '   '  N)   )  )  h )  +   +  +  d +  -   -  U.  4 X.  .  D .  .  h .  )/  L ,/  /  ` /  :  t :  =   =  =  < =  >   >  q?  	 ?  ?  d ?  ?  d ?  B@  h D@  @  ` @  3A   4A  A   A  DB   DB  B  	 B  4C  	 4C  C   C  C  h C  D  <	 D  E  |	 E  F  `  F  G  	 G  LG   LG  G   G  RI  	 TI  I  	 I  J  < J  ZK  	 \K  K  ` K  M  	 M  N  
 N   O  |  O  Q  (
 Q  S  D
 S  S  d S  2U   tV  V  h V  AW  t
 `W  W  d W  :X  
 <X  X   X  X  h X  Z  
 Z  Z  h Z  [  
 [  9]   <]  a_    d_  _  d _  _  h _  `  4 `  a  d a  Da   Da  |a   |a  a   @b  b  l b  b   b  b  d b  d  ` d  5g   Pg  g   g  g  h g  h  d h   h  d  h  h   h  i  	 i  k   k  l   l  Fn  ( Hn  n  @ n  Go  H `o  o  X o  3p  < 4p  yp  | |p  p  | q  s  ` s  s  < s  t   t  Wu   Xu  u  p u  }v   v  v   v  V~   X~         
   Z  4
 d    @
   I  X
 L    
   N  
 P    
 $    
   X  	 X    
   y  | |  Q  | T    | h        7  
 8    h           <     < $       J    L  |  < |  8   8  P  < P    h     p   
        `   |   |     <              ?   @       -   0    <     D     d          L   L  x L  [   d  V   X  2   4    
     
          p      $  w  < x       j   l  j  8 l  Y  X \    |   u  d x            v   x    <        `   `    |             >   @  X   X  z   z                           -   -  F   F  _   f                                .   .  E   E  ^   ^  w   ~              P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
import sys
import marshal
import contextlib
import dis
from distutils.version import StrictVersion

from ._imp import find_module, PY_COMPILED, PY_FROZEN, PY_SOURCE
from . import _imp


__all__ = [
    'Require', 'find_module', 'get_module_constant', 'extract_constant'
]


class Require:
    """A prerequisite to building or installing a distribution"""

    def __init__(
            self, name, requested_version, module, homepage='',
            attribute=None, format=None):

        if format is None and requested_version is not None:
            format = StrictVersion

        if format is not None:
            requested_version = format(requested_version)
            if attribute is None:
                attribute = '__version__'

        self.__dict__.update(locals())
        del self.self

    def full_name(self):
        """Return full package/distribution name, w/version"""
        if self.requested_version is not None:
            return '%s-%s' % (self.name, self.requested_version)
        return self.name

    def version_ok(self, version):
        """Is 'version' sufficiently up-to-date?"""
        return self.attribute is None or self.format is None or \
            str(version) != "unknown" and version >= self.requested_version

    def get_version(self, paths=None, default="unknown"):
        """Get version number of installed module, 'None', or 'default'

        Search 'paths' for module.  If not found, return 'None'.  If found,
        return the extracted version attribute, or 'default' if no version
        attribute was specified, or the value cannot be determined without
        importing the module.  The version is formatted according to the
        requirement's version format (if any), unless it is 'None' or the
        supplied 'default'.
        """

        if self.attribute is None:
            try:
                f, p, i = find_module(self.module, paths)
                if f:
                    f.close()
                return default
            except ImportError:
                return None

        v = get_module_constant(self.module, self.attribute, default, paths)

        if v is not None and v is not default and self.format is not None:
            return self.format(v)

        return v

    def is_present(self, paths=None):
        """Return true if dependency is present on 'paths'"""
        return self.get_version(paths) is not None

    def is_current(self, paths=None):
        """Return true if dependency is present and up-to-date on 'paths'"""
        version = self.get_version(paths)
        if version is None:
            return False
        return self.version_ok(version)


def maybe_close(f):
    @contextlib.contextmanager
    def empty():
        yield
        return
    if not f:
        return empty()

    return contextlib.closing(f)


def get_module_constant(module, symbol, default=-1, paths=None):
    """Find 'module' by searching 'paths', and extract 'symbol'

    Return 'None' if 'module' does not exist on 'paths', or it does not define
    'symbol'.  If the module defines 'symbol' as a constant, return the
    constant.  Otherwise, return 'default'."""

    try:
        f, path, (suffix, mode, kind) = info = find_module(module, paths)
    except ImportError:
        # Module doesn't exist
        return None

    with maybe_close(f):
        if kind == PY_COMPILED:
            f.read(8)  # skip magic & date
            code = marshal.load(f)
        elif kind == PY_FROZEN:
            code = _imp.get_frozen_object(module, paths)
        elif kind == PY_SOURCE:
            code = compile(f.read(), path, 'exec')
        else:
            # Not something we can parse; we'll have to import it.  :(
            imported = _imp.get_module(module, paths, info)
            return getattr(imported, symbol, None)

    return extract_constant(code, symbol, default)


def extract_constant(code, symbol, default=-1):
    """Extract the constant value of 'symbol' from 'code'

    If the name 'symbol' is bound to a constant value by the Python code
    object 'code', return that value.  If 'symbol' is bound to an expression,
    return 'default'.  Otherwise, return 'None'.

    Return value is based on the first assignment to 'symbol'.  'symbol' must
    be a global, or at least a non-"fast" local in the code block.  That is,
    only 'STORE_NAME' and 'STORE_GLOBAL' opcodes are checked, and 'symbol'
    must be present in 'code.co_names'.
    """
    if symbol not in code.co_names:
        # name's not there, can't possibly be an assignment
        return None

    name_idx = list(code.co_names).index(symbol)

    STORE_NAME = 90
    STORE_GLOBAL = 97
    LOAD_CONST = 100

    const = default

    for byte_code in dis.Bytecode(code):
        op = byte_code.opcode
        arg = byte_code.arg

        if op == LOAD_CONST:
            const = code.co_consts[arg]
        elif arg == name_idx and (op == STORE_NAME or op == STORE_GLOBAL):
            return const
        else:
            const = default


def _update_globals():
    """
    Patch the globals to remove the objects not available on some platforms.

    XXX it'd be better to test assertions about bytecode instead.
    """

    if not sys.platform.startswith('java') and sys.platform != 'cli':
        return
    incompatible = 'extract_constant', 'get_module_constant'
    for name in incompatible:
        del globals()[name]
        __all__.remove(name)


_update_globals()

"""Extensions to the 'distutils' for large or complex distributions"""

from fnmatch import fnmatchcase
import functools
import os
import re

import _distutils_hack.override  # noqa: F401

import distutils.core
from distutils.errors import DistutilsOptionError
from distutils.util import convert_path

from ._deprecation_warning import SetuptoolsDeprecationWarning

import setuptools.version
from setuptools.extension import Extension
from setuptools.dist import Distribution
from setuptools.depends import Require
from . import monkey


__all__ = [
    'setup',
    'Distribution',
    'Command',
    'Extension',
    'Require',
    'SetuptoolsDeprecationWarning',
    'find_packages',
    'find_namespace_packages',
]

__version__ = setuptools.version.__version__

bootstrap_install_from = None


class PackageFinder:
    """
    Generate a list of all Python packages found within a directory
    """

    @classmethod
    def find(cls, where='.', exclude=(), include=('*',)):
        """Return a list all Python packages found within directory 'where'

        'where' is the root directory which will be searched for packages.  It
        should be supplied as a "cross-platform" (i.e. URL-style) path; it will
        be converted to the appropriate local path syntax.

        'exclude' is a sequence of package names to exclude; '*' can be used
        as a wildcard in the names, such that 'foo.*' will exclude all
        subpackages of 'foo' (but not 'foo' itself).

        'include' is a sequence of package names to include.  If it's
        specified, only the named packages will be included.  If it's not
        specified, all found packages will be included.  'include' can contain
        shell style wildcard patterns just like 'exclude'.
        """

        return list(
            cls._find_packages_iter(
                convert_path(where),
                cls._build_filter('ez_setup', '*__pycache__', *exclude),
                cls._build_filter(*include),
            )
        )

    @classmethod
    def _find_packages_iter(cls, where, exclude, include):
        """
        All the packages found in 'where' that pass the 'include' filter, but
        not the 'exclude' filter.
        """
        for root, dirs, files in os.walk(where, followlinks=True):
            # Copy dirs to iterate over it, then empty dirs.
            all_dirs = dirs[:]
            dirs[:] = []

            for dir in all_dirs:
                full_path = os.path.join(root, dir)
                rel_path = os.path.relpath(full_path, where)
                package = rel_path.replace(os.path.sep, '.')

                # Skip directory trees that are not valid packages
                if '.' in dir or not cls._looks_like_package(full_path):
                    continue

                # Should this package be included?
                if include(package) and not exclude(package):
                    yield package

                # Keep searching subdirectories, as there may be more packages
                # down there, even if the parent was excluded.
                dirs.append(dir)

    @staticmethod
    def _looks_like_package(path):
        """Does a directory look like a package?"""
        return os.path.isfile(os.path.join(path, '__init__.py'))

    @staticmethod
    def _build_filter(*patterns):
        """
        Given a list of patterns, return a callable that will be true only if
        the input matches at least one of the patterns.
        """
        return lambda name: any(fnmatchcase(name, pat=pat) for pat in patterns)


class PEP420PackageFinder(PackageFinder):
    @staticmethod
    def _looks_like_package(path):
        return True


find_packages = PackageFinder.find
find_namespace_packages = PEP420PackageFinder.find


def _install_setup_requires(attrs):
    # Note: do not use `setuptools.Distribution` directly, as
    # our PEP 517 backend patch `distutils.core.Distribution`.
    class MinimalDistribution(distutils.core.Distribution):
        """
        A minimal version of a distribution for supporting the
        fetch_build_eggs interface.
        """

        def __init__(self, attrs):
            _incl = 'dependency_links', 'setup_requires'
            filtered = {k: attrs[k] for k in set(_incl) & set(attrs)}
            distutils.core.Distribution.__init__(self, filtered)

        def finalize_options(self):
            """
            Disable finalize_options to avoid building the working set.
            Ref #2158.
            """

    dist = MinimalDistribution(attrs)

    # Honor setup.cfg's options.
    dist.parse_config_files(ignore_option_errors=True)
    if dist.setup_requires:
        dist.fetch_build_eggs(dist.setup_requires)


def setup(**attrs):
    # Make sure we have any requirements needed to interpret 'attrs'.
    _install_setup_requires(attrs)
    return distutils.core.setup(**attrs)


setup.__doc__ = distutils.core.setup.__doc__


_Command = monkey.get_unpatched(distutils.core.Command)


class Command(_Command):
    __doc__ = _Command.__doc__

    command_consumes_arguments = False

    def __init__(self, dist, **kw):
        """
        Construct the command for dist, updating
        vars(self) with any keyword parameters.
        """
        _Command.__init__(self, dist)
        vars(self).update(kw)

    def _ensure_stringlike(self, option, what, default=None):
        val = getattr(self, option)
        if val is None:
            setattr(self, option, default)
            return default
        elif not isinstance(val, str):
            raise DistutilsOptionError(
                "'%s' must be a %s (got `%s`)" % (option, what, val)
            )
        return val

    def ensure_string_list(self, option):
        r"""Ensure that 'option' is a list of strings.  If 'option' is
        currently a string, we split it either on /,\s*/ or /\s+/, so
        "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
        ["foo", "bar", "baz"].
        """
        val = getattr(self, option)
        if val is None:
            return
        elif isinstance(val, str):
            setattr(self, option, re.split(r',\s*|\s+', val))
        else:
            if isinstance(val, list):
                ok = all(isinstance(v, str) for v in val)
            else:
                ok = False
            if not ok:
                raise DistutilsOptionError(
                    "'%s' must be a list of strings (got %r)" % (option, val)
                )

    def reinitialize_command(self, command, reinit_subcommands=0, **kw):
        cmd = _Command.reinitialize_command(self, command, reinit_subcommands)
        vars(cmd).update(kw)
        return cmd


def _find_all_simple(path):
    """
    Find all files under 'path'
    """
    results = (
        os.path.join(base, file)
        for base, dirs, files in os.walk(path, followlinks=True)
        for file in files
    )
    return filter(os.path.isfile, results)


def findall(dir=os.curdir):
    """
    Find all files under 'dir' and return the list of full filenames.
    Unless dir is '.', return full filenames with dir prepended.
    """
    files = _find_all_simple(dir)
    if dir == os.curdir:
        make_rel = functools.partial(os.path.relpath, start=dir)
        files = map(make_rel, files)
    return list(files)


class sic(str):
    """Treat this string as-is (https://en.wikipedia.org/wiki/Sic)"""


# Apply monkey patches
monkey.patch_all()

import glob
import os
import subprocess
import sys
import tempfile
from distutils import log
from distutils.errors import DistutilsError

import pkg_resources
from setuptools.wheel import Wheel


def _fixup_find_links(find_links):
    """Ensure find-links option end-up being a list of strings."""
    if isinstance(find_links, str):
        return find_links.split()
    assert isinstance(find_links, (tuple, list))
    return find_links


def fetch_build_egg(dist, req):  # noqa: C901  # is too complex (16)  # FIXME
    """Fetch an egg needed for building.

    Use pip/wheel to fetch/build a wheel."""
    # Warn if wheel is not available
    try:
        pkg_resources.get_distribution('wheel')
    except pkg_resources.DistributionNotFound:
        dist.announce('WARNING: The wheel package is not available.', log.WARN)
    # Ignore environment markers; if supplied, it is required.
    req = strip_marker(req)
    # Take easy_install options into account, but do not override relevant
    # pip environment variables (like PIP_INDEX_URL or PIP_QUIET); they'll
    # take precedence.
    opts = dist.get_option_dict('easy_install')
    if 'allow_hosts' in opts:
        raise DistutilsError('the `allow-hosts` option is not supported '
                             'when using pip to install requirements.')
    quiet = 'PIP_QUIET' not in os.environ and 'PIP_VERBOSE' not in os.environ
    if 'PIP_INDEX_URL' in os.environ:
        index_url = None
    elif 'index_url' in opts:
        index_url = opts['index_url'][1]
    else:
        index_url = None
    find_links = (
        _fixup_find_links(opts['find_links'][1])[:] if 'find_links' in opts
        else []
    )
    if dist.dependency_links:
        find_links.extend(dist.dependency_links)
    eggs_dir = os.path.realpath(dist.get_egg_cache_dir())
    environment = pkg_resources.Environment()
    for egg_dist in pkg_resources.find_distributions(eggs_dir):
        if egg_dist in req and environment.can_add(egg_dist):
            return egg_dist
    with tempfile.TemporaryDirectory() as tmpdir:
        cmd = [
            sys.executable, '-m', 'pip',
            '--disable-pip-version-check',
            'wheel', '--no-deps',
            '-w', tmpdir,
        ]
        if quiet:
            cmd.append('--quiet')
        if index_url is not None:
            cmd.extend(('--index-url', index_url))
        for link in find_links or []:
            cmd.extend(('--find-links', link))
        # If requirement is a PEP 508 direct URL, directly pass
        # the URL to pip, as `req @ url` does not work on the
        # command line.
        cmd.append(req.url or str(req))
        try:
            subprocess.check_call(cmd)
        except subprocess.CalledProcessError as e:
            raise DistutilsError(str(e)) from e
        wheel = Wheel(glob.glob(os.path.join(tmpdir, '*.whl'))[0])
        dist_location = os.path.join(eggs_dir, wheel.egg_name())
        wheel.install_as_egg(dist_location)
        dist_metadata = pkg_resources.PathMetadata(
            dist_location, os.path.join(dist_location, 'EGG-INFO'))
        dist = pkg_resources.Distribution.from_filename(
            dist_location, metadata=dist_metadata)
        return dist


def strip_marker(req):
    """
    Return a new requirement without the environment marker to avoid
    calling pip with something like `babel; extra == "i18n"`, which
    would always be ignored.
    """
    # create a copy to avoid mutating the input
    req = pkg_resources.Requirement.parse(str(req))
    req.marker = None
    return req

"""
Filename globbing utility. Mostly a copy of `glob` from Python 3.5.

Changes include:
 * `yield from` and PEP3102 `*` removed.
 * Hidden files are not ignored.
"""

import os
import re
import fnmatch

__all__ = ["glob", "iglob", "escape"]


def glob(pathname, recursive=False):
    """Return a list of paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    If recursive is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    """
    return list(iglob(pathname, recursive=recursive))


def iglob(pathname, recursive=False):
    """Return an iterator which yields the paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    If recursive is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    """
    it = _iglob(pathname, recursive)
    if recursive and _isrecursive(pathname):
        s = next(it)  # skip empty string
        assert not s
    return it


def _iglob(pathname, recursive):
    dirname, basename = os.path.split(pathname)
    glob_in_dir = glob2 if recursive and _isrecursive(basename) else glob1

    if not has_magic(pathname):
        if basename:
            if os.path.lexists(pathname):
                yield pathname
        else:
            # Patterns ending with a slash should match only directories
            if os.path.isdir(dirname):
                yield pathname
        return

    if not dirname:
        yield from glob_in_dir(dirname, basename)
        return
    # `os.path.split()` returns the argument itself as a dirname if it is a
    # drive or UNC path.  Prevent an infinite recursion if a drive or UNC path
    # contains magic characters (i.e. r'\\?\C:').
    if dirname != pathname and has_magic(dirname):
        dirs = _iglob(dirname, recursive)
    else:
        dirs = [dirname]
    if not has_magic(basename):
        glob_in_dir = glob0
    for dirname in dirs:
        for name in glob_in_dir(dirname, basename):
            yield os.path.join(dirname, name)


# These 2 helper functions non-recursively glob inside a literal directory.
# They return a list of basenames. `glob1` accepts a pattern while `glob0`
# takes a literal basename (so it only has to check for its existence).


def glob1(dirname, pattern):
    if not dirname:
        if isinstance(pattern, bytes):
            dirname = os.curdir.encode('ASCII')
        else:
            dirname = os.curdir
    try:
        names = os.listdir(dirname)
    except OSError:
        return []
    return fnmatch.filter(names, pattern)


def glob0(dirname, basename):
    if not basename:
        # `os.path.split()` returns an empty basename for paths ending with a
        # directory separator.  'q*x/' should match only directories.
        if os.path.isdir(dirname):
            return [basename]
    else:
        if os.path.lexists(os.path.join(dirname, basename)):
            return [basename]
    return []


# This helper function recursively yields relative pathnames inside a literal
# directory.


def glob2(dirname, pattern):
    assert _isrecursive(pattern)
    yield pattern[:0]
    for x in _rlistdir(dirname):
        yield x


# Recursively yields relative pathnames inside a literal directory.
def _rlistdir(dirname):
    if not dirname:
        if isinstance(dirname, bytes):
            dirname = os.curdir.encode('ASCII')
        else:
            dirname = os.curdir
    try:
        names = os.listdir(dirname)
    except os.error:
        return
    for x in names:
        yield x
        path = os.path.join(dirname, x) if dirname else x
        for y in _rlistdir(path):
            yield os.path.join(x, y)


magic_check = re.compile('([*?[])')
magic_check_bytes = re.compile(b'([*?[])')


def has_magic(s):
    if isinstance(s, bytes):
        match = magic_check_bytes.search(s)
    else:
        match = magic_check.search(s)
    return match is not None


def _isrecursive(pattern):
    if isinstance(pattern, bytes):
        return pattern == b'**'
    else:
        return pattern == '**'


def escape(pathname):
    """Escape all special characters.
    """
    # Escaping is done by wrapping any of "*?[" between square brackets.
    # Metacharacters do not work in the drive part and shouldn't be escaped.
    drive, pathname = os.path.splitdrive(pathname)
    if isinstance(pathname, bytes):
        pathname = magic_check_bytes.sub(br'[\1]', pathname)
    else:
        pathname = magic_check.sub(r'[\1]', pathname)
    return drive + pathname

import os
import sys
import tempfile
import operator
import functools
import itertools
import re
import contextlib
import pickle
import textwrap
import builtins

import pkg_resources
from distutils.errors import DistutilsError
from pkg_resources import working_set

if sys.platform.startswith('java'):
    import org.python.modules.posix.PosixModule as _os
else:
    _os = sys.modules[os.name]
try:
    _file = file
except NameError:
    _file = None
_open = open


__all__ = [
    "AbstractSandbox",
    "DirectorySandbox",
    "SandboxViolation",
    "run_setup",
]


def _execfile(filename, globals, locals=None):
    """
    Python 3 implementation of execfile.
    """
    mode = 'rb'
    with open(filename, mode) as stream:
        script = stream.read()
    if locals is None:
        locals = globals
    code = compile(script, filename, 'exec')
    exec(code, globals, locals)


@contextlib.contextmanager
def save_argv(repl=None):
    saved = sys.argv[:]
    if repl is not None:
        sys.argv[:] = repl
    try:
        yield saved
    finally:
        sys.argv[:] = saved


@contextlib.contextmanager
def save_path():
    saved = sys.path[:]
    try:
        yield saved
    finally:
        sys.path[:] = saved


@contextlib.contextmanager
def override_temp(replacement):
    """
    Monkey-patch tempfile.tempdir with replacement, ensuring it exists
    """
    os.makedirs(replacement, exist_ok=True)

    saved = tempfile.tempdir

    tempfile.tempdir = replacement

    try:
        yield
    finally:
        tempfile.tempdir = saved


@contextlib.contextmanager
def pushd(target):
    saved = os.getcwd()
    os.chdir(target)
    try:
        yield saved
    finally:
        os.chdir(saved)


class UnpickleableException(Exception):
    """
    An exception representing another Exception that could not be pickled.
    """

    @staticmethod
    def dump(type, exc):
        """
        Always return a dumped (pickled) type and exc. If exc can't be pickled,
        wrap it in UnpickleableException first.
        """
        try:
            return pickle.dumps(type), pickle.dumps(exc)
        except Exception:
            # get UnpickleableException inside the sandbox
            from setuptools.sandbox import UnpickleableException as cls

            return cls.dump(cls, cls(repr(exc)))


class ExceptionSaver:
    """
    A Context Manager that will save an exception, serialized, and restore it
    later.
    """

    def __enter__(self):
        return self

    def __exit__(self, type, exc, tb):
        if not exc:
            return

        # dump the exception
        self._saved = UnpickleableException.dump(type, exc)
        self._tb = tb

        # suppress the exception
        return True

    def resume(self):
        "restore and re-raise any exception"

        if '_saved' not in vars(self):
            return

        type, exc = map(pickle.loads, self._saved)
        raise exc.with_traceback(self._tb)


@contextlib.contextmanager
def save_modules():
    """
    Context in which imported modules are saved.

    Translates exceptions internal to the context into the equivalent exception
    outside the context.
    """
    saved = sys.modules.copy()
    with ExceptionSaver() as saved_exc:
        yield saved

    sys.modules.update(saved)
    # remove any modules imported since
    del_modules = (
        mod_name
        for mod_name in sys.modules
        if mod_name not in saved
        # exclude any encodings modules. See #285
        and not mod_name.startswith('encodings.')
    )
    _clear_modules(del_modules)

    saved_exc.resume()


def _clear_modules(module_names):
    for mod_name in list(module_names):
        del sys.modules[mod_name]


@contextlib.contextmanager
def save_pkg_resources_state():
    saved = pkg_resources.__getstate__()
    try:
        yield saved
    finally:
        pkg_resources.__setstate__(saved)


@contextlib.contextmanager
def setup_context(setup_dir):
    temp_dir = os.path.join(setup_dir, 'temp')
    with save_pkg_resources_state():
        with save_modules():
            with save_path():
                hide_setuptools()
                with save_argv():
                    with override_temp(temp_dir):
                        with pushd(setup_dir):
                            # ensure setuptools commands are available
                            __import__('setuptools')
                            yield


_MODULES_TO_HIDE = {
    'setuptools',
    'distutils',
    'pkg_resources',
    'Cython',
    '_distutils_hack',
}


def _needs_hiding(mod_name):
    """
    >>> _needs_hiding('setuptools')
    True
    >>> _needs_hiding('pkg_resources')
    True
    >>> _needs_hiding('setuptools_plugin')
    False
    >>> _needs_hiding('setuptools.__init__')
    True
    >>> _needs_hiding('distutils')
    True
    >>> _needs_hiding('os')
    False
    >>> _needs_hiding('Cython')
    True
    """
    base_module = mod_name.split('.', 1)[0]
    return base_module in _MODULES_TO_HIDE


def hide_setuptools():
    """
    Remove references to setuptools' modules from sys.modules to allow the
    invocation to import the most appropriate setuptools. This technique is
    necessary to avoid issues such as #315 where setuptools upgrading itself
    would fail to find a function declared in the metadata.
    """
    _distutils_hack = sys.modules.get('_distutils_hack', None)
    if _distutils_hack is not None:
        _distutils_hack.remove_shim()

    modules = filter(_needs_hiding, sys.modules)
    _clear_modules(modules)


def run_setup(setup_script, args):
    """Run a distutils setup script, sandboxed in its directory"""
    setup_dir = os.path.abspath(os.path.dirname(setup_script))
    with setup_context(setup_dir):
        try:
            sys.argv[:] = [setup_script] + list(args)
            sys.path.insert(0, setup_dir)
            # reset to include setup dir, w/clean callback list
            working_set.__init__()
            working_set.callbacks.append(lambda dist: dist.activate())

            with DirectorySandbox(setup_dir):
                ns = dict(__file__=setup_script, __name__='__main__')
                _execfile(setup_script, ns)
        except SystemExit as v:
            if v.args and v.args[0]:
                raise
            # Normal exit, just return


class AbstractSandbox:
    """Wrap 'os' module and 'open()' builtin for virtualizing setup scripts"""

    _active = False

    def __init__(self):
        self._attrs = [
            name
            for name in dir(_os)
            if not name.startswith('_') and hasattr(self, name)
        ]

    def _copy(self, source):
        for name in self._attrs:
            setattr(os, name, getattr(source, name))

    def __enter__(self):
        self._copy(self)
        if _file:
            builtins.file = self._file
        builtins.open = self._open
        self._active = True

    def __exit__(self, exc_type, exc_value, traceback):
        self._active = False
        if _file:
            builtins.file = _file
        builtins.open = _open
        self._copy(_os)

    def run(self, func):
        """Run 'func' under os sandboxing"""
        with self:
            return func()

    def _mk_dual_path_wrapper(name):
        original = getattr(_os, name)

        def wrap(self, src, dst, *args, **kw):
            if self._active:
                src, dst = self._remap_pair(name, src, dst, *args, **kw)
            return original(src, dst, *args, **kw)

        return wrap

    for name in ["rename", "link", "symlink"]:
        if hasattr(_os, name):
            locals()[name] = _mk_dual_path_wrapper(name)

    def _mk_single_path_wrapper(name, original=None):
        original = original or getattr(_os, name)

        def wrap(self, path, *args, **kw):
            if self._active:
                path = self._remap_input(name, path, *args, **kw)
            return original(path, *args, **kw)

        return wrap

    if _file:
        _file = _mk_single_path_wrapper('file', _file)
    _open = _mk_single_path_wrapper('open', _open)
    for name in [
        "stat",
        "listdir",
        "chdir",
        "open",
        "chmod",
        "chown",
        "mkdir",
        "remove",
        "unlink",
        "rmdir",
        "utime",
        "lchown",
        "chroot",
        "lstat",
        "startfile",
        "mkfifo",
        "mknod",
        "pathconf",
        "access",
    ]:
        if hasattr(_os, name):
            locals()[name] = _mk_single_path_wrapper(name)

    def _mk_single_with_return(name):
        original = getattr(_os, name)

        def wrap(self, path, *args, **kw):
            if self._active:
                path = self._remap_input(name, path, *args, **kw)
                return self._remap_output(name, original(path, *args, **kw))
            return original(path, *args, **kw)

        return wrap

    for name in ['readlink', 'tempnam']:
        if hasattr(_os, name):
            locals()[name] = _mk_single_with_return(name)

    def _mk_query(name):
        original = getattr(_os, name)

        def wrap(self, *args, **kw):
            retval = original(*args, **kw)
            if self._active:
                return self._remap_output(name, retval)
            return retval

        return wrap

    for name in ['getcwd', 'tmpnam']:
        if hasattr(_os, name):
            locals()[name] = _mk_query(name)

    def _validate_path(self, path):
        """Called to remap or validate any path, whether input or output"""
        return path

    def _remap_input(self, operation, path, *args, **kw):
        """Called for path inputs"""
        return self._validate_path(path)

    def _remap_output(self, operation, path):
        """Called for path outputs"""
        return self._validate_path(path)

    def _remap_pair(self, operation, src, dst, *args, **kw):
        """Called for path pairs like rename, link, and symlink operations"""
        return (
            self._remap_input(operation + '-from', src, *args, **kw),
            self._remap_input(operation + '-to', dst, *args, **kw),
        )


if hasattr(os, 'devnull'):
    _EXCEPTIONS = [os.devnull]
else:
    _EXCEPTIONS = []


class DirectorySandbox(AbstractSandbox):
    """Restrict operations to a single subdirectory - pseudo-chroot"""

    write_ops = dict.fromkeys(
        [
            "open",
            "chmod",
            "chown",
            "mkdir",
            "remove",
            "unlink",
            "rmdir",
            "utime",
            "lchown",
            "chroot",
            "mkfifo",
            "mknod",
            "tempnam",
        ]
    )

    _exception_patterns = []
    "exempt writing to paths that match the pattern"

    def __init__(self, sandbox, exceptions=_EXCEPTIONS):
        self._sandbox = os.path.normcase(os.path.realpath(sandbox))
        self._prefix = os.path.join(self._sandbox, '')
        self._exceptions = [
            os.path.normcase(os.path.realpath(path)) for path in exceptions
        ]
        AbstractSandbox.__init__(self)

    def _violation(self, operation, *args, **kw):
        from setuptools.sandbox import SandboxViolation

        raise SandboxViolation(operation, args, kw)

    if _file:

        def _file(self, path, mode='r', *args, **kw):
            if mode not in ('r', 'rt', 'rb', 'rU', 'U') and not self._ok(path):
                self._violation("file", path, mode, *args, **kw)
            return _file(path, mode, *args, **kw)

    def _open(self, path, mode='r', *args, **kw):
        if mode not in ('r', 'rt', 'rb', 'rU', 'U') and not self._ok(path):
            self._violation("open", path, mode, *args, **kw)
        return _open(path, mode, *args, **kw)

    def tmpnam(self):
        self._violation("tmpnam")

    def _ok(self, path):
        active = self._active
        try:
            self._active = False
            realpath = os.path.normcase(os.path.realpath(path))
            return (
                self._exempted(realpath)
                or realpath == self._sandbox
                or realpath.startswith(self._prefix)
            )
        finally:
            self._active = active

    def _exempted(self, filepath):
        start_matches = (
            filepath.startswith(exception) for exception in self._exceptions
        )
        pattern_matches = (
            re.match(pattern, filepath) for pattern in self._exception_patterns
        )
        candidates = itertools.chain(start_matches, pattern_matches)
        return any(candidates)

    def _remap_input(self, operation, path, *args, **kw):
        """Called for path inputs"""
        if operation in self.write_ops and not self._ok(path):
            self._violation(operation, os.path.realpath(path), *args, **kw)
        return path

    def _remap_pair(self, operation, src, dst, *args, **kw):
        """Called for path pairs like rename, link, and symlink operations"""
        if not self._ok(src) or not self._ok(dst):
            self._violation(operation, src, dst, *args, **kw)
        return (src, dst)

    def open(self, file, flags, mode=0o777, *args, **kw):
        """Called for low-level os.open()"""
        if flags & WRITE_FLAGS and not self._ok(file):
            self._violation("os.open", file, flags, mode, *args, **kw)
        return _os.open(file, flags, mode, *args, **kw)


WRITE_FLAGS = functools.reduce(
    operator.or_,
    [
        getattr(_os, a, 0)
        for a in "O_WRONLY O_RDWR O_APPEND O_CREAT O_TRUNC O_TEMPORARY".split()
    ],
)


class SandboxViolation(DistutilsError):
    """A setup script attempted to modify the filesystem outside the sandbox"""

    tmpl = textwrap.dedent(
        """
        SandboxViolation: {cmd}{args!r} {kwargs}

        The package setup script has attempted to modify files on your system
        that are not within the EasyInstall build area, and has been aborted.

        This package cannot be safely installed by EasyInstall, and may not
        support alternate installation locations even if you run its setup
        script by hand.  Please inform the package's author and the EasyInstall
        maintainers to find out if a fix or workaround is available.
        """
    ).lstrip()

    def __str__(self):
        cmd, args, kwargs = self.args
        return self.tmpl.format(**locals())

import importlib

try:
    import importlib.util
except ImportError:
    pass


try:
    module_from_spec = importlib.util.module_from_spec
except AttributeError:
    def module_from_spec(spec):
        return spec.loader.load_module(spec.name)

# EASY-INSTALL-SCRIPT: %(spec)r,%(script_name)r
__requires__ = %(spec)r
__import__('pkg_resources').run_script(%(spec)r, %(script_name)r)

"""
Launch the Python script on the command line after
setuptools is bootstrapped via import.
"""

# Note that setuptools gets imported implicitly by the
# invocation of this script using python -m setuptools.launch

import tokenize
import sys


def run():
    """
    Run the script in sys.argv[1] as if it had
    been invoked naturally.
    """
    __builtins__
    script_name = sys.argv[1]
    namespace = dict(
        __file__=script_name,
        __name__='__main__',
        __doc__=None,
    )
    sys.argv[:] = sys.argv[1:]

    open_ = getattr(tokenize, 'open', open)
    with open_(script_name) as fid:
        script = fid.read()
    norm_script = script.replace('\\r\\n', '\\n')
    code = compile(norm_script, script_name, 'exec')
    exec(code, namespace)


if __name__ == '__main__':
    run()

import re
import functools
import distutils.core
import distutils.errors
import distutils.extension

from .monkey import get_unpatched


def _have_cython():
    """
    Return True if Cython can be imported.
    """
    cython_impl = 'Cython.Distutils.build_ext'
    try:
        # from (cython_impl) import build_ext
        __import__(cython_impl, fromlist=['build_ext']).build_ext
        return True
    except Exception:
        pass
    return False


# for compatibility
have_pyrex = _have_cython

_Extension = get_unpatched(distutils.core.Extension)


class Extension(_Extension):
    """Extension that uses '.c' files in place of '.pyx' files"""

    def __init__(self, name, sources, *args, **kw):
        # The *args is needed for compatibility as calls may use positional
        # arguments. py_limited_api may be set only via keyword.
        self.py_limited_api = kw.pop("py_limited_api", False)
        _Extension.__init__(self, name, sources, *args, **kw)

    def _convert_pyx_sources_to_lang(self):
        """
        Replace sources with .pyx extensions to sources with the target
        language extension. This mechanism allows language authors to supply
        pre-converted sources but to prefer the .pyx sources.
        """
        if _have_cython():
            # the build has Cython, so allow it to compile the .pyx files
            return
        lang = self.language or ''
        target_ext = '.cpp' if lang.lower() == 'c++' else '.c'
        sub = functools.partial(re.sub, '.pyx$', target_ext)
        self.sources = list(map(sub, self.sources))


class Library(Extension):
    """Just like a regular Extension, but built as a library instead"""

import unicodedata
import sys


# HFS Plus uses decomposed UTF-8
def decompose(path):
    if isinstance(path, str):
        return unicodedata.normalize('NFD', path)
    try:
        path = path.decode('utf-8')
        path = unicodedata.normalize('NFD', path)
        path = path.encode('utf-8')
    except UnicodeError:
        pass  # Not UTF-8
    return path


def filesys_decode(path):
    """
    Ensure that the given path is decoded,
    NONE when no expected encoding works
    """

    if isinstance(path, str):
        return path

    fs_enc = sys.getfilesystemencoding() or 'utf-8'
    candidates = fs_enc, 'utf-8'

    for enc in candidates:
        try:
            return path.decode(enc)
        except UnicodeDecodeError:
            continue


def try_encode(string, enc):
    "turn unicode encoding into a functional routine"
    try:
        return string.encode(enc)
    except UnicodeEncodeError:
        return None

"""
Monkey patching of distutils.
"""

import sys
import distutils.filelist
import platform
import types
import functools
from importlib import import_module
import inspect

import setuptools

__all__ = []
"""
Everything is private. Contact the project team
if you think you need this functionality.
"""


def _get_mro(cls):
    """
    Returns the bases classes for cls sorted by the MRO.

    Works around an issue on Jython where inspect.getmro will not return all
    base classes if multiple classes share the same name. Instead, this
    function will return a tuple containing the class itself, and the contents
    of cls.__bases__. See https://github.com/pypa/setuptools/issues/1024.
    """
    if platform.python_implementation() == "Jython":
        return (cls,) + cls.__bases__
    return inspect.getmro(cls)


def get_unpatched(item):
    lookup = (
        get_unpatched_class if isinstance(item, type) else
        get_unpatched_function if isinstance(item, types.FunctionType) else
        lambda item: None
    )
    return lookup(item)


def get_unpatched_class(cls):
    """Protect against re-patching the distutils if reloaded

    Also ensures that no other distutils extension monkeypatched the distutils
    first.
    """
    external_bases = (
        cls
        for cls in _get_mro(cls)
        if not cls.__module__.startswith('setuptools')
    )
    base = next(external_bases)
    if not base.__module__.startswith('distutils'):
        msg = "distutils has already been patched by %r" % cls
        raise AssertionError(msg)
    return base


def patch_all():
    # we can't patch distutils.cmd, alas
    distutils.core.Command = setuptools.Command

    has_issue_12885 = sys.version_info <= (3, 5, 3)

    if has_issue_12885:
        # fix findall bug in distutils (http://bugs.python.org/issue12885)
        distutils.filelist.findall = setuptools.findall

    needs_warehouse = (
        sys.version_info < (2, 7, 13)
        or
        (3, 4) < sys.version_info < (3, 4, 6)
        or
        (3, 5) < sys.version_info <= (3, 5, 3)
    )

    if needs_warehouse:
        warehouse = 'https://upload.pypi.org/legacy/'
        distutils.config.PyPIRCCommand.DEFAULT_REPOSITORY = warehouse

    _patch_distribution_metadata()

    # Install Distribution throughout the distutils
    for module in distutils.dist, distutils.core, distutils.cmd:
        module.Distribution = setuptools.dist.Distribution

    # Install the patched Extension
    distutils.core.Extension = setuptools.extension.Extension
    distutils.extension.Extension = setuptools.extension.Extension
    if 'distutils.command.build_ext' in sys.modules:
        sys.modules['distutils.command.build_ext'].Extension = (
            setuptools.extension.Extension
        )

    patch_for_msvc_specialized_compiler()


def _patch_distribution_metadata():
    """Patch write_pkg_file and read_pkg_file for higher metadata standards"""
    for attr in ('write_pkg_file', 'read_pkg_file', 'get_metadata_version'):
        new_val = getattr(setuptools.dist, attr)
        setattr(distutils.dist.DistributionMetadata, attr, new_val)


def patch_func(replacement, target_mod, func_name):
    """
    Patch func_name in target_mod with replacement

    Important - original must be resolved by name to avoid
    patching an already patched function.
    """
    original = getattr(target_mod, func_name)

    # set the 'unpatched' attribute on the replacement to
    # point to the original.
    vars(replacement).setdefault('unpatched', original)

    # replace the function in the original module
    setattr(target_mod, func_name, replacement)


def get_unpatched_function(candidate):
    return getattr(candidate, 'unpatched')


def patch_for_msvc_specialized_compiler():
    """
    Patch functions in distutils to use standalone Microsoft Visual C++
    compilers.
    """
    # import late to avoid circular imports on Python < 3.5
    msvc = import_module('setuptools.msvc')

    if platform.system() != 'Windows':
        # Compilers only available on Microsoft Windows
        return

    def patch_params(mod_name, func_name):
        """
        Prepare the parameters for patch_func to patch indicated function.
        """
        repl_prefix = 'msvc9_' if 'msvc9' in mod_name else 'msvc14_'
        repl_name = repl_prefix + func_name.lstrip('_')
        repl = getattr(msvc, repl_name)
        mod = import_module(mod_name)
        if not hasattr(mod, func_name):
            raise ImportError(func_name)
        return repl, mod, func_name

    # Python 2.7 to 3.4
    msvc9 = functools.partial(patch_params, 'distutils.msvc9compiler')

    # Python 3.5+
    msvc14 = functools.partial(patch_params, 'distutils._msvccompiler')

    try:
        # Patch distutils.msvc9compiler
        patch_func(*msvc9('find_vcvarsall'))
        patch_func(*msvc9('query_vcvarsall'))
    except ImportError:
        pass

    try:
        # Patch distutils._msvccompiler._get_vc_env
        patch_func(*msvc14('_get_vc_env'))
    except ImportError:
        pass

    try:
        # Patch distutils._msvccompiler.gen_lib_options for Numpy
        patch_func(*msvc14('gen_lib_options'))
    except ImportError:
        pass

"""A PEP 517 interface to setuptools

Previously, when a user or a command line tool (let's call it a "frontend")
needed to make a request of setuptools to take a certain action, for
example, generating a list of installation requirements, the frontend would
would call "setup.py egg_info" or "setup.py bdist_wheel" on the command line.

PEP 517 defines a different method of interfacing with setuptools. Rather
than calling "setup.py" directly, the frontend should:

  1. Set the current directory to the directory with a setup.py file
  2. Import this module into a safe python interpreter (one in which
     setuptools can potentially set global variables or crash hard).
  3. Call one of the functions defined in PEP 517.

What each function does is defined in PEP 517. However, here is a "casual"
definition of the functions (this definition should not be relied on for
bug reports or API stability):

  - `build_wheel`: build a wheel in the folder and return the basename
  - `get_requires_for_build_wheel`: get the `setup_requires` to build
  - `prepare_metadata_for_build_wheel`: get the `install_requires`
  - `build_sdist`: build an sdist in the folder and return the basename
  - `get_requires_for_build_sdist`: get the `setup_requires` to build

Again, this is not a formal definition! Just a "taste" of the module.
"""

import io
import os
import sys
import tokenize
import shutil
import contextlib
import tempfile

import setuptools
import distutils

from pkg_resources import parse_requirements

__all__ = ['get_requires_for_build_sdist',
           'get_requires_for_build_wheel',
           'prepare_metadata_for_build_wheel',
           'build_wheel',
           'build_sdist',
           '__legacy__',
           'SetupRequirementsError']


class SetupRequirementsError(BaseException):
    def __init__(self, specifiers):
        self.specifiers = specifiers


class Distribution(setuptools.dist.Distribution):
    def fetch_build_eggs(self, specifiers):
        specifier_list = list(map(str, parse_requirements(specifiers)))

        raise SetupRequirementsError(specifier_list)

    @classmethod
    @contextlib.contextmanager
    def patch(cls):
        """
        Replace
        distutils.dist.Distribution with this class
        for the duration of this context.
        """
        orig = distutils.core.Distribution
        distutils.core.Distribution = cls
        try:
            yield
        finally:
            distutils.core.Distribution = orig


@contextlib.contextmanager
def no_install_setup_requires():
    """Temporarily disable installing setup_requires

    Under PEP 517, the backend reports build dependencies to the frontend,
    and the frontend is responsible for ensuring they're installed.
    So setuptools (acting as a backend) should not try to install them.
    """
    orig = setuptools._install_setup_requires
    setuptools._install_setup_requires = lambda attrs: None
    try:
        yield
    finally:
        setuptools._install_setup_requires = orig


def _get_immediate_subdirectories(a_dir):
    return [name for name in os.listdir(a_dir)
            if os.path.isdir(os.path.join(a_dir, name))]


def _file_with_extension(directory, extension):
    matching = (
        f for f in os.listdir(directory)
        if f.endswith(extension)
    )
    try:
        file, = matching
    except ValueError:
        raise ValueError(
            'No distribution was found. Ensure that `setup.py` '
            'is not empty and that it calls `setup()`.')
    return file


def _open_setup_script(setup_script):
    if not os.path.exists(setup_script):
        # Supply a default setup.py
        return io.StringIO(u"from setuptools import setup; setup()")

    return getattr(tokenize, 'open', open)(setup_script)


class _BuildMetaBackend(object):

    def _fix_config(self, config_settings):
        config_settings = config_settings or {}
        config_settings.setdefault('--global-option', [])
        return config_settings

    def _get_build_requires(self, config_settings, requirements):
        config_settings = self._fix_config(config_settings)

        sys.argv = sys.argv[:1] + ['egg_info'] + \
            config_settings["--global-option"]
        try:
            with Distribution.patch():
                self.run_setup()
        except SetupRequirementsError as e:
            requirements += e.specifiers

        return requirements

    def run_setup(self, setup_script='setup.py'):
        # Note that we can reuse our build directory between calls
        # Correctness comes first, then optimization later
        __file__ = setup_script
        __name__ = '__main__'

        with _open_setup_script(__file__) as f:
            code = f.read().replace(r'\r\n', r'\n')

        exec(compile(code, __file__, 'exec'), locals())

    def get_requires_for_build_wheel(self, config_settings=None):
        config_settings = self._fix_config(config_settings)
        return self._get_build_requires(
            config_settings, requirements=['wheel'])

    def get_requires_for_build_sdist(self, config_settings=None):
        config_settings = self._fix_config(config_settings)
        return self._get_build_requires(config_settings, requirements=[])

    def prepare_metadata_for_build_wheel(self, metadata_directory,
                                         config_settings=None):
        sys.argv = sys.argv[:1] + [
            'dist_info', '--egg-base', metadata_directory]
        with no_install_setup_requires():
            self.run_setup()

        dist_info_directory = metadata_directory
        while True:
            dist_infos = [f for f in os.listdir(dist_info_directory)
                          if f.endswith('.dist-info')]

            if (
                len(dist_infos) == 0 and
                len(_get_immediate_subdirectories(dist_info_directory)) == 1
            ):

                dist_info_directory = os.path.join(
                    dist_info_directory, os.listdir(dist_info_directory)[0])
                continue

            assert len(dist_infos) == 1
            break

        # PEP 517 requires that the .dist-info directory be placed in the
        # metadata_directory. To comply, we MUST copy the directory to the root
        if dist_info_directory != metadata_directory:
            shutil.move(
                os.path.join(dist_info_directory, dist_infos[0]),
                metadata_directory)
            shutil.rmtree(dist_info_directory, ignore_errors=True)

        return dist_infos[0]

    def _build_with_temp_dir(self, setup_command, result_extension,
                             result_directory, config_settings):
        config_settings = self._fix_config(config_settings)
        result_directory = os.path.abspath(result_directory)

        # Build in a temporary directory, then copy to the target.
        os.makedirs(result_directory, exist_ok=True)
        with tempfile.TemporaryDirectory(dir=result_directory) as tmp_dist_dir:
            sys.argv = (sys.argv[:1] + setup_command +
                        ['--dist-dir', tmp_dist_dir] +
                        config_settings["--global-option"])
            with no_install_setup_requires():
                self.run_setup()

            result_basename = _file_with_extension(
                tmp_dist_dir, result_extension)
            result_path = os.path.join(result_directory, result_basename)
            if os.path.exists(result_path):
                # os.rename will fail overwriting on non-Unix.
                os.remove(result_path)
            os.rename(os.path.join(tmp_dist_dir, result_basename), result_path)

        return result_basename

    def build_wheel(self, wheel_directory, config_settings=None,
                    metadata_directory=None):
        return self._build_with_temp_dir(['bdist_wheel'], '.whl',
                                         wheel_directory, config_settings)

    def build_sdist(self, sdist_directory, config_settings=None):
        return self._build_with_temp_dir(['sdist', '--formats', 'gztar'],
                                         '.tar.gz', sdist_directory,
                                         config_settings)


class _BuildMetaLegacyBackend(_BuildMetaBackend):
    """Compatibility backend for setuptools

    This is a version of setuptools.build_meta that endeavors
    to maintain backwards
    compatibility with pre-PEP 517 modes of invocation. It
    exists as a temporary
    bridge between the old packaging mechanism and the new
    packaging mechanism,
    and will eventually be removed.
    """
    def run_setup(self, setup_script='setup.py'):
        # In order to maintain compatibility with scripts assuming that
        # the setup.py script is in a directory on the PYTHONPATH, inject
        # '' into sys.path. (pypa/setuptools#1642)
        sys_path = list(sys.path)           # Save the original path

        script_dir = os.path.dirname(os.path.abspath(setup_script))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)

        # Some setup.py scripts (e.g. in pygame and numpy) use sys.argv[0] to
        # get the directory of the source code. They expect it to refer to the
        # setup.py script.
        sys_argv_0 = sys.argv[0]
        sys.argv[0] = setup_script

        try:
            super(_BuildMetaLegacyBackend,
                  self).run_setup(setup_script=setup_script)
        finally:
            # While PEP 517 frontends should be calling each hook in a fresh
            # subprocess according to the standard (and thus it should not be
            # strictly necessary to restore the old sys.path), we'll restore
            # the original path so that the path manipulation does not persist
            # within the hook after run_setup is called.
            sys.path[:] = sys_path
            sys.argv[0] = sys_argv_0


# The primary backend
_BACKEND = _BuildMetaBackend()

get_requires_for_build_wheel = _BACKEND.get_requires_for_build_wheel
get_requires_for_build_sdist = _BACKEND.get_requires_for_build_sdist
prepare_metadata_for_build_wheel = _BACKEND.prepare_metadata_for_build_wheel
build_wheel = _BACKEND.build_wheel
build_sdist = _BACKEND.build_sdist


# The legacy backend
__legacy__ = _BuildMetaLegacyBackend()

MZ                @                                       	!L!This program cannot be run in DOS mode.

$       YSj292929:92929F29}929`9929`929`9m29`929Rich29                PE  L Q         	     N      %          @                      @                                     ,  (                                                                     @              @                          .text   ]                          `.rdata  `       "                 @  @.data   +                      @                                                                                                                                                                                                                                                                                                                                                                                                                                                  QD$P@uSUV+WD-jPs
  33D$ "p~W    L$<\uG <"u~Wj\V
  3\F3T$CF;|~Wj\VV
  D$_"F ^][Y  A 3$  V$  W$  td$ A</uA\u$  P$  QT$RD$PW
  |$    |$\   $  Q$  RD$PL$QV^
  D$ P@u+|\Du
H8\td$ T$;r	  H8\uj WD$PL$Q$  R
  jh    h  $,  PV	  (jh    h  WV	  $  _^3
    SUVW|$P@u+jP  l$(3D$] 8P\$
  tOGQ
  uGL$tgRm
  t|$ tLD$<\uC<"uu39D$D$ D$tSj\VA  3|$ tL$FL$tSj\V  L$(3T$ E E F4t7R  tGGP  u? 6D$_^][_^][|$ u  A t	j P @    X3jDPD$D$D$D$D$PD$    f  jh0@ D$D   @ D$\L$QT$Rj j j jj j Pj @ uh@   @P  3XT$L$jR
  A @ L$$PQ@ uh@ $XSUVW|$PI @u\$+   ;p~-$    D$x    @u+A;t||$jV(  Wh@ U{  P@u+   ;~:L$R/h@ PI  L$$PI @u+F;||_^][  A 3$  $   h   L$Qj D$@ D$P@u+DT$;vI 8.t  HL$;w  D$H$    H@u(@ 
,@ f0@ H
2@ VfPT$j RH
  u4D$Ph@ >  @P  F^$  3!	    Wh   $   QV  V,    $,  H@;st

t
uj$   h@ R  T
  t2@ 
@ @ $  @ $   $$  $(  L$Q$"  R0D$ D$$PV$|$uVh@    S\$U$,  +D$@jP  Wt$C   ;~L$ R#G;|D$$P   ;~L$RG;|$4   ]    [tED$t$PV$  Vh@   @Pn   _   ^$  3s    L$T$D$QRPP$,  _^3?    D$L$j PQjh@   3u3];;u ;      VVVVV     39u;t]S  YuC@uwS*  Ytt*A A A$u)tt*A A @$t      VVVVV)  M9uu#SL
  EPVuS  ESW
  E	   E  uL  Y A ;A Vj^u   ;};A jP   YY+A ujV5;A z   YY+A ujX^3 A +A  A |j^3A W*A t;tu1 BpA |_3^#  =0 A  tp!  5+A    YUVu A ;r"`A w+Q$  N   Y
 V@ ^]UE}P$  EH   Y]E P@ ]UE A ;r=`A w`+P#  Y] P@ ]UME}`Qh#  Y] P@ ]UQe VEPuuL$  u9Eta  t
X  M^T$L$ti3D$u   r=*A  te%  Wr1t+utt
uD$_D$L$W   VSt$   |$u   't+t/   uuatt7uD$[^_   t      uutu[^D$_t~3 tt,t   t   u     33t3uwD$[^_Uuuuuju %  ]UQQS3VW]9]t}M;u9]uq9]tj9]u9]u`9]tY9]u9] uO9] tH9]$u>9](u>u3@8tHF;w>:u5;t}   jujQ%&  Fu9](uE      ;tu3]8tUP%  YtF</t
<\t	<.uu~F8u;t%9]t+E9Ev}Puju%  }	E;tE;tJ;ErE9]t+E9E vEPujut%  9]$   +u9u(v#Vuju$R%     9]t+u9u wfE;t9]vE;t9]vE;t9] vE$;t9](v  9]uj^SSSSS0\  *9]uj"YVuju$  E$;t3_^[UM   #QuM#QMu#EQuPuu$];
A ux$  UEVF uc52  FHlHhN;
pA t
A Hpu.  F;A tF
A HpuD'  FF@puHpF
@F^] UuMfE   ~EPjuo4     MH} tMapU=$A  uE
`A A]j uYY]U S39]u  SSSSS      ME;tVEEEPSuEPEEB     MxEEPS`4  YY^[UQe S]u3   Wru{vnMEtR:QuMPt<:Qu7Pt&:Qu!Pt:QuE9}r?@IF@I<@I2@I(MEt:u@AE9]r3_[ 	+UW  W$@ u @   `  wt_]Um6  u4  5A q-  h   ]UhD@  @ th4@ P(@ tu]UuYu,@ j  Yj  YUVt;ur^]UVu3ut;ur^]U=+A  th+A 8  Yt
u+A YO7  h`@ hH@ YYuBhxY@ 6  @@ $D@ c=+A  Yth+A 7  Ytj jj +A 3]jh@   j  Ye 3C98 A    4 A E0 A }    5+A  ,  Y}tx5+A +  Yu}uu;rW+  9t;rJ6+  +  5+A +  5+A +  9}u9Et}}Eu}hp@ d@ _Yhx@ t@ OYE   } u(8 A j<  Yu3C} tj#  Y  Uj j u]Uj ju]jj j jjj V*  V);  V:  VK  V:  V:  Vl8  V7  V6  h#@ *  $A ^U=D A t\3  u1  h   'YY]jh0@   MZ  f9  @ u8< @   @ PE  u'  f9 @ ut @ v39 @ Me jV?  YujnY-  uj]Y=4  e 
  }j;Y0@ +A =  < A =  }jY:  }j	YjYtPY A  A P5 A 5 A  E} uP2Y.E	MPQ5  YYeEE} uP8EE  >  UVuVS  P?  YYt| ;u3@;u`3@ A F  uNSW<H A ?    u S	  YuFjFXFF
?~>^^N  3_@[3^]U} t'VuF   tV  ff & f Y^]A@ty t$IxQP-  YYu	UVMEM>t} ^]UG@SVt2 u,E+M}C>u  8*u?d} ^[]Ux  A 3ES]Vu3W}u#u5M      3PPPPP   t
`p
  F@u^V@
  YA tt*A A$utt*A @$g3;]
  C 
  , <XwX@ 333x@ jY;	  $2@ v	   tJt6t%HHtW	  K	  ?	  3	     $	  	  *u,;    k
D    *u&;    k
D{  ItUhtDltwc     T  ;luC   9  -   !  <6u{4uCC     <3u{2uCC  <d  <i  <o  <u  <x  <X  PP<  YYt"CM  d  y  S      AtHHtXHHtHH      @9   H       0           0  u
   u    ;uA      X  HHty+'HH    t0GPh   PP:  t   G   5  ;t;H;t4    t+       A P^8  Y  p    e  g4itqnt(o     ta   U77  / tff     @
        W  ugue   Y9~   ~?]  V  Yt
   3GPPSP5XA =   Y   t 9uPS5dA    YYYgu;uPS5`A   YYY;-u   CS   $sHH  '      iQ0   E   K t@tGGG@t3@t;|;s       u3 }      9~u!ut-RPSW7  09~NE+F   tat90tV0@>If90t@@;u+(;uA I8 t@;u+ \  @t2   t	-t	+t    ++uSj pvYtuWSj0. tf~bPjEPFPF5  u(9t M YuPY |tWSj  t   Yt t
`pM_^3[*@ (@ )@ y)@ )@ )@ *@ D+@ jThP@ e  3}EP@@ Ej@j ^Vu  YY;  *A 5*A    0@ @
x@$ @%
@&
x8@4 @
*A    ;rf9}
  E;   8X;E   ;|E   [j@j   YYtVM*A *A     *@ @
` `$@%
@&
`8 @4 @;rE9=*A |=*A e ~mEtVtQtKuQ<@ t<u4*A E Fh  FP*  YY   FECE9}|35*A ttNrFujX
HP8@ tCt?W<@ t4>%   uN@	uNh  FP)  YYt7F
N@Cg5*A 4@ 33@eEc  UEV3;u  VVVVV    E  @^]UEP A ]U(  A 3E SjLj P(0,ffffffEM0  I    X@ j T@ (PP@ uuj1  Yh L@ PH@ M3[(U5P A &  Yt]j1  Y]UE3;A tA-rHwj
X]A ]DjY;#]  u@A   uDA UVMQY0^]h7@ d5    D$l$l$+SVWA 1E3PeuEEEEd    Md
    Y__^[]QUS]Vs35A WE E   {t
N38NF38E@f  MUS[EMt_I [LDE Et$1  E|@GEu} t$t
N38VNV3:FE_^[]E    M9csmu)=*A  t h*A !  tUjR*A M0  E9XthA W0  EMHt
N38NV3:EH]0  9SRhA Wu0  UVW3u0  Yu'9T A vV$@   ;T A vu_^]UVW3j uuE  u'9T A vV$@   ;T A vu_^]UVW3uu0  YYu,9Et'9T A vV$@   ;T A vu_^]UVW3uuu2  u,9Et'9T A vV$@   ;T A vu_^]jhp@ utu=*A uCj  Ye V2  YEt	VP2  YYE   } u7u
j  YVj 5t)A `@ u \@ PYjh@ I3]j  Y]j_};=;A }W+A 9tD @tPj=  YtE|(+A  PD@ +A 4Y+A GE	   Ej7  YUSVuF3u@  t9FW>+~,WPVeYPD  ;uFyFN _Ff ^[]UVuu	V5   Y/V|YtF @  tVPD  YY3^]jh@ 3}}jD  Y}3u;5;A    +A 98t^ @tVPVDYY3BU+A Ht/9UuPJYtE9}utP/Yu	E}   F3u+A 4VMYYE   }EtE{j   YjYVW3X A <LA uHA 8h  0}!  YYtF$|3@_^$HA  3SD@ VHA W>t~t
WW& YhA |HA _t	~uPhA |^[UE4HA @ ]jh@ ^3G}39t)A u  j  h   YYu4HA 9tnj	Y;u    3Qj
Y   Y]9u,h  Wt   YYuWY    ]>WYE	   Ej
(YUEV4HA > uP"YujtY6@ ^]jh@ hM3;v.jX3;E@u    WWWWW3   Mu;u3F3]wi=*A uKuE;p*A w7jLY}u5  YEE_   ];tuWS6;uaVj5t)A d@ ;uL9=)A t3V  YrE;P    E3ujY;u
E;t    U}}Mf$    ffGfG fG0fG@fGPfG`fGp   Iu}]U}E3+3+u<MU;t+QPsEUtEE+E3}ME.}3}MEMU+Rj Q~E}]jh@ de f(E   #E  =  t
=  t33@ee EEfU3SEEESX5    PZ+tQ3E]UM   UE[E   t\t3@3[*A 3UQSVu3W;t9]w IjYSSSSS   E3;t :tj_9}   F:FM;t@8t<}UG};syF@8uPQ@   YY</t<\tG;}sV\F}E;tG;}s>F@8uE;t':t!.tG;}s.FG;}sF@8uG;}vElj"3_^[UuMEMUTu} tM   A#E3t3@} tMapUjj uu]Ujj uj ]Uj uuuu?  ]U(  "A 
"A "A "A 5"A ="A f"A f
"A f"A f"A f%"A f-"A "A E "A E"A E"A  "A   "A !A !A 	 !A    A A X@ !A jO$  Yj T@ h@ P@ =!A  uj+$  Yh	 L@ PH@ -  t"t
tHt3        VWh  3FWP+3~~~~hA F+  @Ou     @Nu_^U  A 3ESWPvh@       3@;r t.;w+@P
j RhCCuj vvPWPjj E  3SvWPWPWvSB  DSvWPWPh   vSB  $3EtLtL      @;rV  3)  Z wL wL    A;rM_3[Ojh8@ 
  A Gptl twhuj Yj
Ye whu;5A t6tVp@ uhA tVYA Gh5A uVl@ E   uj
YUS3SM$A u$A    x@ 8]tEMap<u$A    t@ uE@$A    8]tE`p[U A 3ES]VuWd3};u3  u39A    E0=   r  p    d  P|@ R  EPWh@ 3  h  CVP3B{s9U   }    u   F   h  CVPAMk0uA u*Ft(>EA D;FG;v}FF> uuE}ur{C   gjCCA Zf1Af0A@@JuL@;vFF~ 4C   @IuCCSs3{95$A XM_^3[JjhX@ M  }_huuE;CW  h   YF     wh# SuYYE   uvhp@ uFh=hA tPcY^hS=l@ Fp   A    j
tYe C$A C$A C$A 3E}fLCfE$A @3E=  }
LA @3E=   }  A @5A p@ uA =hA tPYA SE   0j
Y%u hA tStY    e E=+A  ujVY+A    3USVu   3W;to=HA th   ;t^9uZ   ;t9uP   ;A  YY   ;t9uP   @  YY      YY   ;tD9u@   -   P      +P   +Pu   j   =A t9   uP>  7CYY~PE   A t;t9uPY9_tG;t9uPYMuVY_^[]USV5l@ W}W   tP   tP   tP   tP_PE   {A t	tP{ t
CtPMu      P_^[]UW}   SV5p@ W   tP   tP   tP   tP_PE   {A t	tP{ t
CtPMu      P^[_]t7t3V0;t(W8YtVE> YuA tVYY^3jhx@ c,  A Fpt"~l t  pluj -YvjYe Fl=pA iEE   j}YuUV5A 5@ t!A tP5A t  't@ V @ uVnYthd@ P(@ tuEE^]j YUV5A 5@ t!A tP5A t  't@ V @ uVYth@ P(@ tuEE^]@  V5A @ u5%A eYV5A @ ^A tP5%A ;Y
A A tP@ 
A jh@ t@ V @ uV4YEuF\@ 3G~t$hd@ P(@   h@ u  ~p   CK  CFhhA j
nYe vhl@ E>   jMY}EFlupA FlvlYE   	3Guj
5Yj,YVW\@ 5A uNh  jYYt:V5A 5%A Ytj VYY@ N	V^Y3W@ _^VujY^jh@ u   F$tPYF,tPYF4tPYF<tPYF@tPYFDtPYFHtPYF\=@ tPYj
Ye ~htWp@ uhA tWYEW   jYE   ~lt#WY;=pA tA t? uWYE   V'YI uj
vYujjYVWt@ V @ uVY^  5(@ h@ Wh@ W%A h@ W%A h@ W%A =%A  5@ %A t=%A  t
=%A  tu$@ %A @ %A dO@ 5%A %A @ A    5%A P   5%A 5%A %A 5%A %A 5%A %A %A tehXQ@ 5%A =YA tHh  jYYt4V5A 5%A 
Ytj VYY@ N3@3_^USuM]C=   wE   Xu]}EPE%   PG  YYtEjE]E Y
3]E AEjppEPQEPEjP6   u8EtE`p3E#E} tMap[UQVuVwEFYu8 	   N /  @t
 "   S3t^   NFFF^]  u, ;t@;u
u  YuV?  YF  W   F>HN+I;N~WPu*  EM FyMtt*A A @ tjSSQ*>  #t%FM3GWEPum*  E9}t	N E%   _[^UQQS]VW33};A t	G}rw  jz@  Y4  ji@  Yu
=A      A  hp@   S %A W08  t
VVVVVh  9%A Vj =&A  @ u&hX@ h  V7  t3PPPPPV  @Y<v8Vz  ;j4(A hT@ +QP6  t3VVVVVQ3hP@ SW6  t
VVVVV-E4A SW5  t
VVVVVh  h(@ W=  2j8@ ;t$tj EP4A 6
  YP6S@ _^[j>  Ytj>  Yu=A uh   )h   YYUQSVW5+A 5+A }YY;   +CrwW>  CY;sH   ;s;rPusYYuG;r@Pu]YYt1P4Y+A uVY+A EY3_^[Vjj V+A +A ujX^& 3^jh@ ee uYEE	   EUuYH]V@ @ W;st;r_^V@ @ W;st;r_^VW3@A 6Y(r_^UMMZ  f9t3]A<8PE  u3  f9H]UEH<ASVq3WDv}H;r	X;r
B(;r3_^[]Ujh@ h7@ d    PSVWA 1E3PEd    eE    h  @ *tUE-  @ Ph  @ Pt;@$EMd
    Y_^[]E3=  eE3Md
    Y_^[]jh(@ W @xte 3@eE<  ph
[@ 'Y4(A UQQV`F  V\tA W}S99tk;rk;s99u3t
X]u3   u` 3@      N`MMN`H   
hA =lA ;}$k~\d9 =hA lA B;|] ~d=  u	Fd   ^=  u	Fd   N=  u	Fd   >=  u	Fd   .=  u	Fd   =  u	Fd   =  uFd   vdjY~d` QEYF`[_^UE8(A <(A @(A D(A ]UE
tA V9Ptku;rkM^;s9Pt3]5@(A Yj hH@ J3}}]LtjY+t"+t+td+uDs}ua  8(A 8(A `w\]Zt<t+Ht    3PPPPP@(A @(A <(A <(A 
D(A D(A E   PEY3}   9Euj9EtPY3Et
tuO`MG`u@OdMGd   u.
hA M
lA hA 9M}MkW\DE~E   uwdSUY]}} tj TYSUYt
tuEG`uEGd3UEL(A ]UEX(A ]UE\(A ]jhh@ me uu@ E/E  E3=  e}  uj@ e EE_UE`(A ]U5`(A |YtuYt3@]3]UE 8csmu*xu$@= t=!t="t= @uC3] h_@ T@ 3=+A  uHV5< A W3u   <=tGV  YtujGWYY= A t5< A SBVR  C>=Yt1jSRYYtNVSP|.  t3PPPPP"> u5< A %< A  ' +A    3Y[_^5 A % A  UQMS3VU   9Et	]EE>"u39E"FE<tBUPFYt} t
MEFUMt2} u t	utB e >    < t<	uFN>    } t	EE3C3FA>\t>"u&u} tF8"u
339EEtIt\BuUtU} u< tK<	tGt=Pt#9Yt
MEFME
YtFUFVt BUME^[t  US3VW9+A uh  h(A VSl)A @ +A 5( A ;tE8uuUEPSS}
E=?sJMsB;r6PY;t)UEPWV}EH A 5 A 3_^[Up)A SV5@ W33;u.;tp)A    #\@ xu
jXp)A p)A    ;u;u3   f9t@@f9u@@f9u5@ SSS+S@PWSSEE;t/PYE;t!SSuPuWSSuuY]]W@ \t;u@ ;r8t
@8u@8u+@PEBY;uV@ EuVW+  V@ _^[U39Ej h   P@ t)A u]3@*A ]UA e e SWN@  ;t
t	A `VEP@ u3u@ 3@ 3@ 3EP@ E3E3;uO@u5A 5A ^_[UEu 	   3]V3;|;*A rVVVVV 	   n3*A D@^]A 39x)A L$   t$tN   u    $    $    ~3 tAt2t$   t   tAL$+AL$+AL$+AL$+USVu3W};u;vE;t3   E;tvj^SSSSS0PVuMsE9X   fE   f;v6;t;vWSV8t *   i 8]tMap_^[;t2;w,Ij"^SSSSS08]yE`pmE;t    8]%E`pMQSWVjMQS]p@ ;t9]^M;t\@ zD;g;_WSVaOUj uuuu|]UuM:EM   A%   } tMapUj uYY]VD$u(L$D$3D$d$d$G\$T$D$ud$D$r;T$wr;D$v	N+D$T$3+D$T$ ^ %*A  SVWT$D$L$URPQQh i@ d5    A 3D$d%    D$0XL$,3pt;T$4t;v.4v\H{ uh  C1     C1  d    _^[L$A      t3D$H3Uhppp>]D$T$   UL$)qqq(] UVWS33333[_^]j_0  33333USVWj j hi@ QQ  _^[]Ul$RQt$] jh@ e u;5p*A w"jYe Va  YEE	   EjYUVu   SW=d@ =t)A  ujh   MYY*A ut3@PuVSYuuFVj 5t)A u.j^9)A tuYtu{N0G0_[V{Y3    3^]jh@ h]uuY  uuScY  =*A   3}  jwY}S6  YE;   ;5p*A wIVSP  t]5V	  YE;t'CH;rPSu:$  S  ESP  9}uH;u3FuuVW5t)A d@ E;t CH;rPSu#  Su  E.   } u1uFuVSj 5t)A @ u]jY}   9=)A t,VY9}ul\@ P_Y_   9}th    quFVSj 5t)A @ uV9)A t4VYtvVYC    30|u"\@ PYUMS3;v(j3X;EsSSSSS    u3AMVW9]tu)  YVuYYt;s+Vj SX_^[]U
h*A l*A kU+P   r	;r3]UMAVuW+yi  D  MIM  S1UVUU]utJ?vj?ZK;KuB    sL!\D	u#M!JL!   	uM!Y]S[MMZUZRSMJ?vj?Z]]   +u]j?uK^;vMJM;v;t^Mq;qu;    s!tDLu!M!1K!   LuM!qMqINMqINu]} u;   MYN^qNqN;Nu`LML s%} u   M	   DD	)} uJ   M	YJ      	ED0E   |)A    
|*A 5@ h @  H   SQ
|*A |)A    	P|)A @
|*A     |)A @HC|)A HyC u	`|)A xueSj p|)A pj 5t)A `@ 
h*A |)A kl*A +LQHQP+  E
h*A ;|)A vml*A t*A E|)A =|*A [_^x*A V5h*A W3;u4kP5l*A W5t)A @ ;u3xx*A 5h*A l*A k5l*A hA  j5t)A d@ F;tjh    h   W@ F;uvW5t)A `@ N>~h*A F_^UQQMASVqW3C}i  0D  j?EZ@@Jujh   yh   W@ u    p  U;wC+GAH    @  P       IuUE  OHAJHAdD 3G   FCENCu	x   !P_^[UMASVuW}+Qi  D  MOI;|9M]U  E  ;;  MIM?vj?YM_;_uC    sML!\D	u&M!ML!   	uM!YO_YOyM+M}    }MOL1?vj?_]][Y]YKYKY;YuWLML s} u   M	DD } uO   M	Y   O   	UMD2LUFBD2<  38  /  ])uNK\3uN]K?vj?^E   uN?vj?^O;OuB    st!\Du#M!NL!   	uM!Y]OwqwOquuuN?vj?^MyK{YKYK;KuWLML s} u   M	9DD } uN   M	y   N   	ED3@_^[Uh*A Mkl*A MSI VW}M
3U
t*A S;#U#u
];r;ul*A S;#U#u
];r;u[{ u
];r;u1l*A 	{ u
];r;u]u3	  S:YKC8tt*A CUt   |D#M#u)e    HD9#U#uE   Ui  D  MLD3#u   #Mj _G}MT
+MN?M~j?^;  J;Ju\    }&M|8]#\D\Du3M]!,OM   |8!]u]M!K]} JzyJzy   MyJzQJQJ;Ju^LM L}#} u   	;   M	|D)} u
N   	{M   N   	7Mt
LMuN
L2uy>u;|)A uM;
|*A u%|)A  MB_^[USVuW3;uWWWWW    =BFt7V(V(  VP'  }F;t
PY~~_^[]jh@ M3u3;;u2    WWWWWF@t~EVY}V*YEE   uVYU  8*  A 3EEV34809uu3  ;u'0VVVVV      SW}4*A X$('tu0Mu&?30#VVVVV    C  @ tjj j uc  uY  D  @l39HP4 @ `  39 tP  @ 43<9EB  D'g  (3
 x8 tP4UM`8 jEPKPYt:4+M3@;  j@SP<(    CDjS@P(    3PPjMQj@QPCD@ \  j <PVEP( 4@ )  D09<8       j <PjEP( E
4@   <  08   <t<u!33f
CCD@ <t<uR@%%  Yf;@h  8  t)j
XP@$  Yf;@;  80E9D'  8T4D8  3@  4@   <9M   (<D +4H;Ms9<<A
u0 
@D@DD  rH+j ,PSHP4@ B  ,8;:  <+4;EL   D   9MM  (D< +4H;MsFDDAAf
u0j
[f@@<<f@@<  rH+j ,PSHP4@ b  ,8;Z  D+4;E?@  9M|  D< +4jH^;Ms<DDf
uj
[f<<f<  r3VVhU
  QH++PPVh  @ ;   j ,P+P5P( 4@ t,;\@ @;\D+48;E
?j ,Qu40@ t,@ 8\@ @8 ul@ t-j^9@u 	   0?@"Y1(D@t48u3$      8+0_[M3^hjh@ Eu   	      3;|;*A r!y8_ 	   WWWWW*A L1tP9$  Y}D0tuuu.E 	   8ME	   Ehu$  Yjh@ Eu 	      3;|;*A r 	   SSSSS<*A LtPl#  Y]Dt1u"  YP@ u\@ E]9]t1M 	   ME	   Eu#  YUS39]uSSSSS    ^3jVu;uSSSSS    :9ur3>uMVMF9YtH9Ew
D
u++N8]tMap^[Uj uuU]US3Vu9]u;u9]u3  ;t9]w	j^SSSSS0  9]uW};uj^SSSSS0a(  uME9XuuWuV
  L  }Uu@G:tJu@G:tJtMu9]u@;   8t}u5x};rEPE P0YYtM9us+E   }uZEv:|};r!EPE PYYtM9usE+Mt\8]tE`pjPX   j"^SSSSS0@8]tE`pd+|Mx};rEPE PiYYtM9us+EtTj*X8]tMap8]tE`p3_^[UEt8  uPxY]UA 3ESV3W9)A u8SS3GWhd@ h   S@ t=)A \@ xu
)A    9]~"MEI8t@;uE+H;E}@E)A   ;    ]9] u@E 5@ 39]$SSuu   Pu ;  ~Cj3Xr7D?=   w#  ;t   PY;t	   E]9]>  Wuuuju    5@ SSWuuuM;   E   t)9]   ;M   uuWuuu   ;~Ej3Xr9D	=   w"  ;tj  PJY;t	   3;tAuVWuuu@ t"SS9]uSSuuuVSu @ EVYuEYY  ]]9]u@E9] u@E u    YEu3!  ;E    SSMQuPu >   E;t5@ SSuPuuE;u3   ~=w8=   w!  ;t  P4Y;t	   3;tuSWuWuuuuE;u3%uEuPWu u  u#uWYuuuuuu@ 9]t	uYE;t9EtPYe_^[M3'UuM!u(Mu$u uuuuu( } tMapUQQA 3E)A SV3W;u:EP3FVhd@ V@ t5)A 4\@ xu
jX)A )A    ;      ]9]u@E5@ 39] SSuu   Pu;   ~<w4D?=   w  ;t   PPY;t	   ti?Pj SWSuujutuPSu@ ESEYu39]u@E9]u@EuA  Yu3G;EtSSMQuPui  ;tuuuuuu@ ;tVYe_^[M3(UuM"u$Mu uuuuu} tMapUVu  vvvnvfv^vVvN6Gv ?v$7v(/v,'v0v4vv8v<@v@vDvHvLvPvTvXv\v`vdvhvlvpvtvxv||@   n   c   X   M   B   7   ,   !          ,^]UVut5;HA tPYF;LA tPYv;5PA tVY^]UVut~F;TA tPYF;XA tPYF;\A tPsYF;`A tPaYF;dA tPOYF ;hA tP=Yv$;5lA tV+Y^]UES3VW;t};wj^0SSSSS*<u;u8tBOu;t
BF:tOu;uZj"Y3_^[]UV3PPPPPPPPUI 
t	$uI 
t	$s ^USVu3W9]u;u9]u3_^[];t};wj^0SSSSSU9]uU;u}u
@B:tOu
@B:tOtMu9]u;u}uEjP\XxRj"YUMS3VW;t};w,j^0SSSSS0u;uBF:tOu;uj"Y3_^[]T$L$   u<:u.
t&:au%
t:Au
t:au
u3   t:u
t   tf:u
t:au
tUWVuM};v;     r=*A  tWV;^_u^_],     ur*$T@    r$h@ $d@ $@ x@ @ @ #FGFGr$T@ I #FGr$T@ #r$T@ I K@ 8@ 0@ (@  @ @ @ @ DDDDDDDDDDDDDD    $T@ d@ l@ x@ @ E^_E^_FGE^_I FGFGE^_t1|9   u$r
$@ $@ I    r+$@ $@ @ (@ P@ F#Gr$@ I F#GFGr$@ F#GFGFGV$@ I @ @ @ @ @ @ @ @ DDDDDDDDDDDDDD    $@  @ @ @ ,@ E^_FGE^_I FGFGE^_FGFGFGE^_UV3PPPPPPPPUI 
t	$u
t$sF ^UQQEVuEEWVE  Y;ui 	   JuMQuP @ E;u\@ t	P[Y*A D0 EU_^jh(@ OuuEu    	      3;|;*A r!8 	   WWWWWD*A L1u&8{ 	   WWWWW[Pp  Y}D0tuuuuEU- 	   58MME   EUu  YU A h   YMAt
IA   IAAA   Aa ]USVWbe =)A     h @ @ *  5(@ h@ W  P$@ W)A P$@ W)A P$@ W)A PmY)A th@ WPUY)A )A ;tO9)A tGP5)A YYt,t(tMQjMQjPtEu	M    9)A ;t0PcYt%Et)A ;tPFYtuE5)A .Ytuuuu3_^[UMV3;|~uD A (D A 
D A VVVVV    ^]jhH@ 93]3;;u    WWWWW`S=*A u8jUY}SYE;ts	uuE%   9}uSW5t)A @ 3]uj#YjYU(  A 3EA Vtj
3Y
tjYA    ffffffuE0  @jPj P:(0j   @,T@ (PP@ jUSVWUj j h@ uV"  ]_^[]L$A      t2D$H3UhP(RP$R   ]D$T$   SVWD$UPjh@ d5    A 3PD$d    D$(Xpt:|$,t;t$,v-4vL$H| uh  DI   D_   L$d
    _^[3d
    y@ uQR9Qu   SQA SQA L$KCkUQPXY]Y[ UVWuMEu3;t0;u,WWWWW    Y} tE`p3  9}t}|}$MS}~   ~EPjPeM   BtG-uM+uGEK  B  $9  u*0t	E
   4<xt
<Xt	E   !E   
u0u<xt<XuGG   3uNt0  t1aw ;MsM9Er'u;v!M} u#EOu } t}e []]]Guu=t	}   w	u+9uv&0E "   tMEj XEEt8Et]} tE`pEEt0} tE`p3[_^U3Puuu9$A uhxA P]UWVuM};v;     r=*A  tWV;^_u^_]|
     ur*$@    r$@ $@ $@ (@ T@ x@ #FGFGr$@ I #FGr$@ #r$@ I @ @ @ @ @ @ @ @ DDDDDDDDDDDDDD    $@ @ @ (@ <@ E^_E^_FGE^_I FGFGE^_t1|9   u$r
$@ $P@ I    r+$@ $@ @ @  @ F#Gr$@ I F#GFGr$@ F#GFGFGV$@ I T@ \@ d@ l@ t@ |@ @ @ DDDDDDDDDDDDDD    $@ @ @ @ @ E^_FGE^_I FGFGE^_FGFGFGE^_UVuWV  YtP*A u	   uu@Dtj  j  YY;tV}  YP@ u
\@ 3V  *A YD0 tWY3_^]jhh@ Eu  r 	      3;|;*A r!d8J 	   WWWWW*A L1tP$  Y}D0tuYE 	   ME	   Ebu}  YUVuFttvf3YFF^]UA 3EV395A tO=tA u
  tA u  pVMQjMQP@ ug=A u\@ xu5A VVjEPjEPV@ P@ 
tA tVURPEPQ@ tfEM3^|A    USVu3;t9]t8uE;t3f3^[uMd|E9XuE;tff8]tE`p3@EPPYYt}E   ~%9M| 39]RuQVj	p@ EuM;   r 8^t   8]eMapY *   8]tE`p:39]PuEjVj	p@ :Uj uuu]QL$+#% ;r
Y $-    UEVW|Y;*A sQ<*A <u5=A S]u tHtHuSjSjSj@ 3[ 	     _^]UMS3;VW|[;
*A sS<*A @t58t0=A u+tItIuSjSjSj@ 3w 	   _^[]UEuc  H 	   ]V3;|";*A s*A @u$"0VVVVV 	    ^]jh@ +}4*A E   39^u6j
XY]9^uh  FPoYYu]FE0   9]t*A D8P@ E3}j
YUE*A DP@ ]jh@ dM3}jYub  jY}}@<  4*A    u*A    ;   Fu\~ u9j
PY3C]~ uh  FPcYYu]Fe (   } u^S@ FtS@ @}uj
Y} uF+4*A u}uyG+j@j YYEta*A *A     ;s@ @
` @E}*A DWYuME	   E%jWYUA 3EjEPh  uE @ u
EP`  YM3wU4A 3EEMEESE VEEW3M}};E_  5h@ MQP@ t^}uXEPutK}uEuE   uu&YF;~[wSD6=   w/  ;t8   -WWuuju;u3   PxY;t	   E}9}t6PWuqVuuujut];tWWuSVuWu@ t`][@ 9}uWWWWVuWu;t<Vj\YYE;t+WWVPVuWu;uu%Y}}tMuwYEe_^[M3MuQL$+YQL$+YU}uu}M    fofoNfoV fo^0ffOfW f_0fof@fonPfov`fo~pfg@foPfw`fp      Iuu}]U}u]]E3+3+3+3+uJuM;t+VSP'EMtw]U+U+]u}MES;u5Mu}MMMUUE+EPRQLEu}ME]u}]Uj
j u]US3VW9]   uMs9]u.SSSSS    58]tE`p   };t9uv(nSSSSS    8]tE`p`E9XuuWu  8]tDMap;E MQPG  EMQP5  GMt;t;t+3_^[UV395$A u99uuVVVVV    T'9ut}w^]  Vuuu^]3PPjPjh   @hL@ @ tA tA V5@ ttPpA ttP^U=+A  V5 A u3cWu95  A tS  uJ5 A t@} t:uaY'PVY;v<8=uWuPn  tu3_^]D8jh@ jGY3u3];;uj_8VVVVV}   3E;t039u;tuYE;tXPGjWl;u)     E*uWP;t
VVVVVlE;t8uE	   EjjYUSVuMp]   ;sTM   ~EPjSM
   Xt      } tE`p   E   ~1]}EPE%   PYYtEjE]E Y *   3]E AEjpUjRQMQVpEP$oEt	M} tMap^[UWVSMtMu}AZ I &
t'
t#:r:w:r:w:uu3:t	r[^_USuMoM3;u8]tE`p3   9]u.SSSSS    8]tE`p   9]tV;vSSSSS    d?E9XuuQuu   6pQuQuh  pEP   ;u8]tE`p8]tMap^[Uj uuu]UQQSV3W=  A u;te@ VVVVjPVVE;tTjPYYE;tCVVuPj7VVt6EVP  YY}9utuAYu;u3_^[u YD$L$L$u	D$ SD$d$D$[ UMI8 t@uIE+H]U,A 3EESVW3]E9=`*A u8jd@ PjPWW$@ t`*A    \@ xu
`*A    9}~&uoYEU;~ER[YU}}3  |
`*A   ;  3@;u}9}uIM9}t;   9UujXu  ;m  9E~jEPuh@ t9}~)}r} EtPt:r:v@@8 u9}~8}s3@  } EtPtM	:r:t@@8 u5@ WWuSj	u];   ~@j3Xr4D;w&t   PYt	   Ee } Suuuju   j j uuj	ut{~Bj3Xr6D;wtZ  P!Yt	   3t1SWuujutSWuuuu$@ EWYuEY   339}u@E9}u@Eu	Y;utPj j EPuVu-j j EPuVuuSYk]}uuuuuu @ tSwWqYYe_^[M3iUuMiu$Uu Muuuu`} tMapUSuMiiU3;u8]tE`p3   9]u.vSSSSS    8]tE`p   9]tV;v9SSSSS    KEH;uEPRuu2?pERuRuh  QP ;u    8]tE`p8]tMap^[UV5 A !WPu9u
<=ttu+ A ^]+ A UQW3tF9t	@9 uV@jPYYuuj	jjPc  Yu!E^_UES3];uSSSSS    xnV0Wu;tSj=V  YY};t@;t<38_E A ; A u
5 A ;u`9]t$9  A t3tJu    _^[9]  jY A ;t9  A ujtY  A ;t5 A u;t+}ub;Y|R9tN46lY9]uEE   FEG49u?sjjW5 A ;tUN9]   ;}G;6=?+Pj5 A ;UYM A 9]txujV@Y@PYY;t\VV@Y@PWt
SSSSS|M+E@#QW(@ uM} *   WYY9]tuKEYEhu5EY3SUS39]u3AVWuFVYY;t"uVW@t
SSSSS{3_^[]USuM#eE3;u(H}SSSSS    |8]tE`p3tVu9^u:uP   YYAD2t@:t>9MuH9Ut
@ff;u9Mu8]tMap8]tE`p3^[Uj uu2]B[$    d$ 3D$ST$   t
:ttQ   uWV
~333 u% t% u   u^_[3B:t6t:t't:tt:tt^_B[B^_[B^_[B^_[%@ UUS3;u{SSSSS    4{ 8tM;t;t8tSQR  []UUVujXEU;uc{  H{ 	     S3;|;5*A r'9{{SSSSS 	   zQ  W<*A Huzz 	   jwP];    9]t7@$EHjYtHutUEE   u!zmz    SSSSSy4M;rEuz|YE;u5z    =z    h  jSSu|D(ET,AHttI
tl9]tg@ME   D
8]tNL%
tC9]t>@M}E   D%
u$L&
t9]t@ME   D&
SMQuP4,@ {  M;p  ;Mg  MD   }  ;t
M9
u ]E]E;   M<   <
tCAM   EH;sA8
u
AAM
uEmEj EPjEP4,@ u
\@ uE} t?DHt}
t
ML%;]u}
tjjju}
t
CE9EGD @uC+E}E      KxC   3@;]rK@A  tA u
w *   zA;u@AHt$CQ|	T%Cu	T&C+jRPuE+]PuSuj h  @ Eu4\@ PwYME;EtPzYE  E  E3;EL0;tMf9
u ]E]E;   Ef   f
tfCC@@E   M;sHf9
u
Ej
   M   Ej EPjEP4,@ u
\@ u[} tUDHt(f}
tj
XfMLML%D&
*;]uf}
tjjjuf}
tj
XfCCE9Et@uf fCC+]]\@ j^;uu 	   u0imY]\3_[^jh@ uEuu  u 	      3;|;*A r!u0fu 	   VVVVVt*A L9t;MAu2u0u    PYuD8tuuu~Et 	   t0ME	   ENuuiYU0S3EVW]]E   ]t	]E
E   ]EP
  Yt
SSSSSrM   u @ u9EtM+      tGHt.Ht&7ttj^SSSSS0s   Ut   uE   @}EjY+t7+t*+t+t@u9}EE   E   E   ]E   #   ;   ;t0;t,;t=      =   @E   /E   &E   =   t=   t`;E   EE   t
 A #MxE   @tM   M   M   t	} tM   E   tM   urr       E=@ Su    uEPuuuEumM   #;u+Et%eSuEuPuuuEu46*A D0 \@ P?rYr t  u<@ ;uD6*A D0 \@ VqYu@ ;uq 
   uM@	uMu64*A YYML*A D$ MeHM     EtqjW6  E;u:q8   tM6jEP6]u}uERP6  ;tSS6F  ;tE0   @  @  }uE#u	M	EE#;tD=   t)= @ t"=   t)= @ t"=   t= @ uEM  #;u	E]E     E@]  E   #=   @   =   tw;  E;y  vv0f  E3H&  HR  E  E     jSS68tSSS6'#jEP6/utk   } uYE   E;   bPjSS6CSSS6#   E%  =  u6Yoj^0d  =  uSj6X  EASS6=  E E   E+PD=P69}*A D$2M0*A D$M
8]u!Et*A D }   #;u|Etvu@ SuEjPuWu@ u4\@ Pm*A D 6Y6*A _^[jh@ mM3u39u;umm    VVVVVlruuj@uuEPEEE   };t<m839ut+9utEM*A D uYEomUQQV39uulVVVVV    QlJ9utuEPEPuu|  tuuujU  uouo^USW}3};u IlSSSSS    k  8tE;t ;t8tVj\W  j/W
  ;   ;   j:W=YY;usWIjVMn};   ht@ VWkt
SSSSSjuVWt
SSSSSiw}
;t;vMj.Vh  YYt,Su
  YY   uuu`E   ujVmE;u   uVPt
SSSSS`iuQ}Yj EE+EA E0VWrt
SSSSSiSu]	  YYtm}A }juMuuEum}Y9}t	umYE^_[USVW3jSSu]]E#UtYjSSuz#tAu}+   ;      Sj4@ Pd@ Eui    i _^[h   u  YYE|
;rPuut6+xwuuuF  YYuj 4@ P`@ 3   Wi8u:i 
   u;q|;skSuuu#DuYP0@ HE#Uu)h 
   h\@ u#uSuuu#3UVuV"Yuyh 	   MWuj uP @ u\@ 3tPihY*A D0 _^]US]Vu*A 0A$Wy    @  tP   tB   t&   t   u=I
L1$'I
L1$a
I
L1$!_^[u   ]%    @  ]UEV3;uNgVVVVV    fjX

d*A 3^]UhES3W]];tt~~	uEEE8gfSSSSS    of  @8uH8t  8uVjD^VESPdJu5*A ;t+F*A 8\uNH;u;@  23  4  kfEjPhYYE;  ;0EH|0]~9E*A Pu EA9u|E8]t,H3D0}j_;}BAE   eEPEPSuujSSuu@ \@ uhY;u	WeYX}uS4R5@ 9]uju@ EPu@ ]}uu]u(e    ^_[U@A 3EMESVWx@ }fMM3MMjE M]]]^P2tY;ujVu*guYY;u#Ed    d    /  EPESP;tuqSSSSSbbEPGGY}9]tuY}E;tOj _P|Y;u< A ;uC< A ;u5u6MRgEYe  E}6;   FU  ]8t(=tVYML< A 4M:uMM+8Xt-x:u'x=u!PYMD
< A E8=tE+Eu}EPPEP6  tM9u}jWeuYYM;26kfYb    cM    i  E   P+EPVt
SSSSS'a7t6PE +EPVIt
SSSSS`7 FY;uE^09]   }E+Q
< A QV+}}6EM7+PVt
SSSSSy`7kYt9u9]ug}EPWVt
SSSSS?`h`@ WVt
SSSSS`9]tuWVt
SSSSS_;tE;0uF< A ;tPdY< A 9]t	udYEM_^3[IUV39uu$Ba0(aVVVVV    `jXUEuu8@ u\@ PaY` (u"tEt`    ` 
   3^]USu3M]lHM;u(`SSSSS    `8]tE`p3qVu9^uuQj  YY8]tWMapNWD7t!A:t9EuAE
9]9EuMA:u_8]tE`pE^[Uj uu2]US39]u3  uMGE9Xu&uuu8]m  Mapa  W};t9]u._SSSSS    _8]tE`p%  VfMGDMtC:u]XfffGMf;prf;pwfp6f;pr0f;pw*fp$UAt
f  MfuMf	EDMtEU:u]WffEMf;Hrf;HwfH6f;Hr0f;Hw*fH$UAt
f  MfMf;u!f;t	9]8]tE`p3^_[H8]tMapUj uuu#]UW}3E8t3_                                                                                                                                                                                 4  L  `  h  z                    8  V  j  z                        (  8  N  Z  j                *  D  T  j                  
    ,  >  P  b  n  |                  (  8  J                  @ A@ 4K@ X@ _@         @ @                 failed to get exit code from process.
  failed to create process.
   %s %s  Could not exec %s   Cannot find Python executable %s
   #!python.exe    #!  Cannot open %s
 -script.py  CorExitProcess  m s c o r e e . d l l   ( n u l l )     (null)             EEE50 P    ( 8PX 700WP        `h````  xpxxxx          !A  "A     	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ =   EncodePointer   K E R N E L 3 2 . D L L     DecodePointer   FlsFree FlsSetValue FlsGetValue FlsAlloc    runtime error   
  TLOSS error
   SING error
    DOMAIN error
  R6034
An application has made an attempt to load the C runtime library incorrectly.
Please contact the application's support team for more information.
      R6033
- Attempt to use MSIL code from this assembly during native code initialization
This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain.
  R6032
- not enough space for locale information
      R6031
- Attempt to initialize the CRT more than once.
This indicates a bug in your application.
  R6030
- CRT not initialized
  R6028
- unable to initialize heap
    R6027
- not enough space for lowio initialization
    R6026
- not enough space for stdio initialization
    R6025
- pure virtual function call
   R6024
- not enough space for _onexit/atexit table
    R6019
- unable to open console device
    R6018
- unexpected heap error
    R6017
- unexpected multithread lock error
    R6016
- not enough space for thread data
 
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
   R6009
- not enough space for environment
 R6008
- not enough space for arguments
   R6002
- floating point support not loaded
    Microsoft Visual C++ Runtime Library    

  ... <program name unknown>  Runtime Error!

Program:                                                                                                    EEE  00P  ('8PW  700PP    (   `h`hhhxppwpp                                                                                                                                                                                                                                                                                             ( ( ( ( (                                     H                                                                                                                                                                                                                                                                                                                                                                                     h ( ( ( (                                     H                                                                                                             H                                       	

 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~HH:mm:ss    dddd, MMMM dd, yyyy MM/dd/yy    PM  AM  December    November    October September   August  July    June    April   March   February    January Dec Nov Oct Sep Aug Jul Jun May Apr Mar Feb Jan Saturday    Friday  Thursday    Wednesday   Tuesday Monday  Sunday  Sat Fri Thu Wed Tue Mon Sun GetProcessWindowStation GetUserObjectInformationA   GetLastActivePopup  GetActiveWindow MessageBoxA USER32.DLL  SunMonTueWedThuFriSat   JanFebMarAprMayJunJulAugSepOctNovDec    CONOUT$ .com    .exe    .bat    .cmd    .\  SystemRoot      H                                                           A @    7   i                                    @                 #@             %@ %@             <5@ @5@                 :@                 ;@                 ;=@         =@             >@                 ?@             A@ 9A@                 -G@                 J@                 kN@                 P@     P@             oR@     {R@             5Y@             Z@ Z@             -[@ 1[@                 ^@             _@ /_@                 )j@                 :l@                 >y@                 N@                 /@                 $@                 @                 T@                 @                 @         @             L@                 h@                 @ T                                                 4  L  `  h  z                    8  V  j  z                        (  8  N  Z  j                *  D  T  j                  
    ,  >  P  b  n  |                  (  8  J      RGenerateConsoleCtrlEvent  GetExitCodeProcess  nWaitForSingleObject  CreateProcessA  SetConsoleCtrlHandler GetModuleFileNameA   EnterCriticalSection  LeaveCriticalSection  GetModuleHandleW  +Sleep "GetProcAddress  ExitProcess pGetCommandLineA SetHandleCount  >GetStdHandle  GetFileType <GetStartupInfoA  DeleteCriticalSection 7TerminateProcess  GetCurrentProcess HUnhandledExceptionFilter  SetUnhandledExceptionFilter IsDebuggerPresent GetLastError  HeapFree  HeapAlloc \GetCPInfo InterlockedIncrement  InterlockedDecrement  SGetACP  GetOEMCP  IsValidCodePage >TlsGetValue <TlsAlloc  ?TlsSetValue =TlsFree SetLastError  GetCurrentThreadId  WriteFile LoadLibraryA  InitializeCriticalSectionAndSpinCount KFreeEnvironmentStringsA GetEnvironmentStrings LFreeEnvironmentStringsW WideCharToMultiByte GetEnvironmentStringsW  HeapCreate  aVirtualFree YQueryPerformanceCounter jGetTickCount  GetCurrentProcessId SGetSystemTimeAsFileTime RtlUnwind HeapReAlloc ^VirtualAlloc  GetConsoleCP  GetConsoleMode  BFlushFileBuffers  LCMapStringA  MultiByteToWideChar LCMapStringW  @GetStringTypeA  CGetStringTypeW  GetLocaleInfoA  SetFilePointer  HeapSize  D CloseHandle WriteConsoleA GetConsoleOutputCP  WriteConsoleW SetStdHandle  y CreateFileA S CompareStringA  V CompareStringW  SetEnvironmentVariableA KERNEL32.dll  nReadFile  SetEndOfFile  &GetProcessHeap  GetFileAttributesA                                                                                                                                                                                                                                                                                                                                                                                                                                  +A     +A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              N@D#@    l@ \@ 
                                                                                     
      	               	      
                  
               
               !   
   5      A   
   C      P      R   
   S   
   W      Y      l   
   m       p      r   	            
      
      	            
      )      
                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                                                                                                                                                                                                                                                                                                                                       abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                     hA   `y!                       @~                                    @                                      A         [                       @~    Q  Q^  _j2                   1~    l@ C                                                                                              A             A             A             A             A                               HA         h@ @ p@ A A    A hA    @    @ 	   @ 
   @    @    @    @    \@    $@    @    @    @    d@    D@    @     @ !   @ "   @ x    @ y   @ z   @    @    @ @ @ @ @ @ @ @ @ @ @       x   
          h@ j@ @ @ @ @ @ @ @ x@ p@ h@ \@ P@ H@ <@ 8@ 4@ 0@ ,@ (@ $@  @ @ @ @ @ @ @ @ @ @ (@ @ @ @ @ @ @ @ @ @ @ |@ p@ 	         A .   DA )A )A )A )A )A )A )A )A )A HA    .                                                         p         PST                                                             PDT                                                             A A                    ;   Z   x                 0  N  m     :   Y   w                 /  M  l                                                                                                                                                                                                          l@ d@ \@ T@                
"""setuptools.errors

Provides exceptions used by setuptools modules.
"""

from distutils.errors import DistutilsError


class RemovedCommandError(DistutilsError, RuntimeError):
    """Error used for commands that have been removed in setuptools.

    Since ``setuptools`` is built on ``distutils``, simply removing a command
    from ``setuptools`` will make the behavior fall back to ``distutils``; this
    error is raised if a command exists in ``distutils`` but has been actively
    removed in ``setuptools``.
    """

from distutils.dep_util import newer_group


# yes, this is was almost entirely copy-pasted from
# 'newer_pairwise()', this is just another convenience
# function.
def newer_pairwise_group(sources_groups, targets):
    """Walk both arguments in parallel, testing if each source group is newer
    than its corresponding target. Returns a pair of lists (sources_groups,
    targets) where sources is newer than target, according to the semantics
    of 'newer_group()'.
    """
    if len(sources_groups) != len(targets):
        raise ValueError(
            "'sources_group' and 'targets' must be the same length")

    # build a pair of lists (sources_groups, targets) where source is newer
    n_sources = []
    n_targets = []
    for i in range(len(sources_groups)):
        if newer_group(sources_groups[i], targets[i]):
            n_sources.append(sources_groups[i])
            n_targets.append(targets[i])

    return n_sources, n_targets

"""
Improved support for Microsoft Visual C++ compilers.

Known supported compilers:
--------------------------
Microsoft Visual C++ 9.0:
    Microsoft Visual C++ Compiler for Python 2.7 (x86, amd64)
    Microsoft Windows SDK 6.1 (x86, x64, ia64)
    Microsoft Windows SDK 7.0 (x86, x64, ia64)

Microsoft Visual C++ 10.0:
    Microsoft Windows SDK 7.1 (x86, x64, ia64)

Microsoft Visual C++ 14.X:
    Microsoft Visual C++ Build Tools 2015 (x86, x64, arm)
    Microsoft Visual Studio Build Tools 2017 (x86, x64, arm, arm64)
    Microsoft Visual Studio Build Tools 2019 (x86, x64, arm, arm64)

This may also support compilers shipped with compatible Visual Studio versions.
"""

import json
from io import open
from os import listdir, pathsep
from os.path import join, isfile, isdir, dirname
import sys
import contextlib
import platform
import itertools
import subprocess
import distutils.errors
from setuptools.extern.packaging.version import LegacyVersion
from setuptools.extern.more_itertools import unique_everseen

from .monkey import get_unpatched

if platform.system() == 'Windows':
    import winreg
    from os import environ
else:
    # Mock winreg and environ so the module can be imported on this platform.

    class winreg:
        HKEY_USERS = None
        HKEY_CURRENT_USER = None
        HKEY_LOCAL_MACHINE = None
        HKEY_CLASSES_ROOT = None

    environ = dict()

_msvc9_suppress_errors = (
    # msvc9compiler isn't available on some platforms
    ImportError,

    # msvc9compiler raises DistutilsPlatformError in some
    # environments. See #1118.
    distutils.errors.DistutilsPlatformError,
)

try:
    from distutils.msvc9compiler import Reg
except _msvc9_suppress_errors:
    pass


def msvc9_find_vcvarsall(version):
    """
    Patched "distutils.msvc9compiler.find_vcvarsall" to use the standalone
    compiler build for Python
    (VCForPython / Microsoft Visual C++ Compiler for Python 2.7).

    Fall back to original behavior when the standalone compiler is not
    available.

    Redirect the path of "vcvarsall.bat".

    Parameters
    ----------
    version: float
        Required Microsoft Visual C++ version.

    Return
    ------
    str
        vcvarsall.bat path
    """
    vc_base = r'Software\%sMicrosoft\DevDiv\VCForPython\%0.1f'
    key = vc_base % ('', version)
    try:
        # Per-user installs register the compiler path here
        productdir = Reg.get_value(key, "installdir")
    except KeyError:
        try:
            # All-user installs on a 64-bit system register here
            key = vc_base % ('Wow6432Node\\', version)
            productdir = Reg.get_value(key, "installdir")
        except KeyError:
            productdir = None

    if productdir:
        vcvarsall = join(productdir, "vcvarsall.bat")
        if isfile(vcvarsall):
            return vcvarsall

    return get_unpatched(msvc9_find_vcvarsall)(version)


def msvc9_query_vcvarsall(ver, arch='x86', *args, **kwargs):
    """
    Patched "distutils.msvc9compiler.query_vcvarsall" for support extra
    Microsoft Visual C++ 9.0 and 10.0 compilers.

    Set environment without use of "vcvarsall.bat".

    Parameters
    ----------
    ver: float
        Required Microsoft Visual C++ version.
    arch: str
        Target architecture.

    Return
    ------
    dict
        environment
    """
    # Try to get environment from vcvarsall.bat (Classical way)
    try:
        orig = get_unpatched(msvc9_query_vcvarsall)
        return orig(ver, arch, *args, **kwargs)
    except distutils.errors.DistutilsPlatformError:
        # Pass error if Vcvarsall.bat is missing
        pass
    except ValueError:
        # Pass error if environment not set after executing vcvarsall.bat
        pass

    # If error, try to set environment directly
    try:
        return EnvironmentInfo(arch, ver).return_env()
    except distutils.errors.DistutilsPlatformError as exc:
        _augment_exception(exc, ver, arch)
        raise


def _msvc14_find_vc2015():
    """Python 3.8 "distutils/_msvccompiler.py" backport"""
    try:
        key = winreg.OpenKey(
            winreg.HKEY_LOCAL_MACHINE,
            r"Software\Microsoft\VisualStudio\SxS\VC7",
            0,
            winreg.KEY_READ | winreg.KEY_WOW64_32KEY
        )
    except OSError:
        return None, None

    best_version = 0
    best_dir = None
    with key:
        for i in itertools.count():
            try:
                v, vc_dir, vt = winreg.EnumValue(key, i)
            except OSError:
                break
            if v and vt == winreg.REG_SZ and isdir(vc_dir):
                try:
                    version = int(float(v))
                except (ValueError, TypeError):
                    continue
                if version >= 14 and version > best_version:
                    best_version, best_dir = version, vc_dir
    return best_version, best_dir


def _msvc14_find_vc2017():
    """Python 3.8 "distutils/_msvccompiler.py" backport

    Returns "15, path" based on the result of invoking vswhere.exe
    If no install is found, returns "None, None"

    The version is returned to avoid unnecessarily changing the function
    result. It may be ignored when the path is not None.

    If vswhere.exe is not available, by definition, VS 2017 is not
    installed.
    """
    root = environ.get("ProgramFiles(x86)") or environ.get("ProgramFiles")
    if not root:
        return None, None

    try:
        path = subprocess.check_output([
            join(root, "Microsoft Visual Studio", "Installer", "vswhere.exe"),
            "-latest",
            "-prerelease",
            "-requiresAny",
            "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
            "-requires", "Microsoft.VisualStudio.Workload.WDExpress",
            "-property", "installationPath",
            "-products", "*",
        ]).decode(encoding="mbcs", errors="strict").strip()
    except (subprocess.CalledProcessError, OSError, UnicodeDecodeError):
        return None, None

    path = join(path, "VC", "Auxiliary", "Build")
    if isdir(path):
        return 15, path

    return None, None


PLAT_SPEC_TO_RUNTIME = {
    'x86': 'x86',
    'x86_amd64': 'x64',
    'x86_arm': 'arm',
    'x86_arm64': 'arm64'
}


def _msvc14_find_vcvarsall(plat_spec):
    """Python 3.8 "distutils/_msvccompiler.py" backport"""
    _, best_dir = _msvc14_find_vc2017()
    vcruntime = None

    if plat_spec in PLAT_SPEC_TO_RUNTIME:
        vcruntime_plat = PLAT_SPEC_TO_RUNTIME[plat_spec]
    else:
        vcruntime_plat = 'x64' if 'amd64' in plat_spec else 'x86'

    if best_dir:
        vcredist = join(best_dir, "..", "..", "redist", "MSVC", "**",
                        vcruntime_plat, "Microsoft.VC14*.CRT",
                        "vcruntime140.dll")
        try:
            import glob
            vcruntime = glob.glob(vcredist, recursive=True)[-1]
        except (ImportError, OSError, LookupError):
            vcruntime = None

    if not best_dir:
        best_version, best_dir = _msvc14_find_vc2015()
        if best_version:
            vcruntime = join(best_dir, 'redist', vcruntime_plat,
                             "Microsoft.VC140.CRT", "vcruntime140.dll")

    if not best_dir:
        return None, None

    vcvarsall = join(best_dir, "vcvarsall.bat")
    if not isfile(vcvarsall):
        return None, None

    if not vcruntime or not isfile(vcruntime):
        vcruntime = None

    return vcvarsall, vcruntime


def _msvc14_get_vc_env(plat_spec):
    """Python 3.8 "distutils/_msvccompiler.py" backport"""
    if "DISTUTILS_USE_SDK" in environ:
        return {
            key.lower(): value
            for key, value in environ.items()
        }

    vcvarsall, vcruntime = _msvc14_find_vcvarsall(plat_spec)
    if not vcvarsall:
        raise distutils.errors.DistutilsPlatformError(
            "Unable to find vcvarsall.bat"
        )

    try:
        out = subprocess.check_output(
            'cmd /u /c "{}" {} && set'.format(vcvarsall, plat_spec),
            stderr=subprocess.STDOUT,
        ).decode('utf-16le', errors='replace')
    except subprocess.CalledProcessError as exc:
        raise distutils.errors.DistutilsPlatformError(
            "Error executing {}".format(exc.cmd)
        ) from exc

    env = {
        key.lower(): value
        for key, _, value in
        (line.partition('=') for line in out.splitlines())
        if key and value
    }

    if vcruntime:
        env['py_vcruntime_redist'] = vcruntime
    return env


def msvc14_get_vc_env(plat_spec):
    """
    Patched "distutils._msvccompiler._get_vc_env" for support extra
    Microsoft Visual C++ 14.X compilers.

    Set environment without use of "vcvarsall.bat".

    Parameters
    ----------
    plat_spec: str
        Target architecture.

    Return
    ------
    dict
        environment
    """

    # Always use backport from CPython 3.8
    try:
        return _msvc14_get_vc_env(plat_spec)
    except distutils.errors.DistutilsPlatformError as exc:
        _augment_exception(exc, 14.0)
        raise


def msvc14_gen_lib_options(*args, **kwargs):
    """
    Patched "distutils._msvccompiler.gen_lib_options" for fix
    compatibility between "numpy.distutils" and "distutils._msvccompiler"
    (for Numpy < 1.11.2)
    """
    if "numpy.distutils" in sys.modules:
        import numpy as np
        if LegacyVersion(np.__version__) < LegacyVersion('1.11.2'):
            return np.distutils.ccompiler.gen_lib_options(*args, **kwargs)
    return get_unpatched(msvc14_gen_lib_options)(*args, **kwargs)


def _augment_exception(exc, version, arch=''):
    """
    Add details to the exception message to help guide the user
    as to what action will resolve it.
    """
    # Error if MSVC++ directory not found or environment not set
    message = exc.args[0]

    if "vcvarsall" in message.lower() or "visual c" in message.lower():
        # Special error message if MSVC++ not installed
        tmpl = 'Microsoft Visual C++ {version:0.1f} or greater is required.'
        message = tmpl.format(**locals())
        msdownload = 'www.microsoft.com/download/details.aspx?id=%d'
        if version == 9.0:
            if arch.lower().find('ia64') > -1:
                # For VC++ 9.0, if IA64 support is needed, redirect user
                # to Windows SDK 7.0.
                # Note: No download link available from Microsoft.
                message += ' Get it with "Microsoft Windows SDK 7.0"'
            else:
                # For VC++ 9.0 redirect user to Vc++ for Python 2.7 :
                # This redirection link is maintained by Microsoft.
                # Contact vspython@microsoft.com if it needs updating.
                message += ' Get it from http://aka.ms/vcpython27'
        elif version == 10.0:
            # For VC++ 10.0 Redirect user to Windows SDK 7.1
            message += ' Get it with "Microsoft Windows SDK 7.1": '
            message += msdownload % 8279
        elif version >= 14.0:
            # For VC++ 14.X Redirect user to latest Visual C++ Build Tools
            message += (' Get it with "Microsoft C++ Build Tools": '
                        r'https://visualstudio.microsoft.com'
                        r'/visual-cpp-build-tools/')

    exc.args = (message, )


class PlatformInfo:
    """
    Current and Target Architectures information.

    Parameters
    ----------
    arch: str
        Target architecture.
    """
    current_cpu = environ.get('processor_architecture', '').lower()

    def __init__(self, arch):
        self.arch = arch.lower().replace('x64', 'amd64')

    @property
    def target_cpu(self):
        """
        Return Target CPU architecture.

        Return
        ------
        str
            Target CPU
        """
        return self.arch[self.arch.find('_') + 1:]

    def target_is_x86(self):
        """
        Return True if target CPU is x86 32 bits..

        Return
        ------
        bool
            CPU is x86 32 bits
        """
        return self.target_cpu == 'x86'

    def current_is_x86(self):
        """
        Return True if current CPU is x86 32 bits..

        Return
        ------
        bool
            CPU is x86 32 bits
        """
        return self.current_cpu == 'x86'

    def current_dir(self, hidex86=False, x64=False):
        """
        Current platform specific subfolder.

        Parameters
        ----------
        hidex86: bool
            return '' and not '\x86' if architecture is x86.
        x64: bool
            return '\x64' and not '\amd64' if architecture is amd64.

        Return
        ------
        str
            subfolder: '\target', or '' (see hidex86 parameter)
        """
        return (
            '' if (self.current_cpu == 'x86' and hidex86) else
            r'\x64' if (self.current_cpu == 'amd64' and x64) else
            r'\%s' % self.current_cpu
        )

    def target_dir(self, hidex86=False, x64=False):
        r"""
        Target platform specific subfolder.

        Parameters
        ----------
        hidex86: bool
            return '' and not '\x86' if architecture is x86.
        x64: bool
            return '\x64' and not '\amd64' if architecture is amd64.

        Return
        ------
        str
            subfolder: '\current', or '' (see hidex86 parameter)
        """
        return (
            '' if (self.target_cpu == 'x86' and hidex86) else
            r'\x64' if (self.target_cpu == 'amd64' and x64) else
            r'\%s' % self.target_cpu
        )

    def cross_dir(self, forcex86=False):
        r"""
        Cross platform specific subfolder.

        Parameters
        ----------
        forcex86: bool
            Use 'x86' as current architecture even if current architecture is
            not x86.

        Return
        ------
        str
            subfolder: '' if target architecture is current architecture,
            '\current_target' if not.
        """
        current = 'x86' if forcex86 else self.current_cpu
        return (
            '' if self.target_cpu == current else
            self.target_dir().replace('\\', '\\%s_' % current)
        )


class RegistryInfo:
    """
    Microsoft Visual Studio related registry information.

    Parameters
    ----------
    platform_info: PlatformInfo
        "PlatformInfo" instance.
    """
    HKEYS = (winreg.HKEY_USERS,
             winreg.HKEY_CURRENT_USER,
             winreg.HKEY_LOCAL_MACHINE,
             winreg.HKEY_CLASSES_ROOT)

    def __init__(self, platform_info):
        self.pi = platform_info

    @property
    def visualstudio(self):
        """
        Microsoft Visual Studio root registry key.

        Return
        ------
        str
            Registry key
        """
        return 'VisualStudio'

    @property
    def sxs(self):
        """
        Microsoft Visual Studio SxS registry key.

        Return
        ------
        str
            Registry key
        """
        return join(self.visualstudio, 'SxS')

    @property
    def vc(self):
        """
        Microsoft Visual C++ VC7 registry key.

        Return
        ------
        str
            Registry key
        """
        return join(self.sxs, 'VC7')

    @property
    def vs(self):
        """
        Microsoft Visual Studio VS7 registry key.

        Return
        ------
        str
            Registry key
        """
        return join(self.sxs, 'VS7')

    @property
    def vc_for_python(self):
        """
        Microsoft Visual C++ for Python registry key.

        Return
        ------
        str
            Registry key
        """
        return r'DevDiv\VCForPython'

    @property
    def microsoft_sdk(self):
        """
        Microsoft SDK registry key.

        Return
        ------
        str
            Registry key
        """
        return 'Microsoft SDKs'

    @property
    def windows_sdk(self):
        """
        Microsoft Windows/Platform SDK registry key.

        Return
        ------
        str
            Registry key
        """
        return join(self.microsoft_sdk, 'Windows')

    @property
    def netfx_sdk(self):
        """
        Microsoft .NET Framework SDK registry key.

        Return
        ------
        str
            Registry key
        """
        return join(self.microsoft_sdk, 'NETFXSDK')

    @property
    def windows_kits_roots(self):
        """
        Microsoft Windows Kits Roots registry key.

        Return
        ------
        str
            Registry key
        """
        return r'Windows Kits\Installed Roots'

    def microsoft(self, key, x86=False):
        """
        Return key in Microsoft software registry.

        Parameters
        ----------
        key: str
            Registry key path where look.
        x86: str
            Force x86 software registry.

        Return
        ------
        str
            Registry key
        """
        node64 = '' if self.pi.current_is_x86() or x86 else 'Wow6432Node'
        return join('Software', node64, 'Microsoft', key)

    def lookup(self, key, name):
        """
        Look for values in registry in Microsoft software registry.

        Parameters
        ----------
        key: str
            Registry key path where look.
        name: str
            Value name to find.

        Return
        ------
        str
            value
        """
        key_read = winreg.KEY_READ
        openkey = winreg.OpenKey
        closekey = winreg.CloseKey
        ms = self.microsoft
        for hkey in self.HKEYS:
            bkey = None
            try:
                bkey = openkey(hkey, ms(key), 0, key_read)
            except (OSError, IOError):
                if not self.pi.current_is_x86():
                    try:
                        bkey = openkey(hkey, ms(key, True), 0, key_read)
                    except (OSError, IOError):
                        continue
                else:
                    continue
            try:
                return winreg.QueryValueEx(bkey, name)[0]
            except (OSError, IOError):
                pass
            finally:
                if bkey:
                    closekey(bkey)


class SystemInfo:
    """
    Microsoft Windows and Visual Studio related system information.

    Parameters
    ----------
    registry_info: RegistryInfo
        "RegistryInfo" instance.
    vc_ver: float
        Required Microsoft Visual C++ version.
    """

    # Variables and properties in this class use originals CamelCase variables
    # names from Microsoft source files for more easy comparison.
    WinDir = environ.get('WinDir', '')
    ProgramFiles = environ.get('ProgramFiles', '')
    ProgramFilesx86 = environ.get('ProgramFiles(x86)', ProgramFiles)

    def __init__(self, registry_info, vc_ver=None):
        self.ri = registry_info
        self.pi = self.ri.pi

        self.known_vs_paths = self.find_programdata_vs_vers()

        # Except for VS15+, VC version is aligned with VS version
        self.vs_ver = self.vc_ver = (
            vc_ver or self._find_latest_available_vs_ver())

    def _find_latest_available_vs_ver(self):
        """
        Find the latest VC version

        Return
        ------
        float
            version
        """
        reg_vc_vers = self.find_reg_vs_vers()

        if not (reg_vc_vers or self.known_vs_paths):
            raise distutils.errors.DistutilsPlatformError(
                'No Microsoft Visual C++ version found')

        vc_vers = set(reg_vc_vers)
        vc_vers.update(self.known_vs_paths)
        return sorted(vc_vers)[-1]

    def find_reg_vs_vers(self):
        """
        Find Microsoft Visual Studio versions available in registry.

        Return
        ------
        list of float
            Versions
        """
        ms = self.ri.microsoft
        vckeys = (self.ri.vc, self.ri.vc_for_python, self.ri.vs)
        vs_vers = []
        for hkey, key in itertools.product(self.ri.HKEYS, vckeys):
            try:
                bkey = winreg.OpenKey(hkey, ms(key), 0, winreg.KEY_READ)
            except (OSError, IOError):
                continue
            with bkey:
                subkeys, values, _ = winreg.QueryInfoKey(bkey)
                for i in range(values):
                    with contextlib.suppress(ValueError):
                        ver = float(winreg.EnumValue(bkey, i)[0])
                        if ver not in vs_vers:
                            vs_vers.append(ver)
                for i in range(subkeys):
                    with contextlib.suppress(ValueError):
                        ver = float(winreg.EnumKey(bkey, i))
                        if ver not in vs_vers:
                            vs_vers.append(ver)
        return sorted(vs_vers)

    def find_programdata_vs_vers(self):
        r"""
        Find Visual studio 2017+ versions from information in
        "C:\ProgramData\Microsoft\VisualStudio\Packages\_Instances".

        Return
        ------
        dict
            float version as key, path as value.
        """
        vs_versions = {}
        instances_dir = \
            r'C:\ProgramData\Microsoft\VisualStudio\Packages\_Instances'

        try:
            hashed_names = listdir(instances_dir)

        except (OSError, IOError):
            # Directory not exists with all Visual Studio versions
            return vs_versions

        for name in hashed_names:
            try:
                # Get VS installation path from "state.json" file
                state_path = join(instances_dir, name, 'state.json')
                with open(state_path, 'rt', encoding='utf-8') as state_file:
                    state = json.load(state_file)
                vs_path = state['installationPath']

                # Raises OSError if this VS installation does not contain VC
                listdir(join(vs_path, r'VC\Tools\MSVC'))

                # Store version and path
                vs_versions[self._as_float_version(
                    state['installationVersion'])] = vs_path

            except (OSError, IOError, KeyError):
                # Skip if "state.json" file is missing or bad format
                continue

        return vs_versions

    @staticmethod
    def _as_float_version(version):
        """
        Return a string version as a simplified float version (major.minor)

        Parameters
        ----------
        version: str
            Version.

        Return
        ------
        float
            version
        """
        return float('.'.join(version.split('.')[:2]))

    @property
    def VSInstallDir(self):
        """
        Microsoft Visual Studio directory.

        Return
        ------
        str
            path
        """
        # Default path
        default = join(self.ProgramFilesx86,
                       'Microsoft Visual Studio %0.1f' % self.vs_ver)

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vs, '%0.1f' % self.vs_ver) or default

    @property
    def VCInstallDir(self):
        """
        Microsoft Visual C++ directory.

        Return
        ------
        str
            path
        """
        path = self._guess_vc() or self._guess_vc_legacy()

        if not isdir(path):
            msg = 'Microsoft Visual C++ directory not found'
            raise distutils.errors.DistutilsPlatformError(msg)

        return path

    def _guess_vc(self):
        """
        Locate Visual C++ for VS2017+.

        Return
        ------
        str
            path
        """
        if self.vs_ver <= 14.0:
            return ''

        try:
            # First search in known VS paths
            vs_dir = self.known_vs_paths[self.vs_ver]
        except KeyError:
            # Else, search with path from registry
            vs_dir = self.VSInstallDir

        guess_vc = join(vs_dir, r'VC\Tools\MSVC')

        # Subdir with VC exact version as name
        try:
            # Update the VC version with real one instead of VS version
            vc_ver = listdir(guess_vc)[-1]
            self.vc_ver = self._as_float_version(vc_ver)
            return join(guess_vc, vc_ver)
        except (OSError, IOError, IndexError):
            return ''

    def _guess_vc_legacy(self):
        """
        Locate Visual C++ for versions prior to 2017.

        Return
        ------
        str
            path
        """
        default = join(self.ProgramFilesx86,
                       r'Microsoft Visual Studio %0.1f\VC' % self.vs_ver)

        # Try to get "VC++ for Python" path from registry as default path
        reg_path = join(self.ri.vc_for_python, '%0.1f' % self.vs_ver)
        python_vc = self.ri.lookup(reg_path, 'installdir')
        default_vc = join(python_vc, 'VC') if python_vc else default

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vc, '%0.1f' % self.vs_ver) or default_vc

    @property
    def WindowsSdkVersion(self):
        """
        Microsoft Windows SDK versions for specified MSVC++ version.

        Return
        ------
        tuple of str
            versions
        """
        if self.vs_ver <= 9.0:
            return '7.0', '6.1', '6.0a'
        elif self.vs_ver == 10.0:
            return '7.1', '7.0a'
        elif self.vs_ver == 11.0:
            return '8.0', '8.0a'
        elif self.vs_ver == 12.0:
            return '8.1', '8.1a'
        elif self.vs_ver >= 14.0:
            return '10.0', '8.1'

    @property
    def WindowsSdkLastVersion(self):
        """
        Microsoft Windows SDK last version.

        Return
        ------
        str
            version
        """
        return self._use_last_dir_name(join(self.WindowsSdkDir, 'lib'))

    @property  # noqa: C901
    def WindowsSdkDir(self):  # noqa: C901  # is too complex (12)  # FIXME
        """
        Microsoft Windows SDK directory.

        Return
        ------
        str
            path
        """
        sdkdir = ''
        for ver in self.WindowsSdkVersion:
            # Try to get it from registry
            loc = join(self.ri.windows_sdk, 'v%s' % ver)
            sdkdir = self.ri.lookup(loc, 'installationfolder')
            if sdkdir:
                break
        if not sdkdir or not isdir(sdkdir):
            # Try to get "VC++ for Python" version from registry
            path = join(self.ri.vc_for_python, '%0.1f' % self.vc_ver)
            install_base = self.ri.lookup(path, 'installdir')
            if install_base:
                sdkdir = join(install_base, 'WinSDK')
        if not sdkdir or not isdir(sdkdir):
            # If fail, use default new path
            for ver in self.WindowsSdkVersion:
                intver = ver[:ver.rfind('.')]
                path = r'Microsoft SDKs\Windows Kits\%s' % intver
                d = join(self.ProgramFiles, path)
                if isdir(d):
                    sdkdir = d
        if not sdkdir or not isdir(sdkdir):
            # If fail, use default old path
            for ver in self.WindowsSdkVersion:
                path = r'Microsoft SDKs\Windows\v%s' % ver
                d = join(self.ProgramFiles, path)
                if isdir(d):
                    sdkdir = d
        if not sdkdir:
            # If fail, use Platform SDK
            sdkdir = join(self.VCInstallDir, 'PlatformSDK')
        return sdkdir

    @property
    def WindowsSDKExecutablePath(self):
        """
        Microsoft Windows SDK executable directory.

        Return
        ------
        str
            path
        """
        # Find WinSDK NetFx Tools registry dir name
        if self.vs_ver <= 11.0:
            netfxver = 35
            arch = ''
        else:
            netfxver = 40
            hidex86 = True if self.vs_ver <= 12.0 else False
            arch = self.pi.current_dir(x64=True, hidex86=hidex86)
        fx = 'WinSDK-NetFx%dTools%s' % (netfxver, arch.replace('\\', '-'))

        # list all possibles registry paths
        regpaths = []
        if self.vs_ver >= 14.0:
            for ver in self.NetFxSdkVersion:
                regpaths += [join(self.ri.netfx_sdk, ver, fx)]

        for ver in self.WindowsSdkVersion:
            regpaths += [join(self.ri.windows_sdk, 'v%sA' % ver, fx)]

        # Return installation folder from the more recent path
        for path in regpaths:
            execpath = self.ri.lookup(path, 'installationfolder')
            if execpath:
                return execpath

    @property
    def FSharpInstallDir(self):
        """
        Microsoft Visual F# directory.

        Return
        ------
        str
            path
        """
        path = join(self.ri.visualstudio, r'%0.1f\Setup\F#' % self.vs_ver)
        return self.ri.lookup(path, 'productdir') or ''

    @property
    def UniversalCRTSdkDir(self):
        """
        Microsoft Universal CRT SDK directory.

        Return
        ------
        str
            path
        """
        # Set Kit Roots versions for specified MSVC++ version
        vers = ('10', '81') if self.vs_ver >= 14.0 else ()

        # Find path of the more recent Kit
        for ver in vers:
            sdkdir = self.ri.lookup(self.ri.windows_kits_roots,
                                    'kitsroot%s' % ver)
            if sdkdir:
                return sdkdir or ''

    @property
    def UniversalCRTSdkLastVersion(self):
        """
        Microsoft Universal C Runtime SDK last version.

        Return
        ------
        str
            version
        """
        return self._use_last_dir_name(join(self.UniversalCRTSdkDir, 'lib'))

    @property
    def NetFxSdkVersion(self):
        """
        Microsoft .NET Framework SDK versions.

        Return
        ------
        tuple of str
            versions
        """
        # Set FxSdk versions for specified VS version
        return (('4.7.2', '4.7.1', '4.7',
                 '4.6.2', '4.6.1', '4.6',
                 '4.5.2', '4.5.1', '4.5')
                if self.vs_ver >= 14.0 else ())

    @property
    def NetFxSdkDir(self):
        """
        Microsoft .NET Framework SDK directory.

        Return
        ------
        str
            path
        """
        sdkdir = ''
        for ver in self.NetFxSdkVersion:
            loc = join(self.ri.netfx_sdk, ver)
            sdkdir = self.ri.lookup(loc, 'kitsinstallationfolder')
            if sdkdir:
                break
        return sdkdir

    @property
    def FrameworkDir32(self):
        """
        Microsoft .NET Framework 32bit directory.

        Return
        ------
        str
            path
        """
        # Default path
        guess_fw = join(self.WinDir, r'Microsoft.NET\Framework')

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vc, 'frameworkdir32') or guess_fw

    @property
    def FrameworkDir64(self):
        """
        Microsoft .NET Framework 64bit directory.

        Return
        ------
        str
            path
        """
        # Default path
        guess_fw = join(self.WinDir, r'Microsoft.NET\Framework64')

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vc, 'frameworkdir64') or guess_fw

    @property
    def FrameworkVersion32(self):
        """
        Microsoft .NET Framework 32bit versions.

        Return
        ------
        tuple of str
            versions
        """
        return self._find_dot_net_versions(32)

    @property
    def FrameworkVersion64(self):
        """
        Microsoft .NET Framework 64bit versions.

        Return
        ------
        tuple of str
            versions
        """
        return self._find_dot_net_versions(64)

    def _find_dot_net_versions(self, bits):
        """
        Find Microsoft .NET Framework versions.

        Parameters
        ----------
        bits: int
            Platform number of bits: 32 or 64.

        Return
        ------
        tuple of str
            versions
        """
        # Find actual .NET version in registry
        reg_ver = self.ri.lookup(self.ri.vc, 'frameworkver%d' % bits)
        dot_net_dir = getattr(self, 'FrameworkDir%d' % bits)
        ver = reg_ver or self._use_last_dir_name(dot_net_dir, 'v') or ''

        # Set .NET versions for specified MSVC++ version
        if self.vs_ver >= 12.0:
            return ver, 'v4.0'
        elif self.vs_ver >= 10.0:
            return 'v4.0.30319' if ver.lower()[:2] != 'v4' else ver, 'v3.5'
        elif self.vs_ver == 9.0:
            return 'v3.5', 'v2.0.50727'
        elif self.vs_ver == 8.0:
            return 'v3.0', 'v2.0.50727'

    @staticmethod
    def _use_last_dir_name(path, prefix=''):
        """
        Return name of the last dir in path or '' if no dir found.

        Parameters
        ----------
        path: str
            Use dirs in this path
        prefix: str
            Use only dirs starting by this prefix

        Return
        ------
        str
            name
        """
        matching_dirs = (
            dir_name
            for dir_name in reversed(listdir(path))
            if isdir(join(path, dir_name)) and
            dir_name.startswith(prefix)
        )
        return next(matching_dirs, None) or ''


class EnvironmentInfo:
    """
    Return environment variables for specified Microsoft Visual C++ version
    and platform : Lib, Include, Path and libpath.

    This function is compatible with Microsoft Visual C++ 9.0 to 14.X.

    Script created by analysing Microsoft environment configuration files like
    "vcvars[...].bat", "SetEnv.Cmd", "vcbuildtools.bat", ...

    Parameters
    ----------
    arch: str
        Target architecture.
    vc_ver: float
        Required Microsoft Visual C++ version. If not set, autodetect the last
        version.
    vc_min_ver: float
        Minimum Microsoft Visual C++ version.
    """

    # Variables and properties in this class use originals CamelCase variables
    # names from Microsoft source files for more easy comparison.

    def __init__(self, arch, vc_ver=None, vc_min_ver=0):
        self.pi = PlatformInfo(arch)
        self.ri = RegistryInfo(self.pi)
        self.si = SystemInfo(self.ri, vc_ver)

        if self.vc_ver < vc_min_ver:
            err = 'No suitable Microsoft Visual C++ version found'
            raise distutils.errors.DistutilsPlatformError(err)

    @property
    def vs_ver(self):
        """
        Microsoft Visual Studio.

        Return
        ------
        float
            version
        """
        return self.si.vs_ver

    @property
    def vc_ver(self):
        """
        Microsoft Visual C++ version.

        Return
        ------
        float
            version
        """
        return self.si.vc_ver

    @property
    def VSTools(self):
        """
        Microsoft Visual Studio Tools.

        Return
        ------
        list of str
            paths
        """
        paths = [r'Common7\IDE', r'Common7\Tools']

        if self.vs_ver >= 14.0:
            arch_subdir = self.pi.current_dir(hidex86=True, x64=True)
            paths += [r'Common7\IDE\CommonExtensions\Microsoft\TestWindow']
            paths += [r'Team Tools\Performance Tools']
            paths += [r'Team Tools\Performance Tools%s' % arch_subdir]

        return [join(self.si.VSInstallDir, path) for path in paths]

    @property
    def VCIncludes(self):
        """
        Microsoft Visual C++ & Microsoft Foundation Class Includes.

        Return
        ------
        list of str
            paths
        """
        return [join(self.si.VCInstallDir, 'Include'),
                join(self.si.VCInstallDir, r'ATLMFC\Include')]

    @property
    def VCLibraries(self):
        """
        Microsoft Visual C++ & Microsoft Foundation Class Libraries.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver >= 15.0:
            arch_subdir = self.pi.target_dir(x64=True)
        else:
            arch_subdir = self.pi.target_dir(hidex86=True)
        paths = ['Lib%s' % arch_subdir, r'ATLMFC\Lib%s' % arch_subdir]

        if self.vs_ver >= 14.0:
            paths += [r'Lib\store%s' % arch_subdir]

        return [join(self.si.VCInstallDir, path) for path in paths]

    @property
    def VCStoreRefs(self):
        """
        Microsoft Visual C++ store references Libraries.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 14.0:
            return []
        return [join(self.si.VCInstallDir, r'Lib\store\references')]

    @property
    def VCTools(self):
        """
        Microsoft Visual C++ Tools.

        Return
        ------
        list of str
            paths
        """
        si = self.si
        tools = [join(si.VCInstallDir, 'VCPackages')]

        forcex86 = True if self.vs_ver <= 10.0 else False
        arch_subdir = self.pi.cross_dir(forcex86)
        if arch_subdir:
            tools += [join(si.VCInstallDir, 'Bin%s' % arch_subdir)]

        if self.vs_ver == 14.0:
            path = 'Bin%s' % self.pi.current_dir(hidex86=True)
            tools += [join(si.VCInstallDir, path)]

        elif self.vs_ver >= 15.0:
            host_dir = (r'bin\HostX86%s' if self.pi.current_is_x86() else
                        r'bin\HostX64%s')
            tools += [join(
                si.VCInstallDir, host_dir % self.pi.target_dir(x64=True))]

            if self.pi.current_cpu != self.pi.target_cpu:
                tools += [join(
                    si.VCInstallDir, host_dir % self.pi.current_dir(x64=True))]

        else:
            tools += [join(si.VCInstallDir, 'Bin')]

        return tools

    @property
    def OSLibraries(self):
        """
        Microsoft Windows SDK Libraries.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver <= 10.0:
            arch_subdir = self.pi.target_dir(hidex86=True, x64=True)
            return [join(self.si.WindowsSdkDir, 'Lib%s' % arch_subdir)]

        else:
            arch_subdir = self.pi.target_dir(x64=True)
            lib = join(self.si.WindowsSdkDir, 'lib')
            libver = self._sdk_subdir
            return [join(lib, '%sum%s' % (libver, arch_subdir))]

    @property
    def OSIncludes(self):
        """
        Microsoft Windows SDK Include.

        Return
        ------
        list of str
            paths
        """
        include = join(self.si.WindowsSdkDir, 'include')

        if self.vs_ver <= 10.0:
            return [include, join(include, 'gl')]

        else:
            if self.vs_ver >= 14.0:
                sdkver = self._sdk_subdir
            else:
                sdkver = ''
            return [join(include, '%sshared' % sdkver),
                    join(include, '%sum' % sdkver),
                    join(include, '%swinrt' % sdkver)]

    @property
    def OSLibpath(self):
        """
        Microsoft Windows SDK Libraries Paths.

        Return
        ------
        list of str
            paths
        """
        ref = join(self.si.WindowsSdkDir, 'References')
        libpath = []

        if self.vs_ver <= 9.0:
            libpath += self.OSLibraries

        if self.vs_ver >= 11.0:
            libpath += [join(ref, r'CommonConfiguration\Neutral')]

        if self.vs_ver >= 14.0:
            libpath += [
                ref,
                join(self.si.WindowsSdkDir, 'UnionMetadata'),
                join(
                    ref, 'Windows.Foundation.UniversalApiContract', '1.0.0.0'),
                join(ref, 'Windows.Foundation.FoundationContract', '1.0.0.0'),
                join(
                    ref, 'Windows.Networking.Connectivity.WwanContract',
                    '1.0.0.0'),
                join(
                    self.si.WindowsSdkDir, 'ExtensionSDKs', 'Microsoft.VCLibs',
                    '%0.1f' % self.vs_ver, 'References', 'CommonConfiguration',
                    'neutral'),
            ]
        return libpath

    @property
    def SdkTools(self):
        """
        Microsoft Windows SDK Tools.

        Return
        ------
        list of str
            paths
        """
        return list(self._sdk_tools())

    def _sdk_tools(self):
        """
        Microsoft Windows SDK Tools paths generator.

        Return
        ------
        generator of str
            paths
        """
        if self.vs_ver < 15.0:
            bin_dir = 'Bin' if self.vs_ver <= 11.0 else r'Bin\x86'
            yield join(self.si.WindowsSdkDir, bin_dir)

        if not self.pi.current_is_x86():
            arch_subdir = self.pi.current_dir(x64=True)
            path = 'Bin%s' % arch_subdir
            yield join(self.si.WindowsSdkDir, path)

        if self.vs_ver in (10.0, 11.0):
            if self.pi.target_is_x86():
                arch_subdir = ''
            else:
                arch_subdir = self.pi.current_dir(hidex86=True, x64=True)
            path = r'Bin\NETFX 4.0 Tools%s' % arch_subdir
            yield join(self.si.WindowsSdkDir, path)

        elif self.vs_ver >= 15.0:
            path = join(self.si.WindowsSdkDir, 'Bin')
            arch_subdir = self.pi.current_dir(x64=True)
            sdkver = self.si.WindowsSdkLastVersion
            yield join(path, '%s%s' % (sdkver, arch_subdir))

        if self.si.WindowsSDKExecutablePath:
            yield self.si.WindowsSDKExecutablePath

    @property
    def _sdk_subdir(self):
        """
        Microsoft Windows SDK version subdir.

        Return
        ------
        str
            subdir
        """
        ucrtver = self.si.WindowsSdkLastVersion
        return ('%s\\' % ucrtver) if ucrtver else ''

    @property
    def SdkSetup(self):
        """
        Microsoft Windows SDK Setup.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver > 9.0:
            return []

        return [join(self.si.WindowsSdkDir, 'Setup')]

    @property
    def FxTools(self):
        """
        Microsoft .NET Framework Tools.

        Return
        ------
        list of str
            paths
        """
        pi = self.pi
        si = self.si

        if self.vs_ver <= 10.0:
            include32 = True
            include64 = not pi.target_is_x86() and not pi.current_is_x86()
        else:
            include32 = pi.target_is_x86() or pi.current_is_x86()
            include64 = pi.current_cpu == 'amd64' or pi.target_cpu == 'amd64'

        tools = []
        if include32:
            tools += [join(si.FrameworkDir32, ver)
                      for ver in si.FrameworkVersion32]
        if include64:
            tools += [join(si.FrameworkDir64, ver)
                      for ver in si.FrameworkVersion64]
        return tools

    @property
    def NetFxSDKLibraries(self):
        """
        Microsoft .Net Framework SDK Libraries.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 14.0 or not self.si.NetFxSdkDir:
            return []

        arch_subdir = self.pi.target_dir(x64=True)
        return [join(self.si.NetFxSdkDir, r'lib\um%s' % arch_subdir)]

    @property
    def NetFxSDKIncludes(self):
        """
        Microsoft .Net Framework SDK Includes.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 14.0 or not self.si.NetFxSdkDir:
            return []

        return [join(self.si.NetFxSdkDir, r'include\um')]

    @property
    def VsTDb(self):
        """
        Microsoft Visual Studio Team System Database.

        Return
        ------
        list of str
            paths
        """
        return [join(self.si.VSInstallDir, r'VSTSDB\Deploy')]

    @property
    def MSBuild(self):
        """
        Microsoft Build Engine.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 12.0:
            return []
        elif self.vs_ver < 15.0:
            base_path = self.si.ProgramFilesx86
            arch_subdir = self.pi.current_dir(hidex86=True)
        else:
            base_path = self.si.VSInstallDir
            arch_subdir = ''

        path = r'MSBuild\%0.1f\bin%s' % (self.vs_ver, arch_subdir)
        build = [join(base_path, path)]

        if self.vs_ver >= 15.0:
            # Add Roslyn C# & Visual Basic Compiler
            build += [join(base_path, path, 'Roslyn')]

        return build

    @property
    def HTMLHelpWorkshop(self):
        """
        Microsoft HTML Help Workshop.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 11.0:
            return []

        return [join(self.si.ProgramFilesx86, 'HTML Help Workshop')]

    @property
    def UCRTLibraries(self):
        """
        Microsoft Universal C Runtime SDK Libraries.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 14.0:
            return []

        arch_subdir = self.pi.target_dir(x64=True)
        lib = join(self.si.UniversalCRTSdkDir, 'lib')
        ucrtver = self._ucrt_subdir
        return [join(lib, '%sucrt%s' % (ucrtver, arch_subdir))]

    @property
    def UCRTIncludes(self):
        """
        Microsoft Universal C Runtime SDK Include.

        Return
        ------
        list of str
            paths
        """
        if self.vs_ver < 14.0:
            return []

        include = join(self.si.UniversalCRTSdkDir, 'include')
        return [join(include, '%sucrt' % self._ucrt_subdir)]

    @property
    def _ucrt_subdir(self):
        """
        Microsoft Universal C Runtime SDK version subdir.

        Return
        ------
        str
            subdir
        """
        ucrtver = self.si.UniversalCRTSdkLastVersion
        return ('%s\\' % ucrtver) if ucrtver else ''

    @property
    def FSharp(self):
        """
        Microsoft Visual F#.

        Return
        ------
        list of str
            paths
        """
        if 11.0 > self.vs_ver > 12.0:
            return []

        return [self.si.FSharpInstallDir]

    @property
    def VCRuntimeRedist(self):
        """
        Microsoft Visual C++ runtime redistributable dll.

        Return
        ------
        str
            path
        """
        vcruntime = 'vcruntime%d0.dll' % self.vc_ver
        arch_subdir = self.pi.target_dir(x64=True).strip('\\')

        # Installation prefixes candidates
        prefixes = []
        tools_path = self.si.VCInstallDir
        redist_path = dirname(tools_path.replace(r'\Tools', r'\Redist'))
        if isdir(redist_path):
            # Redist version may not be exactly the same as tools
            redist_path = join(redist_path, listdir(redist_path)[-1])
            prefixes += [redist_path, join(redist_path, 'onecore')]

        prefixes += [join(tools_path, 'redist')]  # VS14 legacy path

        # CRT directory
        crt_dirs = ('Microsoft.VC%d.CRT' % (self.vc_ver * 10),
                    # Sometime store in directory with VS version instead of VC
                    'Microsoft.VC%d.CRT' % (int(self.vs_ver) * 10))

        # vcruntime path
        for prefix, crt_dir in itertools.product(prefixes, crt_dirs):
            path = join(prefix, arch_subdir, crt_dir, vcruntime)
            if isfile(path):
                return path

    def return_env(self, exists=True):
        """
        Return environment dict.

        Parameters
        ----------
        exists: bool
            It True, only return existing paths.

        Return
        ------
        dict
            environment
        """
        env = dict(
            include=self._build_paths('include',
                                      [self.VCIncludes,
                                       self.OSIncludes,
                                       self.UCRTIncludes,
                    